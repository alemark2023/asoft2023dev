webpackJsonp([1],{

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"./node_modules/webpack/buildin/global.js\"), __webpack_require__(\"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz85YjJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(\"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz9kN2FkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLDZDQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.dev.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.7.14\n * (c) 2014-2022 Evan You\n * Released under the MIT License.\n */\n\n\nconst emptyObject = Object.freeze({});\nconst isArray = Array.isArray;\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef(v) {\n    return v === undefined || v === null;\n}\nfunction isDef(v) {\n    return v !== undefined && v !== null;\n}\nfunction isTrue(v) {\n    return v === true;\n}\nfunction isFalse(v) {\n    return v === false;\n}\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive(value) {\n    return (typeof value === 'string' ||\n        typeof value === 'number' ||\n        // $flow-disable-line\n        typeof value === 'symbol' ||\n        typeof value === 'boolean');\n}\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Quick object check - this is primarily used to tell\n * objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nconst _toString = Object.prototype.toString;\nfunction toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n}\nfunction isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n}\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex(val) {\n    const n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction isPromise(val) {\n    return (isDef(val) &&\n        typeof val.then === 'function' &&\n        typeof val.catch === 'function');\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n    return val == null\n        ? ''\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n            ? JSON.stringify(val, null, 2)\n            : String(val);\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];\n}\n/**\n * Check if a tag is a built-in tag.\n */\nconst isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\nconst isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Remove an item from an array.\n */\nfunction remove$2(arr, item) {\n    const len = arr.length;\n    if (len) {\n        // fast path for the only / last item\n        if (item === arr[len - 1]) {\n            arr.length = len - 1;\n            return;\n        }\n        const index = arr.indexOf(item);\n        if (index > -1) {\n            return arr.splice(index, 1);\n        }\n    }\n}\n/**\n * Check whether an object has the property.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n    const cache = Object.create(null);\n    return function cachedFn(str) {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cached((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\n/**\n * Capitalize a string.\n */\nconst capitalize = cached((str) => {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cached((str) => {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n/* istanbul ignore next */\nfunction polyfillBind(fn, ctx) {\n    function boundFn(a) {\n        const l = arguments.length;\n        return l\n            ? l > 1\n                ? fn.apply(ctx, arguments)\n                : fn.call(ctx, a)\n            : fn.call(ctx);\n    }\n    boundFn._length = fn.length;\n    return boundFn;\n}\nfunction nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n}\n// @ts-expect-error bind cannot be `undefined`\nconst bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n    start = start || 0;\n    let i = list.length - start;\n    const ret = new Array(i);\n    while (i--) {\n        ret[i] = list[i + start];\n    }\n    return ret;\n}\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n    for (const key in _from) {\n        to[key] = _from[key];\n    }\n    return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n    const res = {};\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i]) {\n            extend(res, arr[i]);\n        }\n    }\n    return res;\n}\n/* eslint-disable no-unused-vars */\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop(a, b, c) { }\n/**\n * Always return false.\n */\nconst no = (a, b, c) => false;\n/* eslint-enable no-unused-vars */\n/**\n * Return the same value.\n */\nconst identity = (_) => _;\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys$1(modules) {\n    return modules\n        .reduce((keys, m) => {\n        return keys.concat(m.staticKeys || []);\n    }, [])\n        .join(',');\n}\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    const isObjectA = isObject(a);\n    const isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n        try {\n            const isArrayA = Array.isArray(a);\n            const isArrayB = Array.isArray(b);\n            if (isArrayA && isArrayB) {\n                return (a.length === b.length &&\n                    a.every((e, i) => {\n                        return looseEqual(e, b[i]);\n                    }));\n            }\n            else if (a instanceof Date && b instanceof Date) {\n                return a.getTime() === b.getTime();\n            }\n            else if (!isArrayA && !isArrayB) {\n                const keysA = Object.keys(a);\n                const keysB = Object.keys(b);\n                return (keysA.length === keysB.length &&\n                    keysA.every(key => {\n                        return looseEqual(a[key], b[key]);\n                    }));\n            }\n            else {\n                /* istanbul ignore next */\n                return false;\n            }\n        }\n        catch (e) {\n            /* istanbul ignore next */\n            return false;\n        }\n    }\n    else if (!isObjectA && !isObjectB) {\n        return String(a) === String(b);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf(arr, val) {\n    for (let i = 0; i < arr.length; i++) {\n        if (looseEqual(arr[i], val))\n            return i;\n    }\n    return -1;\n}\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n    let called = false;\n    return function () {\n        if (!called) {\n            called = true;\n            fn.apply(this, arguments);\n        }\n    };\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\nfunction hasChanged(x, y) {\n    if (x === y) {\n        return x === 0 && 1 / x !== 1 / y;\n    }\n    else {\n        return x === x || y === y;\n    }\n}\n\nconst SSR_ATTR = 'data-server-rendered';\nconst ASSET_TYPES = ['component', 'directive', 'filter'];\nconst LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch',\n    'renderTracked',\n    'renderTriggered'\n];\n\nvar config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: true,\n    /**\n     * Whether to enable devtools\n     */\n    devtools: true,\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nconst unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n    const c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5f;\n}\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n    });\n}\n/**\n * Parse simple path.\n */\nconst bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\\\d]`);\nfunction parsePath(path) {\n    if (bailRE.test(path)) {\n        return;\n    }\n    const segments = path.split('.');\n    return function (obj) {\n        for (let i = 0; i < segments.length; i++) {\n            if (!obj)\n                return;\n            obj = obj[segments[i]];\n        }\n        return obj;\n    };\n}\n\n// can we use __proto__?\nconst hasProto = '__proto__' in {};\n// Browser environment sniffing\nconst inBrowser = typeof window !== 'undefined';\nconst UA = inBrowser && window.navigator.userAgent.toLowerCase();\nconst isIE = UA && /msie|trident/.test(UA);\nconst isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nconst isEdge = UA && UA.indexOf('edge/') > 0;\nUA && UA.indexOf('android') > 0;\nconst isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\nUA && /phantomjs/.test(UA);\nconst isFF = UA && UA.match(/firefox\\/(\\d+)/);\n// Firefox has a \"watch\" function on Object.prototype...\n// @ts-expect-error firebox support\nconst nativeWatch = {}.watch;\nlet supportsPassive = false;\nif (inBrowser) {\n    try {\n        const opts = {};\n        Object.defineProperty(opts, 'passive', {\n            get() {\n                /* istanbul ignore next */\n                supportsPassive = true;\n            }\n        }); // https://github.com/facebook/flow/issues/285\n        window.addEventListener('test-passive', null, opts);\n    }\n    catch (e) { }\n}\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nlet _isServer;\nconst isServerRendering = () => {\n    if (_isServer === undefined) {\n        /* istanbul ignore if */\n        if (!inBrowser && typeof global !== 'undefined') {\n            // detect presence of vue-server-renderer and avoid\n            // Webpack shimming the process\n            _isServer =\n                global['process'] && global['process'].env.VUE_ENV === 'server';\n        }\n        else {\n            _isServer = false;\n        }\n    }\n    return _isServer;\n};\n// detect devtools\nconst devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\nconst hasSymbol = typeof Symbol !== 'undefined' &&\n    isNative(Symbol) &&\n    typeof Reflect !== 'undefined' &&\n    isNative(Reflect.ownKeys);\nlet _Set; // $flow-disable-line\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n}\nelse {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = class Set {\n        constructor() {\n            this.set = Object.create(null);\n        }\n        has(key) {\n            return this.set[key] === true;\n        }\n        add(key) {\n            this.set[key] = true;\n        }\n        clear() {\n            this.set = Object.create(null);\n        }\n    };\n}\n\nlet currentInstance = null;\n/**\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\n * relies on it). Do not use this internally, just use `currentInstance`.\n *\n * @internal this function needs manual type declaration because it relies\n * on previously manually authored types from Vue 2\n */\nfunction getCurrentInstance() {\n    return currentInstance && { proxy: currentInstance };\n}\n/**\n * @internal\n */\nfunction setCurrentInstance(vm = null) {\n    if (!vm)\n        currentInstance && currentInstance._scope.off();\n    currentInstance = vm;\n    vm && vm._scope.on();\n}\n\n/**\n * @internal\n */\nclass VNode {\n    constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n        this.tag = tag;\n        this.data = data;\n        this.children = children;\n        this.text = text;\n        this.elm = elm;\n        this.ns = undefined;\n        this.context = context;\n        this.fnContext = undefined;\n        this.fnOptions = undefined;\n        this.fnScopeId = undefined;\n        this.key = data && data.key;\n        this.componentOptions = componentOptions;\n        this.componentInstance = undefined;\n        this.parent = undefined;\n        this.raw = false;\n        this.isStatic = false;\n        this.isRootInsert = true;\n        this.isComment = false;\n        this.isCloned = false;\n        this.isOnce = false;\n        this.asyncFactory = asyncFactory;\n        this.asyncMeta = undefined;\n        this.isAsyncPlaceholder = false;\n    }\n    // DEPRECATED: alias for componentInstance for backwards compat.\n    /* istanbul ignore next */\n    get child() {\n        return this.componentInstance;\n    }\n}\nconst createEmptyVNode = (text = '') => {\n    const node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n};\nfunction createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n}\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n    const cloned = new VNode(vnode.tag, vnode.data, \n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\nlet initProxy;\n{\n    const allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +\n        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +\n        'require' // for Webpack/Browserify\n    );\n    const warnNonPresent = (target, key) => {\n        warn$2(`Property or method \"${key}\" is not defined on the instance but ` +\n            'referenced during render. Make sure that this property is reactive, ' +\n            'either in the data option, or for class-based components, by ' +\n            'initializing the property. ' +\n            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n    const warnReservedPrefix = (target, key) => {\n        warn$2(`Property \"${key}\" must be accessed with \"$data.${key}\" because ` +\n            'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n            'prevent conflicts with Vue internals. ' +\n            'See: https://v2.vuejs.org/v2/api/#data', target);\n    };\n    const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n    if (hasProxy) {\n        const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n        config.keyCodes = new Proxy(config.keyCodes, {\n            set(target, key, value) {\n                if (isBuiltInModifier(key)) {\n                    warn$2(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);\n                    return false;\n                }\n                else {\n                    target[key] = value;\n                    return true;\n                }\n            }\n        });\n    }\n    const hasHandler = {\n        has(target, key) {\n            const has = key in target;\n            const isAllowed = allowedGlobals(key) ||\n                (typeof key === 'string' &&\n                    key.charAt(0) === '_' &&\n                    !(key in target.$data));\n            if (!has && !isAllowed) {\n                if (key in target.$data)\n                    warnReservedPrefix(target, key);\n                else\n                    warnNonPresent(target, key);\n            }\n            return has || !isAllowed;\n        }\n    };\n    const getHandler = {\n        get(target, key) {\n            if (typeof key === 'string' && !(key in target)) {\n                if (key in target.$data)\n                    warnReservedPrefix(target, key);\n                else\n                    warnNonPresent(target, key);\n            }\n            return target[key];\n        }\n    };\n    initProxy = function initProxy(vm) {\n        if (hasProxy) {\n            // determine which proxy handler to use\n            const options = vm.$options;\n            const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n            vm._renderProxy = new Proxy(vm, handlers);\n        }\n        else {\n            vm._renderProxy = vm;\n        }\n    };\n}\n\nlet uid$2 = 0;\nconst pendingCleanupDeps = [];\nconst cleanupDeps = () => {\n    for (let i = 0; i < pendingCleanupDeps.length; i++) {\n        const dep = pendingCleanupDeps[i];\n        dep.subs = dep.subs.filter(s => s);\n        dep._pending = false;\n    }\n    pendingCleanupDeps.length = 0;\n};\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n * @internal\n */\nclass Dep {\n    constructor() {\n        // pending subs cleanup\n        this._pending = false;\n        this.id = uid$2++;\n        this.subs = [];\n    }\n    addSub(sub) {\n        this.subs.push(sub);\n    }\n    removeSub(sub) {\n        // #12696 deps with massive amount of subscribers are extremely slow to\n        // clean up in Chromium\n        // to workaround this, we unset the sub for now, and clear them on\n        // next scheduler flush.\n        this.subs[this.subs.indexOf(sub)] = null;\n        if (!this._pending) {\n            this._pending = true;\n            pendingCleanupDeps.push(this);\n        }\n    }\n    depend(info) {\n        if (Dep.target) {\n            Dep.target.addDep(this);\n            if (info && Dep.target.onTrack) {\n                Dep.target.onTrack(Object.assign({ effect: Dep.target }, info));\n            }\n        }\n    }\n    notify(info) {\n        // stabilize the subscriber list first\n        const subs = this.subs.filter(s => s);\n        if (!config.async) {\n            // subs aren't sorted in scheduler if not running async\n            // we need to sort them now to make sure they fire in correct\n            // order\n            subs.sort((a, b) => a.id - b.id);\n        }\n        for (let i = 0, l = subs.length; i < l; i++) {\n            const sub = subs[i];\n            if (info) {\n                sub.onTrigger &&\n                    sub.onTrigger(Object.assign({ effect: subs[i] }, info));\n            }\n            sub.update();\n        }\n    }\n}\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nconst targetStack = [];\nfunction pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n}\nfunction popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\nconst arrayProto = Array.prototype;\nconst arrayMethods = Object.create(arrayProto);\nconst methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n];\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n    // cache original method\n    const original = arrayProto[method];\n    def(arrayMethods, method, function mutator(...args) {\n        const result = original.apply(this, args);\n        const ob = this.__ob__;\n        let inserted;\n        switch (method) {\n            case 'push':\n            case 'unshift':\n                inserted = args;\n                break;\n            case 'splice':\n                inserted = args.slice(2);\n                break;\n        }\n        if (inserted)\n            ob.observeArray(inserted);\n        // notify change\n        {\n            ob.dep.notify({\n                type: \"array mutation\" /* TriggerOpTypes.ARRAY_MUTATION */,\n                target: this,\n                key: method\n            });\n        }\n        return result;\n    });\n});\n\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods);\nconst NO_INIITIAL_VALUE = {};\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nlet shouldObserve = true;\nfunction toggleObserving(value) {\n    shouldObserve = value;\n}\n// ssr mock dep\nconst mockDep = {\n    notify: noop,\n    depend: noop,\n    addSub: noop,\n    removeSub: noop\n};\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nclass Observer {\n    constructor(value, shallow = false, mock = false) {\n        this.value = value;\n        this.shallow = shallow;\n        this.mock = mock;\n        // this.value = value\n        this.dep = mock ? mockDep : new Dep();\n        this.vmCount = 0;\n        def(value, '__ob__', this);\n        if (isArray(value)) {\n            if (!mock) {\n                if (hasProto) {\n                    value.__proto__ = arrayMethods;\n                    /* eslint-enable no-proto */\n                }\n                else {\n                    for (let i = 0, l = arrayKeys.length; i < l; i++) {\n                        const key = arrayKeys[i];\n                        def(value, key, arrayMethods[key]);\n                    }\n                }\n            }\n            if (!shallow) {\n                this.observeArray(value);\n            }\n        }\n        else {\n            /**\n             * Walk through all properties and convert them into\n             * getter/setters. This method should only be called when\n             * value type is Object.\n             */\n            const keys = Object.keys(value);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);\n            }\n        }\n    }\n    /**\n     * Observe a list of Array items.\n     */\n    observeArray(value) {\n        for (let i = 0, l = value.length; i < l; i++) {\n            observe(value[i], false, this.mock);\n        }\n    }\n}\n// helpers\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, shallow, ssrMockReactivity) {\n    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n        return value.__ob__;\n    }\n    if (shouldObserve &&\n        (ssrMockReactivity || !isServerRendering()) &&\n        (isArray(value) || isPlainObject(value)) &&\n        Object.isExtensible(value) &&\n        !value.__v_skip /* ReactiveFlags.SKIP */ &&\n        !isRef(value) &&\n        !(value instanceof VNode)) {\n        return new Observer(value, shallow, ssrMockReactivity);\n    }\n}\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive(obj, key, val, customSetter, shallow, mock) {\n    const dep = new Dep();\n    const property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n        return;\n    }\n    // cater for pre-defined getter/setters\n    const getter = property && property.get;\n    const setter = property && property.set;\n    if ((!getter || setter) &&\n        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {\n        val = obj[key];\n    }\n    let childOb = !shallow && observe(val, false, mock);\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            const value = getter ? getter.call(obj) : val;\n            if (Dep.target) {\n                {\n                    dep.depend({\n                        target: obj,\n                        type: \"get\" /* TrackOpTypes.GET */,\n                        key\n                    });\n                }\n                if (childOb) {\n                    childOb.dep.depend();\n                    if (isArray(value)) {\n                        dependArray(value);\n                    }\n                }\n            }\n            return isRef(value) && !shallow ? value.value : value;\n        },\n        set: function reactiveSetter(newVal) {\n            const value = getter ? getter.call(obj) : val;\n            if (!hasChanged(value, newVal)) {\n                return;\n            }\n            if (customSetter) {\n                customSetter();\n            }\n            if (setter) {\n                setter.call(obj, newVal);\n            }\n            else if (getter) {\n                // #7981: for accessor properties without setter\n                return;\n            }\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\n                value.value = newVal;\n                return;\n            }\n            else {\n                val = newVal;\n            }\n            childOb = !shallow && observe(newVal, false, mock);\n            {\n                dep.notify({\n                    type: \"set\" /* TriggerOpTypes.SET */,\n                    target: obj,\n                    key,\n                    newValue: newVal,\n                    oldValue: value\n                });\n            }\n        }\n    });\n    return dep;\n}\nfunction set(target, key, val) {\n    if ((isUndef(target) || isPrimitive(target))) {\n        warn$2(`Cannot set reactive property on undefined, null, or primitive value: ${target}`);\n    }\n    if (isReadonly(target)) {\n        warn$2(`Set operation on key \"${key}\" failed: target is readonly.`);\n        return;\n    }\n    const ob = target.__ob__;\n    if (isArray(target) && isValidArrayIndex(key)) {\n        target.length = Math.max(target.length, key);\n        target.splice(key, 1, val);\n        // when mocking for SSR, array methods are not hijacked\n        if (ob && !ob.shallow && ob.mock) {\n            observe(val, false, true);\n        }\n        return val;\n    }\n    if (key in target && !(key in Object.prototype)) {\n        target[key] = val;\n        return val;\n    }\n    if (target._isVue || (ob && ob.vmCount)) {\n        warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +\n                'at runtime - declare it upfront in the data option.');\n        return val;\n    }\n    if (!ob) {\n        target[key] = val;\n        return val;\n    }\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\n    {\n        ob.dep.notify({\n            type: \"add\" /* TriggerOpTypes.ADD */,\n            target: target,\n            key,\n            newValue: val,\n            oldValue: undefined\n        });\n    }\n    return val;\n}\nfunction del(target, key) {\n    if ((isUndef(target) || isPrimitive(target))) {\n        warn$2(`Cannot delete reactive property on undefined, null, or primitive value: ${target}`);\n    }\n    if (isArray(target) && isValidArrayIndex(key)) {\n        target.splice(key, 1);\n        return;\n    }\n    const ob = target.__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n        warn$2('Avoid deleting properties on a Vue instance or its root $data ' +\n                '- just set it to null.');\n        return;\n    }\n    if (isReadonly(target)) {\n        warn$2(`Delete operation on key \"${key}\" failed: target is readonly.`);\n        return;\n    }\n    if (!hasOwn(target, key)) {\n        return;\n    }\n    delete target[key];\n    if (!ob) {\n        return;\n    }\n    {\n        ob.dep.notify({\n            type: \"delete\" /* TriggerOpTypes.DELETE */,\n            target: target,\n            key\n        });\n    }\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n    for (let e, i = 0, l = value.length; i < l; i++) {\n        e = value[i];\n        if (e && e.__ob__) {\n            e.__ob__.dep.depend();\n        }\n        if (isArray(e)) {\n            dependArray(e);\n        }\n    }\n}\n\nfunction reactive(target) {\n    makeReactive(target, false);\n    return target;\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    makeReactive(target, true);\n    def(target, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\n    return target;\n}\nfunction makeReactive(target, shallow) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (!isReadonly(target)) {\n        {\n            if (isArray(target)) {\n                warn$2(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);\n            }\n            const existingOb = target && target.__ob__;\n            if (existingOb && existingOb.shallow !== shallow) {\n                warn$2(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);\n            }\n        }\n        const ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);\n        if (!ob) {\n            if (target == null || isPrimitive(target)) {\n                warn$2(`value cannot be made reactive: ${String(target)}`);\n            }\n            if (isCollectionType(target)) {\n                warn$2(`Vue 2 does not support reactive collection types such as Map or Set.`);\n            }\n        }\n    }\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value.__ob__);\n}\nfunction isShallow(value) {\n    return !!(value && value.__v_isShallow);\n}\nfunction isReadonly(value) {\n    return !!(value && value.__v_isReadonly);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    // non-extensible objects won't be observed anyway\n    if (Object.isExtensible(value)) {\n        def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    }\n    return value;\n}\n/**\n * @internal\n */\nfunction isCollectionType(value) {\n    const type = toRawType(value);\n    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');\n}\n\n/**\n * @internal\n */\nconst RefFlag = `__v_isRef`;\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref$1(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    const ref = {};\n    def(ref, RefFlag, true);\n    def(ref, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, shallow);\n    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\n    return ref;\n}\nfunction triggerRef(ref) {\n    if (!ref.dep) {\n        warn$2(`received object is not a triggerable ref.`);\n    }\n    {\n        ref.dep &&\n            ref.dep.notify({\n                type: \"set\" /* TriggerOpTypes.SET */,\n                target: ref,\n                key: 'value'\n            });\n    }\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nfunction proxyRefs(objectWithRefs) {\n    if (isReactive(objectWithRefs)) {\n        return objectWithRefs;\n    }\n    const proxy = {};\n    const keys = Object.keys(objectWithRefs);\n    for (let i = 0; i < keys.length; i++) {\n        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\n    }\n    return proxy;\n}\nfunction proxyWithRefUnwrap(target, source, key) {\n    Object.defineProperty(target, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => {\n            const val = source[key];\n            if (isRef(val)) {\n                return val.value;\n            }\n            else {\n                const ob = val && val.__ob__;\n                if (ob)\n                    ob.dep.depend();\n                return val;\n            }\n        },\n        set: value => {\n            const oldValue = source[key];\n            if (isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n            }\n            else {\n                source[key] = value;\n            }\n        }\n    });\n}\nfunction customRef(factory) {\n    const dep = new Dep();\n    const { get, set } = factory(() => {\n        {\n            dep.depend({\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n    }, () => {\n        {\n            dep.notify({\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value'\n            });\n        }\n    });\n    const ref = {\n        get value() {\n            return get();\n        },\n        set value(newVal) {\n            set(newVal);\n        }\n    };\n    def(ref, RefFlag, true);\n    return ref;\n}\nfunction toRefs(object) {\n    if (!isReactive(object)) {\n        warn$2(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    if (isRef(val)) {\n        return val;\n    }\n    const ref = {\n        get value() {\n            const val = object[key];\n            return val === undefined ? defaultValue : val;\n        },\n        set value(newVal) {\n            object[key] = newVal;\n        }\n    };\n    def(ref, RefFlag, true);\n    return ref;\n}\n\nconst rawToReadonlyFlag = `__v_rawToReadonly`;\nconst rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;\nfunction readonly(target) {\n    return createReadonly(target, false);\n}\nfunction createReadonly(target, shallow) {\n    if (!isPlainObject(target)) {\n        {\n            if (isArray(target)) {\n                warn$2(`Vue 2 does not support readonly arrays.`);\n            }\n            else if (isCollectionType(target)) {\n                warn$2(`Vue 2 does not support readonly collection types such as Map or Set.`);\n            }\n            else {\n                warn$2(`value cannot be made readonly: ${typeof target}`);\n            }\n        }\n        return target;\n    }\n    if (!Object.isExtensible(target)) {\n        warn$2(`Vue 2 does not support creating readonly proxy for non-extensible object.`);\n    }\n    // already a readonly object\n    if (isReadonly(target)) {\n        return target;\n    }\n    // already has a readonly proxy\n    const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\n    const existingProxy = target[existingFlag];\n    if (existingProxy) {\n        return existingProxy;\n    }\n    const proxy = Object.create(Object.getPrototypeOf(target));\n    def(target, existingFlag, proxy);\n    def(proxy, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, true);\n    def(proxy, \"__v_raw\" /* ReactiveFlags.RAW */, target);\n    if (isRef(target)) {\n        def(proxy, RefFlag, true);\n    }\n    if (shallow || isShallow(target)) {\n        def(proxy, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\n    }\n    const keys = Object.keys(target);\n    for (let i = 0; i < keys.length; i++) {\n        defineReadonlyProperty(proxy, target, keys[i], shallow);\n    }\n    return proxy;\n}\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\n    Object.defineProperty(proxy, key, {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const val = target[key];\n            return shallow || !isPlainObject(val) ? val : readonly(val);\n        },\n        set() {\n            warn$2(`Set operation on key \"${key}\" failed: target is readonly.`);\n        }\n    });\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReadonly(target, true);\n}\n\nfunction computed(getterOrOptions, debugOptions) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = () => {\n                warn$2('Write operation failed: computed value is readonly');\n            }\n            ;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const watcher = isServerRendering()\n        ? null\n        : new Watcher(currentInstance, getter, noop, { lazy: true });\n    if (watcher && debugOptions) {\n        watcher.onTrack = debugOptions.onTrack;\n        watcher.onTrigger = debugOptions.onTrigger;\n    }\n    const ref = {\n        // some libs rely on the presence effect for checking computed refs\n        // from normal refs, but the implementation doesn't matter\n        effect: watcher,\n        get value() {\n            if (watcher) {\n                if (watcher.dirty) {\n                    watcher.evaluate();\n                }\n                if (Dep.target) {\n                    if (Dep.target.onTrack) {\n                        Dep.target.onTrack({\n                            effect: Dep.target,\n                            target: ref,\n                            type: \"get\" /* TrackOpTypes.GET */,\n                            key: 'value'\n                        });\n                    }\n                    watcher.depend();\n                }\n                return watcher.value;\n            }\n            else {\n                return getter();\n            }\n        },\n        set value(newVal) {\n            setter(newVal);\n        }\n    };\n    def(ref, RefFlag, true);\n    def(ref, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, onlyGetter);\n    return ref;\n}\n\nlet mark;\nlet measure;\n{\n    const perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (perf &&\n        // @ts-ignore\n        perf.mark &&\n        // @ts-ignore\n        perf.measure &&\n        // @ts-ignore\n        perf.clearMarks &&\n        // @ts-ignore\n        perf.clearMeasures) {\n        mark = tag => perf.mark(tag);\n        measure = (name, startTag, endTag) => {\n            perf.measure(name, startTag, endTag);\n            perf.clearMarks(startTag);\n            perf.clearMarks(endTag);\n            // perf.clearMeasures(name)\n        };\n    }\n}\n\nconst normalizeEvent = cached((name) => {\n    const passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    const once = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once ? name.slice(1) : name;\n    const capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n        name,\n        once,\n        capture,\n        passive\n    };\n});\nfunction createFnInvoker(fns, vm) {\n    function invoker() {\n        const fns = invoker.fns;\n        if (isArray(fns)) {\n            const cloned = fns.slice();\n            for (let i = 0; i < cloned.length; i++) {\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);\n            }\n        }\n        else {\n            // return handler return value for single handlers\n            return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`);\n        }\n    }\n    invoker.fns = fns;\n    return invoker;\n}\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\n    let name, cur, old, event;\n    for (name in on) {\n        cur = on[name];\n        old = oldOn[name];\n        event = normalizeEvent(name);\n        if (isUndef(cur)) {\n            warn$2(`Invalid handler for event \"${event.name}\": got ` + String(cur), vm);\n        }\n        else if (isUndef(old)) {\n            if (isUndef(cur.fns)) {\n                cur = on[name] = createFnInvoker(cur, vm);\n            }\n            if (isTrue(event.once)) {\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n            }\n            add(event.name, cur, event.capture, event.passive, event.params);\n        }\n        else if (cur !== old) {\n            old.fns = cur;\n            on[name] = old;\n        }\n    }\n    for (name in oldOn) {\n        if (isUndef(on[name])) {\n            event = normalizeEvent(name);\n            remove(event.name, oldOn[name], event.capture);\n        }\n    }\n}\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n        def = def.data.hook || (def.data.hook = {});\n    }\n    let invoker;\n    const oldHook = def[hookKey];\n    function wrappedHook() {\n        hook.apply(this, arguments);\n        // important: remove merged hook to ensure it's called only once\n        // and prevent memory leak\n        remove$2(invoker.fns, wrappedHook);\n    }\n    if (isUndef(oldHook)) {\n        // no existing hook\n        invoker = createFnInvoker([wrappedHook]);\n    }\n    else {\n        /* istanbul ignore if */\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n            // already a merged invoker\n            invoker = oldHook;\n            invoker.fns.push(wrappedHook);\n        }\n        else {\n            // existing plain hook\n            invoker = createFnInvoker([oldHook, wrappedHook]);\n        }\n    }\n    invoker.merged = true;\n    def[hookKey] = invoker;\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    const propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n        return;\n    }\n    const res = {};\n    const { attrs, props } = data;\n    if (isDef(attrs) || isDef(props)) {\n        for (const key in propOptions) {\n            const altKey = hyphenate(key);\n            {\n                const keyInLowerCase = key.toLowerCase();\n                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n                    tip(`Prop \"${keyInLowerCase}\" is passed to component ` +\n                        `${formatComponentName(\n                        // @ts-expect-error tag is string\n                        tag || Ctor)}, but the declared prop name is` +\n                        ` \"${key}\". ` +\n                        `Note that HTML attributes are case-insensitive and camelCased ` +\n                        `props need to use their kebab-case equivalents when using in-DOM ` +\n                        `templates. You should probably use \"${altKey}\" instead of \"${key}\".`);\n                }\n            }\n            checkProp(res, props, key, altKey, true) ||\n                checkProp(res, attrs, key, altKey, false);\n        }\n    }\n    return res;\n}\nfunction checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n        if (hasOwn(hash, key)) {\n            res[key] = hash[key];\n            if (!preserve) {\n                delete hash[key];\n            }\n            return true;\n        }\n        else if (hasOwn(hash, altKey)) {\n            res[key] = hash[altKey];\n            if (!preserve) {\n                delete hash[altKey];\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n        if (isArray(children[i])) {\n            return Array.prototype.concat.apply([], children);\n        }\n    }\n    return children;\n}\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n    return isPrimitive(children)\n        ? [createTextVNode(children)]\n        : isArray(children)\n            ? normalizeArrayChildren(children)\n            : undefined;\n}\nfunction isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\nfunction normalizeArrayChildren(children, nestedIndex) {\n    const res = [];\n    let i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n        c = children[i];\n        if (isUndef(c) || typeof c === 'boolean')\n            continue;\n        lastIndex = res.length - 1;\n        last = res[lastIndex];\n        //  nested\n        if (isArray(c)) {\n            if (c.length > 0) {\n                c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`);\n                // merge adjacent text nodes\n                if (isTextNode(c[0]) && isTextNode(last)) {\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\n                    c.shift();\n                }\n                res.push.apply(res, c);\n            }\n        }\n        else if (isPrimitive(c)) {\n            if (isTextNode(last)) {\n                // merge adjacent text nodes\n                // this is necessary for SSR hydration because text nodes are\n                // essentially merged when rendered to HTML strings\n                res[lastIndex] = createTextVNode(last.text + c);\n            }\n            else if (c !== '') {\n                // convert primitive to vnode\n                res.push(createTextVNode(c));\n            }\n        }\n        else {\n            if (isTextNode(c) && isTextNode(last)) {\n                // merge adjacent text nodes\n                res[lastIndex] = createTextVNode(last.text + c.text);\n            }\n            else {\n                // default key for nested array children (likely generated by v-for)\n                if (isTrue(children._isVList) &&\n                    isDef(c.tag) &&\n                    isUndef(c.key) &&\n                    isDef(nestedIndex)) {\n                    c.key = `__vlist${nestedIndex}_${i}__`;\n                }\n                res.push(c);\n            }\n        }\n    }\n    return res;\n}\n\nconst SIMPLE_NORMALIZE = 1;\nconst ALWAYS_NORMALIZE = 2;\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (isArray(data) || isPrimitive(data)) {\n        normalizationType = children;\n        children = data;\n        data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n        normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n}\nfunction _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n        warn$2(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + 'Always create fresh vnode data objects in each render!', context);\n        return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n        tag = data.is;\n    }\n    if (!tag) {\n        // in case of component :is set to falsy value\n        return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n        warn$2('Avoid using non-primitive value as key, ' +\n            'use string/number value instead.', context);\n    }\n    // support single function children as default scoped slot\n    if (isArray(children) && isFunction(children[0])) {\n        data = data || {};\n        data.scopedSlots = { default: children[0] };\n        children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children);\n    }\n    else if (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children);\n    }\n    let vnode, ns;\n    if (typeof tag === 'string') {\n        let Ctor;\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n        if (config.isReservedTag(tag)) {\n            // platform built-in elements\n            if (isDef(data) &&\n                isDef(data.nativeOn) &&\n                data.tag !== 'component') {\n                warn$2(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);\n            }\n            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n        }\n        else if ((!data || !data.pre) &&\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\n            // component\n            vnode = createComponent(Ctor, data, context, children, tag);\n        }\n        else {\n            // unknown or unlisted namespaced elements\n            // check at runtime because it may get assigned a namespace when its\n            // parent normalizes children\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\n        }\n    }\n    else {\n        // direct component options / constructor\n        vnode = createComponent(tag, data, context, children);\n    }\n    if (isArray(vnode)) {\n        return vnode;\n    }\n    else if (isDef(vnode)) {\n        if (isDef(ns))\n            applyNS(vnode, ns);\n        if (isDef(data))\n            registerDeepBindings(data);\n        return vnode;\n    }\n    else {\n        return createEmptyVNode();\n    }\n}\nfunction applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n        // use default namespace inside foreignObject\n        ns = undefined;\n        force = true;\n    }\n    if (isDef(vnode.children)) {\n        for (let i = 0, l = vnode.children.length; i < l; i++) {\n            const child = vnode.children[i];\n            if (isDef(child.tag) &&\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n                applyNS(child, ns, force);\n            }\n        }\n    }\n}\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings(data) {\n    if (isObject(data.style)) {\n        traverse(data.style);\n    }\n    if (isObject(data.class)) {\n        traverse(data.class);\n    }\n}\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n    let ret = null, i, l, keys, key;\n    if (isArray(val) || typeof val === 'string') {\n        ret = new Array(val.length);\n        for (i = 0, l = val.length; i < l; i++) {\n            ret[i] = render(val[i], i);\n        }\n    }\n    else if (typeof val === 'number') {\n        ret = new Array(val);\n        for (i = 0; i < val; i++) {\n            ret[i] = render(i + 1, i);\n        }\n    }\n    else if (isObject(val)) {\n        if (hasSymbol && val[Symbol.iterator]) {\n            ret = [];\n            const iterator = val[Symbol.iterator]();\n            let result = iterator.next();\n            while (!result.done) {\n                ret.push(render(result.value, ret.length));\n                result = iterator.next();\n            }\n        }\n        else {\n            keys = Object.keys(val);\n            ret = new Array(keys.length);\n            for (i = 0, l = keys.length; i < l; i++) {\n                key = keys[i];\n                ret[i] = render(val[key], key, i);\n            }\n        }\n    }\n    if (!isDef(ret)) {\n        ret = [];\n    }\n    ret._isVList = true;\n    return ret;\n}\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n    const scopedSlotFn = this.$scopedSlots[name];\n    let nodes;\n    if (scopedSlotFn) {\n        // scoped slot\n        props = props || {};\n        if (bindObject) {\n            if (!isObject(bindObject)) {\n                warn$2('slot v-bind without argument expects an Object', this);\n            }\n            props = extend(extend({}, bindObject), props);\n        }\n        nodes =\n            scopedSlotFn(props) ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    else {\n        nodes =\n            this.$slots[name] ||\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\n    }\n    const target = props && props.slot;\n    if (target) {\n        return this.$createElement('template', { slot: target }, nodes);\n    }\n    else {\n        return nodes;\n    }\n}\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\nfunction isKeyNotMatch(expect, actual) {\n    if (isArray(expect)) {\n        return expect.indexOf(actual) === -1;\n    }\n    else {\n        return expect !== actual;\n    }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\n    }\n    else if (mappedKeyCode) {\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    }\n    else if (eventKeyName) {\n        return hyphenate(eventKeyName) !== key;\n    }\n    return eventKeyCode === undefined;\n}\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n        if (!isObject(value)) {\n            warn$2('v-bind without argument expects an Object or Array value', this);\n        }\n        else {\n            if (isArray(value)) {\n                value = toObject(value);\n            }\n            let hash;\n            for (const key in value) {\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n                    hash = data;\n                }\n                else {\n                    const type = data.attrs && data.attrs.type;\n                    hash =\n                        asProp || config.mustUseProp(tag, type, key)\n                            ? data.domProps || (data.domProps = {})\n                            : data.attrs || (data.attrs = {});\n                }\n                const camelizedKey = camelize(key);\n                const hyphenatedKey = hyphenate(key);\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n                    hash[key] = value[key];\n                    if (isSync) {\n                        const on = data.on || (data.on = {});\n                        on[`update:${key}`] = function ($event) {\n                            value[key] = $event;\n                        };\n                    }\n                }\n            }\n        }\n    }\n    return data;\n}\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n    const cached = this._staticTrees || (this._staticTrees = []);\n    let tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n        return tree;\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\n    );\n    markStatic$1(tree, `__static__${index}`, false);\n    return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n    markStatic$1(tree, `__once__${index}${key ? `_${key}` : ``}`, true);\n    return tree;\n}\nfunction markStatic$1(tree, key, isOnce) {\n    if (isArray(tree)) {\n        for (let i = 0; i < tree.length; i++) {\n            if (tree[i] && typeof tree[i] !== 'string') {\n                markStaticNode(tree[i], `${key}_${i}`, isOnce);\n            }\n        }\n    }\n    else {\n        markStaticNode(tree, key, isOnce);\n    }\n}\nfunction markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n}\n\nfunction bindObjectListeners(data, value) {\n    if (value) {\n        if (!isPlainObject(value)) {\n            warn$2('v-on without argument expects an Object value', this);\n        }\n        else {\n            const on = (data.on = data.on ? extend({}, data.on) : {});\n            for (const key in value) {\n                const existing = on[key];\n                const ours = value[key];\n                on[key] = existing ? [].concat(existing, ours) : ours;\n            }\n        }\n    }\n    return data;\n}\n\nfunction resolveScopedSlots(fns, res, \n// the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (let i = 0; i < fns.length; i++) {\n        const slot = fns[i];\n        if (isArray(slot)) {\n            resolveScopedSlots(slot, res, hasDynamicKeys);\n        }\n        else if (slot) {\n            // marker for reverse proxying v-slot without scope on this.$slots\n            // @ts-expect-error\n            if (slot.proxy) {\n                // @ts-expect-error\n                slot.fn.proxy = true;\n            }\n            res[slot.key] = slot.fn;\n        }\n    }\n    if (contentHashKey) {\n        res.$key = contentHashKey;\n    }\n    return res;\n}\n\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\nfunction bindDynamicKeys(baseObj, values) {\n    for (let i = 0; i < values.length; i += 2) {\n        const key = values[i];\n        if (typeof key === 'string' && key) {\n            baseObj[values[i]] = values[i + 1];\n        }\n        else if (key !== '' && key !== null) {\n            // null is a special value for explicitly removing a binding\n            warn$2(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);\n        }\n    }\n    return baseObj;\n}\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n}\n\nfunction installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n}\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n    if (!children || !children.length) {\n        return {};\n    }\n    const slots = {};\n    for (let i = 0, l = children.length; i < l; i++) {\n        const child = children[i];\n        const data = child.data;\n        // remove slot attribute if the node is resolved as a Vue slot node\n        if (data && data.attrs && data.attrs.slot) {\n            delete data.attrs.slot;\n        }\n        // named slots should only be respected if the vnode was rendered in the\n        // same context.\n        if ((child.context === context || child.fnContext === context) &&\n            data &&\n            data.slot != null) {\n            const name = data.slot;\n            const slot = slots[name] || (slots[name] = []);\n            if (child.tag === 'template') {\n                slot.push.apply(slot, child.children || []);\n            }\n            else {\n                slot.push(child);\n            }\n        }\n        else {\n            (slots.default || (slots.default = [])).push(child);\n        }\n    }\n    // ignore slots that contains only whitespace\n    for (const name in slots) {\n        if (slots[name].every(isWhitespace)) {\n            delete slots[name];\n        }\n    }\n    return slots;\n}\nfunction isWhitespace(node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\n}\n\nfunction isAsyncPlaceholder(node) {\n    // @ts-expect-error not really boolean type\n    return node.isComment && node.asyncFactory;\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\n    let res;\n    const hasNormalSlots = Object.keys(normalSlots).length > 0;\n    const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\n    const key = scopedSlots && scopedSlots.$key;\n    if (!scopedSlots) {\n        res = {};\n    }\n    else if (scopedSlots._normalized) {\n        // fast path 1: child component re-render only, parent did not change\n        return scopedSlots._normalized;\n    }\n    else if (isStable &&\n        prevScopedSlots &&\n        prevScopedSlots !== emptyObject &&\n        key === prevScopedSlots.$key &&\n        !hasNormalSlots &&\n        !prevScopedSlots.$hasNormal) {\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\n        // only need to normalize once\n        return prevScopedSlots;\n    }\n    else {\n        res = {};\n        for (const key in scopedSlots) {\n            if (scopedSlots[key] && key[0] !== '$') {\n                res[key] = normalizeScopedSlot(ownerVm, normalSlots, key, scopedSlots[key]);\n            }\n        }\n    }\n    // expose normal slots on scopedSlots\n    for (const key in normalSlots) {\n        if (!(key in res)) {\n            res[key] = proxyNormalSlot(normalSlots, key);\n        }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\n        scopedSlots._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n}\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\n    const normalized = function () {\n        const cur = currentInstance;\n        setCurrentInstance(vm);\n        let res = arguments.length ? fn.apply(null, arguments) : fn({});\n        res =\n            res && typeof res === 'object' && !isArray(res)\n                ? [res] // single vnode\n                : normalizeChildren(res);\n        const vnode = res && res[0];\n        setCurrentInstance(cur);\n        return res &&\n            (!vnode ||\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\n            ? undefined\n            : res;\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n        Object.defineProperty(normalSlots, key, {\n            get: normalized,\n            enumerable: true,\n            configurable: true\n        });\n    }\n    return normalized;\n}\nfunction proxyNormalSlot(slots, key) {\n    return () => slots[key];\n}\n\nfunction initSetup(vm) {\n    const options = vm.$options;\n    const setup = options.setup;\n    if (setup) {\n        const ctx = (vm._setupContext = createSetupContext(vm));\n        setCurrentInstance(vm);\n        pushTarget();\n        const setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, `setup`);\n        popTarget();\n        setCurrentInstance();\n        if (isFunction(setupResult)) {\n            // render function\n            // @ts-ignore\n            options.render = setupResult;\n        }\n        else if (isObject(setupResult)) {\n            // bindings\n            if (setupResult instanceof VNode) {\n                warn$2(`setup() should not return VNodes directly - ` +\n                    `return a render function instead.`);\n            }\n            vm._setupState = setupResult;\n            // __sfc indicates compiled bindings from <script setup>\n            if (!setupResult.__sfc) {\n                for (const key in setupResult) {\n                    if (!isReserved(key)) {\n                        proxyWithRefUnwrap(vm, setupResult, key);\n                    }\n                    else {\n                        warn$2(`Avoid using variables that start with _ or $ in setup().`);\n                    }\n                }\n            }\n            else {\n                // exposed for compiled render fn\n                const proxy = (vm._setupProxy = {});\n                for (const key in setupResult) {\n                    if (key !== '__sfc') {\n                        proxyWithRefUnwrap(proxy, setupResult, key);\n                    }\n                }\n            }\n        }\n        else if (setupResult !== undefined) {\n            warn$2(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\n        }\n    }\n}\nfunction createSetupContext(vm) {\n    let exposeCalled = false;\n    return {\n        get attrs() {\n            if (!vm._attrsProxy) {\n                const proxy = (vm._attrsProxy = {});\n                def(proxy, '_v_attr_proxy', true);\n                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\n            }\n            return vm._attrsProxy;\n        },\n        get listeners() {\n            if (!vm._listenersProxy) {\n                const proxy = (vm._listenersProxy = {});\n                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\n            }\n            return vm._listenersProxy;\n        },\n        get slots() {\n            return initSlotsProxy(vm);\n        },\n        emit: bind$1(vm.$emit, vm),\n        expose(exposed) {\n            {\n                if (exposeCalled) {\n                    warn$2(`expose() should be called only once per setup().`, vm);\n                }\n                exposeCalled = true;\n            }\n            if (exposed) {\n                Object.keys(exposed).forEach(key => proxyWithRefUnwrap(vm, exposed, key));\n            }\n        }\n    };\n}\nfunction syncSetupProxy(to, from, prev, instance, type) {\n    let changed = false;\n    for (const key in from) {\n        if (!(key in to)) {\n            changed = true;\n            defineProxyAttr(to, key, instance, type);\n        }\n        else if (from[key] !== prev[key]) {\n            changed = true;\n        }\n    }\n    for (const key in to) {\n        if (!(key in from)) {\n            changed = true;\n            delete to[key];\n        }\n    }\n    return changed;\n}\nfunction defineProxyAttr(proxy, key, instance, type) {\n    Object.defineProperty(proxy, key, {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return instance[type][key];\n        }\n    });\n}\nfunction initSlotsProxy(vm) {\n    if (!vm._slotsProxy) {\n        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);\n    }\n    return vm._slotsProxy;\n}\nfunction syncSetupSlots(to, from) {\n    for (const key in from) {\n        to[key] = from[key];\n    }\n    for (const key in to) {\n        if (!(key in from)) {\n            delete to[key];\n        }\n    }\n}\n/**\n * @internal use manual type def because public setup context type relies on\n * legacy VNode types\n */\nfunction useSlots() {\n    return getContext().slots;\n}\n/**\n * @internal use manual type def because public setup context type relies on\n * legacy VNode types\n */\nfunction useAttrs() {\n    return getContext().attrs;\n}\n/**\n * Vue 2 only\n * @internal use manual type def because public setup context type relies on\n * legacy VNode types\n */\nfunction useListeners() {\n    return getContext().listeners;\n}\nfunction getContext() {\n    if (!currentInstance) {\n        warn$2(`useContext() called without active instance.`);\n    }\n    const vm = currentInstance;\n    return vm._setupContext || (vm._setupContext = createSetupContext(vm));\n}\n/**\n * Runtime helper for merging default declarations. Imported by compiled code\n * only.\n * @internal\n */\nfunction mergeDefaults(raw, defaults) {\n    const props = isArray(raw)\n        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})\n        : raw;\n    for (const key in defaults) {\n        const opt = props[key];\n        if (opt) {\n            if (isArray(opt) || isFunction(opt)) {\n                props[key] = { type: opt, default: defaults[key] };\n            }\n            else {\n                opt.default = defaults[key];\n            }\n        }\n        else if (opt === null) {\n            props[key] = { default: defaults[key] };\n        }\n        else {\n            warn$2(`props default key \"${key}\" has no corresponding declaration.`);\n        }\n    }\n    return props;\n}\n\nfunction initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    const options = vm.$options;\n    const parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree\n    const renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = parentVnode\n        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)\n        : emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    // @ts-expect-error\n    vm._c = (a, b, c, d) => createElement$1(vm, a, b, c, d, false);\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    // @ts-expect-error\n    vm.$createElement = (a, b, c, d) => createElement$1(vm, a, b, c, d, true);\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    const parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n    {\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, () => {\n            !isUpdatingChildComponent && warn$2(`$attrs is readonly.`, vm);\n        }, true);\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {\n            !isUpdatingChildComponent && warn$2(`$listeners is readonly.`, vm);\n        }, true);\n    }\n}\nlet currentRenderingInstance = null;\nfunction renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n    Vue.prototype.$nextTick = function (fn) {\n        return nextTick(fn, this);\n    };\n    Vue.prototype._render = function () {\n        const vm = this;\n        const { render, _parentVnode } = vm.$options;\n        if (_parentVnode && vm._isMounted) {\n            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n            if (vm._slotsProxy) {\n                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\n            }\n        }\n        // set parent vnode. this allows render functions to have access\n        // to the data on the placeholder node.\n        vm.$vnode = _parentVnode;\n        // render self\n        let vnode;\n        try {\n            // There's no need to maintain a stack because all render fns are called\n            // separately from one another. Nested component's render fns are called\n            // when parent component is patched.\n            setCurrentInstance(vm);\n            currentRenderingInstance = vm;\n            vnode = render.call(vm._renderProxy, vm.$createElement);\n        }\n        catch (e) {\n            handleError(e, vm, `render`);\n            // return error render result,\n            // or previous vnode to prevent render error causing blank component\n            /* istanbul ignore else */\n            if (vm.$options.renderError) {\n                try {\n                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n                }\n                catch (e) {\n                    handleError(e, vm, `renderError`);\n                    vnode = vm._vnode;\n                }\n            }\n            else {\n                vnode = vm._vnode;\n            }\n        }\n        finally {\n            currentRenderingInstance = null;\n            setCurrentInstance();\n        }\n        // if the returned array contains only a single node, allow it\n        if (isArray(vnode) && vnode.length === 1) {\n            vnode = vnode[0];\n        }\n        // return empty vnode in case the render function errored out\n        if (!(vnode instanceof VNode)) {\n            if (isArray(vnode)) {\n                warn$2('Multiple root nodes returned from render function. Render function ' +\n                    'should return a single root node.', vm);\n            }\n            vnode = createEmptyVNode();\n        }\n        // set parent\n        vnode.parent = _parentVnode;\n        return vnode;\n    };\n}\n\nfunction ensureCtor(comp, base) {\n    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {\n        comp = comp.default;\n    }\n    return isObject(comp) ? base.extend(comp) : comp;\n}\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n    const node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data, context, children, tag };\n    return node;\n}\nfunction resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n        return factory.errorComp;\n    }\n    if (isDef(factory.resolved)) {\n        return factory.resolved;\n    }\n    const owner = currentRenderingInstance;\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n        // already pending\n        factory.owners.push(owner);\n    }\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n        return factory.loadingComp;\n    }\n    if (owner && !isDef(factory.owners)) {\n        const owners = (factory.owners = [owner]);\n        let sync = true;\n        let timerLoading = null;\n        let timerTimeout = null;\n        owner.$on('hook:destroyed', () => remove$2(owners, owner));\n        const forceRender = (renderCompleted) => {\n            for (let i = 0, l = owners.length; i < l; i++) {\n                owners[i].$forceUpdate();\n            }\n            if (renderCompleted) {\n                owners.length = 0;\n                if (timerLoading !== null) {\n                    clearTimeout(timerLoading);\n                    timerLoading = null;\n                }\n                if (timerTimeout !== null) {\n                    clearTimeout(timerTimeout);\n                    timerTimeout = null;\n                }\n            }\n        };\n        const resolve = once((res) => {\n            // cache resolved\n            factory.resolved = ensureCtor(res, baseCtor);\n            // invoke callbacks only if this is not a synchronous resolve\n            // (async resolves are shimmed as synchronous during SSR)\n            if (!sync) {\n                forceRender(true);\n            }\n            else {\n                owners.length = 0;\n            }\n        });\n        const reject = once(reason => {\n            warn$2(`Failed to resolve async component: ${String(factory)}` +\n                    (reason ? `\\nReason: ${reason}` : ''));\n            if (isDef(factory.errorComp)) {\n                factory.error = true;\n                forceRender(true);\n            }\n        });\n        const res = factory(resolve, reject);\n        if (isObject(res)) {\n            if (isPromise(res)) {\n                // () => Promise\n                if (isUndef(factory.resolved)) {\n                    res.then(resolve, reject);\n                }\n            }\n            else if (isPromise(res.component)) {\n                res.component.then(resolve, reject);\n                if (isDef(res.error)) {\n                    factory.errorComp = ensureCtor(res.error, baseCtor);\n                }\n                if (isDef(res.loading)) {\n                    factory.loadingComp = ensureCtor(res.loading, baseCtor);\n                    if (res.delay === 0) {\n                        factory.loading = true;\n                    }\n                    else {\n                        // @ts-expect-error NodeJS timeout type\n                        timerLoading = setTimeout(() => {\n                            timerLoading = null;\n                            if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                                factory.loading = true;\n                                forceRender(false);\n                            }\n                        }, res.delay || 200);\n                    }\n                }\n                if (isDef(res.timeout)) {\n                    // @ts-expect-error NodeJS timeout type\n                    timerTimeout = setTimeout(() => {\n                        timerTimeout = null;\n                        if (isUndef(factory.resolved)) {\n                            reject(`timeout (${res.timeout}ms)` );\n                        }\n                    }, res.timeout);\n                }\n            }\n        }\n        sync = false;\n        // return in case resolved synchronously\n        return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n}\n\nfunction getFirstComponentChild(children) {\n    if (isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n            const c = children[i];\n            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n                return c;\n            }\n        }\n    }\n}\n\nfunction initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    const listeners = vm.$options._parentListeners;\n    if (listeners) {\n        updateComponentListeners(vm, listeners);\n    }\n}\nlet target$1;\nfunction add$1(event, fn) {\n    target$1.$on(event, fn);\n}\nfunction remove$1(event, fn) {\n    target$1.$off(event, fn);\n}\nfunction createOnceHandler$1(event, fn) {\n    const _target = target$1;\n    return function onceHandler() {\n        const res = fn.apply(null, arguments);\n        if (res !== null) {\n            _target.$off(event, onceHandler);\n        }\n    };\n}\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n    target$1 = vm;\n    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\n    target$1 = undefined;\n}\nfunction eventsMixin(Vue) {\n    const hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n        const vm = this;\n        if (isArray(event)) {\n            for (let i = 0, l = event.length; i < l; i++) {\n                vm.$on(event[i], fn);\n            }\n        }\n        else {\n            (vm._events[event] || (vm._events[event] = [])).push(fn);\n            // optimize hook:event cost by using a boolean flag marked at registration\n            // instead of a hash lookup\n            if (hookRE.test(event)) {\n                vm._hasHookEvent = true;\n            }\n        }\n        return vm;\n    };\n    Vue.prototype.$once = function (event, fn) {\n        const vm = this;\n        function on() {\n            vm.$off(event, on);\n            fn.apply(vm, arguments);\n        }\n        on.fn = fn;\n        vm.$on(event, on);\n        return vm;\n    };\n    Vue.prototype.$off = function (event, fn) {\n        const vm = this;\n        // all\n        if (!arguments.length) {\n            vm._events = Object.create(null);\n            return vm;\n        }\n        // array of events\n        if (isArray(event)) {\n            for (let i = 0, l = event.length; i < l; i++) {\n                vm.$off(event[i], fn);\n            }\n            return vm;\n        }\n        // specific event\n        const cbs = vm._events[event];\n        if (!cbs) {\n            return vm;\n        }\n        if (!fn) {\n            vm._events[event] = null;\n            return vm;\n        }\n        // specific handler\n        let cb;\n        let i = cbs.length;\n        while (i--) {\n            cb = cbs[i];\n            if (cb === fn || cb.fn === fn) {\n                cbs.splice(i, 1);\n                break;\n            }\n        }\n        return vm;\n    };\n    Vue.prototype.$emit = function (event) {\n        const vm = this;\n        {\n            const lowerCaseEvent = event.toLowerCase();\n            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n                tip(`Event \"${lowerCaseEvent}\" is emitted in component ` +\n                    `${formatComponentName(vm)} but the handler is registered for \"${event}\". ` +\n                    `Note that HTML attributes are case-insensitive and you cannot use ` +\n                    `v-on to listen to camelCase events when using in-DOM templates. ` +\n                    `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`);\n            }\n        }\n        let cbs = vm._events[event];\n        if (cbs) {\n            cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n            const args = toArray(arguments, 1);\n            const info = `event handler for \"${event}\"`;\n            for (let i = 0, l = cbs.length; i < l; i++) {\n                invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n            }\n        }\n        return vm;\n    };\n}\n\nlet activeInstance = null;\nlet isUpdatingChildComponent = false;\nfunction setActiveInstance(vm) {\n    const prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return () => {\n        activeInstance = prevActiveInstance;\n    };\n}\nfunction initLifecycle(vm) {\n    const options = vm.$options;\n    // locate first non-abstract parent\n    let parent = options.parent;\n    if (parent && !options.abstract) {\n        while (parent.$options.abstract && parent.$parent) {\n            parent = parent.$parent;\n        }\n        parent.$children.push(vm);\n    }\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._provided = parent ? parent._provided : Object.create(null);\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n}\nfunction lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n        const vm = this;\n        const prevEl = vm.$el;\n        const prevVnode = vm._vnode;\n        const restoreActiveInstance = setActiveInstance(vm);\n        vm._vnode = vnode;\n        // Vue.prototype.__patch__ is injected in entry points\n        // based on the rendering backend used.\n        if (!prevVnode) {\n            // initial render\n            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n        }\n        else {\n            // updates\n            vm.$el = vm.__patch__(prevVnode, vnode);\n        }\n        restoreActiveInstance();\n        // update __vue__ reference\n        if (prevEl) {\n            prevEl.__vue__ = null;\n        }\n        if (vm.$el) {\n            vm.$el.__vue__ = vm;\n        }\n        // if parent is an HOC, update its $el as well\n        let wrapper = vm;\n        while (wrapper &&\n            wrapper.$vnode &&\n            wrapper.$parent &&\n            wrapper.$vnode === wrapper.$parent._vnode) {\n            wrapper.$parent.$el = wrapper.$el;\n            wrapper = wrapper.$parent;\n        }\n        // updated hook is called by the scheduler to ensure that children are\n        // updated in a parent's updated hook.\n    };\n    Vue.prototype.$forceUpdate = function () {\n        const vm = this;\n        if (vm._watcher) {\n            vm._watcher.update();\n        }\n    };\n    Vue.prototype.$destroy = function () {\n        const vm = this;\n        if (vm._isBeingDestroyed) {\n            return;\n        }\n        callHook$1(vm, 'beforeDestroy');\n        vm._isBeingDestroyed = true;\n        // remove self from parent\n        const parent = vm.$parent;\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n            remove$2(parent.$children, vm);\n        }\n        // teardown scope. this includes both the render watcher and other\n        // watchers created\n        vm._scope.stop();\n        // remove reference from data ob\n        // frozen object may not have observer.\n        if (vm._data.__ob__) {\n            vm._data.__ob__.vmCount--;\n        }\n        // call the last hook...\n        vm._isDestroyed = true;\n        // invoke destroy hooks on current rendered tree\n        vm.__patch__(vm._vnode, null);\n        // fire destroyed hook\n        callHook$1(vm, 'destroyed');\n        // turn off all instance listeners.\n        vm.$off();\n        // remove __vue__ reference\n        if (vm.$el) {\n            vm.$el.__vue__ = null;\n        }\n        // release circular reference (#6759)\n        if (vm.$vnode) {\n            vm.$vnode.parent = null;\n        }\n    };\n}\nfunction mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n        // @ts-expect-error invalid type\n        vm.$options.render = createEmptyVNode;\n        {\n            /* istanbul ignore if */\n            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n                vm.$options.el ||\n                el) {\n                warn$2('You are using the runtime-only build of Vue where the template ' +\n                    'compiler is not available. Either pre-compile the templates into ' +\n                    'render functions, or use the compiler-included build.', vm);\n            }\n            else {\n                warn$2('Failed to mount component: template or render function not defined.', vm);\n            }\n        }\n    }\n    callHook$1(vm, 'beforeMount');\n    let updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n        updateComponent = () => {\n            const name = vm._name;\n            const id = vm._uid;\n            const startTag = `vue-perf-start:${id}`;\n            const endTag = `vue-perf-end:${id}`;\n            mark(startTag);\n            const vnode = vm._render();\n            mark(endTag);\n            measure(`vue ${name} render`, startTag, endTag);\n            mark(startTag);\n            vm._update(vnode, hydrating);\n            mark(endTag);\n            measure(`vue ${name} patch`, startTag, endTag);\n        };\n    }\n    else {\n        updateComponent = () => {\n            vm._update(vm._render(), hydrating);\n        };\n    }\n    const watcherOptions = {\n        before() {\n            if (vm._isMounted && !vm._isDestroyed) {\n                callHook$1(vm, 'beforeUpdate');\n            }\n        }\n    };\n    {\n        watcherOptions.onTrack = e => callHook$1(vm, 'renderTracked', [e]);\n        watcherOptions.onTrigger = e => callHook$1(vm, 'renderTriggered', [e]);\n    }\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);\n    hydrating = false;\n    // flush buffer for flush: \"pre\" watchers queued in setup()\n    const preWatchers = vm._preWatchers;\n    if (preWatchers) {\n        for (let i = 0; i < preWatchers.length; i++) {\n            preWatchers[i].run();\n        }\n    }\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n        vm._isMounted = true;\n        callHook$1(vm, 'mounted');\n    }\n    return vm;\n}\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n        isUpdatingChildComponent = true;\n    }\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    const newScopedSlots = parentVnode.data.scopedSlots;\n    const oldScopedSlots = vm.$scopedSlots;\n    const hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\n        (!newScopedSlots && vm.$scopedSlots.$key));\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    let needsForceUpdate = !!(renderChildren || // has new static slots\n        vm.$options._renderChildren || // has old static slots\n        hasDynamicScopedSlot);\n    const prevVNode = vm.$vnode;\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) {\n        // update child tree's parent\n        vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    const attrs = parentVnode.data.attrs || emptyObject;\n    if (vm._attrsProxy) {\n        // force update if attrs are accessed and has changed since it may be\n        // passed to a child component.\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\n            needsForceUpdate = true;\n        }\n    }\n    vm.$attrs = attrs;\n    // update listeners\n    listeners = listeners || emptyObject;\n    const prevListeners = vm.$options._parentListeners;\n    if (vm._listenersProxy) {\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\n    }\n    vm.$listeners = vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, prevListeners);\n    // update props\n    if (propsData && vm.$options.props) {\n        toggleObserving(false);\n        const props = vm._props;\n        const propKeys = vm.$options._propKeys || [];\n        for (let i = 0; i < propKeys.length; i++) {\n            const key = propKeys[i];\n            const propOptions = vm.$options.props; // wtf flow?\n            props[key] = validateProp(key, propOptions, propsData, vm);\n        }\n        toggleObserving(true);\n        // keep a copy of raw propsData\n        vm.$options.propsData = propsData;\n    }\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n        vm.$forceUpdate();\n    }\n    {\n        isUpdatingChildComponent = false;\n    }\n}\nfunction isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n        if (vm._inactive)\n            return true;\n    }\n    return false;\n}\nfunction activateChildComponent(vm, direct) {\n    if (direct) {\n        vm._directInactive = false;\n        if (isInInactiveTree(vm)) {\n            return;\n        }\n    }\n    else if (vm._directInactive) {\n        return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n        vm._inactive = false;\n        for (let i = 0; i < vm.$children.length; i++) {\n            activateChildComponent(vm.$children[i]);\n        }\n        callHook$1(vm, 'activated');\n    }\n}\nfunction deactivateChildComponent(vm, direct) {\n    if (direct) {\n        vm._directInactive = true;\n        if (isInInactiveTree(vm)) {\n            return;\n        }\n    }\n    if (!vm._inactive) {\n        vm._inactive = true;\n        for (let i = 0; i < vm.$children.length; i++) {\n            deactivateChildComponent(vm.$children[i]);\n        }\n        callHook$1(vm, 'deactivated');\n    }\n}\nfunction callHook$1(vm, hook, args, setContext = true) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    const prev = currentInstance;\n    setContext && setCurrentInstance(vm);\n    const handlers = vm.$options[hook];\n    const info = `${hook} hook`;\n    if (handlers) {\n        for (let i = 0, j = handlers.length; i < j; i++) {\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\n        }\n    }\n    if (vm._hasHookEvent) {\n        vm.$emit('hook:' + hook);\n    }\n    setContext && setCurrentInstance(prev);\n    popTarget();\n}\n\nconst MAX_UPDATE_COUNT = 100;\nconst queue = [];\nconst activatedChildren = [];\nlet has = {};\nlet circular = {};\nlet waiting = false;\nlet flushing = false;\nlet index$1 = 0;\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n    index$1 = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n        circular = {};\n    }\n    waiting = flushing = false;\n}\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nlet currentFlushTimestamp = 0;\n// Async edge case fix requires storing an event listener's attach timestamp.\nlet getNow = Date.now;\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n    const performance = window.performance;\n    if (performance &&\n        typeof performance.now === 'function' &&\n        getNow() > document.createEvent('Event').timeStamp) {\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\n        // smaller than it, it means the event is using a hi-res timestamp,\n        // and we need to use the hi-res version for event listener timestamps as\n        // well.\n        getNow = () => performance.now();\n    }\n}\nconst sortCompareFn = (a, b) => {\n    if (a.post) {\n        if (!b.post)\n            return 1;\n    }\n    else if (b.post) {\n        return -1;\n    }\n    return a.id - b.id;\n};\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    let watcher, id;\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(sortCompareFn);\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index$1 = 0; index$1 < queue.length; index$1++) {\n        watcher = queue[index$1];\n        if (watcher.before) {\n            watcher.before();\n        }\n        id = watcher.id;\n        has[id] = null;\n        watcher.run();\n        // in dev build, check and stop circular updates.\n        if (has[id] != null) {\n            circular[id] = (circular[id] || 0) + 1;\n            if (circular[id] > MAX_UPDATE_COUNT) {\n                warn$2('You may have an infinite update loop ' +\n                    (watcher.user\n                        ? `in watcher with expression \"${watcher.expression}\"`\n                        : `in a component render function.`), watcher.vm);\n                break;\n            }\n        }\n    }\n    // keep copies of post queues before resetting state\n    const activatedQueue = activatedChildren.slice();\n    const updatedQueue = queue.slice();\n    resetSchedulerState();\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n    cleanupDeps();\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n        devtools.emit('flush');\n    }\n}\nfunction callUpdatedHooks(queue) {\n    let i = queue.length;\n    while (i--) {\n        const watcher = queue[i];\n        const vm = watcher.vm;\n        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n            callHook$1(vm, 'updated');\n        }\n    }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n}\nfunction callActivatedHooks(queue) {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]._inactive = true;\n        activateChildComponent(queue[i], true /* true */);\n    }\n}\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n    const id = watcher.id;\n    if (has[id] != null) {\n        return;\n    }\n    if (watcher === Dep.target && watcher.noRecurse) {\n        return;\n    }\n    has[id] = true;\n    if (!flushing) {\n        queue.push(watcher);\n    }\n    else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        let i = queue.length - 1;\n        while (i > index$1 && queue[i].id > watcher.id) {\n            i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n        waiting = true;\n        if (!config.async) {\n            flushSchedulerQueue();\n            return;\n        }\n        nextTick(flushSchedulerQueue);\n    }\n}\n\nconst WATCHER = `watcher`;\nconst WATCHER_CB = `${WATCHER} callback`;\nconst WATCHER_GETTER = `${WATCHER} getter`;\nconst WATCHER_CLEANUP = `${WATCHER} cleanup`;\n// Simple effect.\nfunction watchEffect(effect, options) {\n    return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'post' }) ));\n}\nfunction watchSyncEffect(effect, options) {\n    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'sync' }) ));\n}\n// initial value for watchers to trigger on undefined initial values\nconst INITIAL_WATCHER_VALUE = {};\n// implementation\nfunction watch(source, cb, options) {\n    if (typeof cb !== 'function') {\n        warn$2(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n            `supports \\`watch(source, cb, options?) signature.`);\n    }\n    return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, { immediate, deep, flush = 'pre', onTrack, onTrigger } = emptyObject) {\n    if (!cb) {\n        if (immediate !== undefined) {\n            warn$2(`watch() \"immediate\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n        if (deep !== undefined) {\n            warn$2(`watch() \"deep\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n    }\n    const warnInvalidSource = (s) => {\n        warn$2(`Invalid watch source: ${s}. A watch source can only be a getter/effect ` +\n            `function, a ref, a reactive object, or an array of these types.`);\n    };\n    const instance = currentInstance;\n    const call = (fn, type, args = null) => invokeWithErrorHandling(fn, null, args, instance, type);\n    let getter;\n    let forceTrigger = false;\n    let isMultiSource = false;\n    if (isRef(source)) {\n        getter = () => source.value;\n        forceTrigger = isShallow(source);\n    }\n    else if (isReactive(source)) {\n        getter = () => {\n            source.__ob__.dep.depend();\n            return source;\n        };\n        deep = true;\n    }\n    else if (isArray(source)) {\n        isMultiSource = true;\n        forceTrigger = source.some(s => isReactive(s) || isShallow(s));\n        getter = () => source.map(s => {\n            if (isRef(s)) {\n                return s.value;\n            }\n            else if (isReactive(s)) {\n                return traverse(s);\n            }\n            else if (isFunction(s)) {\n                return call(s, WATCHER_GETTER);\n            }\n            else {\n                warnInvalidSource(s);\n            }\n        });\n    }\n    else if (isFunction(source)) {\n        if (cb) {\n            // getter with cb\n            getter = () => call(source, WATCHER_GETTER);\n        }\n        else {\n            // no cb -> simple effect\n            getter = () => {\n                if (instance && instance._isDestroyed) {\n                    return;\n                }\n                if (cleanup) {\n                    cleanup();\n                }\n                return call(source, WATCHER, [onCleanup]);\n            };\n        }\n    }\n    else {\n        getter = noop;\n        warnInvalidSource(source);\n    }\n    if (cb && deep) {\n        const baseGetter = getter;\n        getter = () => traverse(baseGetter());\n    }\n    let cleanup;\n    let onCleanup = (fn) => {\n        cleanup = watcher.onStop = () => {\n            call(fn, WATCHER_CLEANUP);\n        };\n    };\n    // in SSR there is no need to setup an actual effect, and it should be noop\n    // unless it's eager\n    if (isServerRendering()) {\n        // we will also not call the invalidate callback (+ runner is not set up)\n        onCleanup = noop;\n        if (!cb) {\n            getter();\n        }\n        else if (immediate) {\n            call(cb, WATCHER_CB, [\n                getter(),\n                isMultiSource ? [] : undefined,\n                onCleanup\n            ]);\n        }\n        return noop;\n    }\n    const watcher = new Watcher(currentInstance, getter, noop, {\n        lazy: true\n    });\n    watcher.noRecurse = !cb;\n    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\n    // overwrite default run\n    watcher.run = () => {\n        if (!watcher.active) {\n            return;\n        }\n        if (cb) {\n            // watch(source, cb)\n            const newValue = watcher.get();\n            if (deep ||\n                forceTrigger ||\n                (isMultiSource\n                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))\n                    : hasChanged(newValue, oldValue))) {\n                // cleanup before running cb again\n                if (cleanup) {\n                    cleanup();\n                }\n                call(cb, WATCHER_CB, [\n                    newValue,\n                    // pass undefined as the old value when it's changed for the first time\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\n                    onCleanup\n                ]);\n                oldValue = newValue;\n            }\n        }\n        else {\n            // watchEffect\n            watcher.get();\n        }\n    };\n    if (flush === 'sync') {\n        watcher.update = watcher.run;\n    }\n    else if (flush === 'post') {\n        watcher.post = true;\n        watcher.update = () => queueWatcher(watcher);\n    }\n    else {\n        // pre\n        watcher.update = () => {\n            if (instance && instance === currentInstance && !instance._isMounted) {\n                // pre-watcher triggered before\n                const buffer = instance._preWatchers || (instance._preWatchers = []);\n                if (buffer.indexOf(watcher) < 0)\n                    buffer.push(watcher);\n            }\n            else {\n                queueWatcher(watcher);\n            }\n        };\n    }\n    {\n        watcher.onTrack = onTrack;\n        watcher.onTrigger = onTrigger;\n    }\n    // initial run\n    if (cb) {\n        if (immediate) {\n            watcher.run();\n        }\n        else {\n            oldValue = watcher.get();\n        }\n    }\n    else if (flush === 'post' && instance) {\n        instance.$once('hook:mounted', () => watcher.get());\n    }\n    else {\n        watcher.get();\n    }\n    return () => {\n        watcher.teardown();\n    };\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this.active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    run(fn) {\n        if (this.active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else {\n            warn$2(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this.active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].teardown();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this.active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\n/**\n * @internal\n */\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else {\n        warn$2(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nfunction provide(key, value) {\n    if (!currentInstance) {\n        {\n            warn$2(`provide() can only be used inside setup().`);\n        }\n    }\n    else {\n        // TS doesn't allow symbol as index type\n        resolveProvided(currentInstance)[key] = value;\n    }\n}\nfunction resolveProvided(vm) {\n    // by default an instance inherits its parent's provides object\n    // but when it needs to provide values of its own, it creates its\n    // own provides object using parent provides object as prototype.\n    // this way in `inject` we can simply look up injections from direct\n    // parent and let the prototype chain do the work.\n    const existing = vm._provided;\n    const parentProvides = vm.$parent && vm.$parent._provided;\n    if (parentProvides === existing) {\n        return (vm._provided = Object.create(parentProvides));\n    }\n    else {\n        return existing;\n    }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n    // fallback to `currentRenderingInstance` so that this can be called in\n    // a functional component\n    const instance = currentInstance;\n    if (instance) {\n        // #2400\n        // to support `app.use` plugins,\n        // fallback to appContext's `provides` if the instance is at root\n        const provides = instance.$parent && instance.$parent._provided;\n        if (provides && key in provides) {\n            // TS doesn't allow symbol as index type\n            return provides[key];\n        }\n        else if (arguments.length > 1) {\n            return treatDefaultAsFactory && isFunction(defaultValue)\n                ? defaultValue.call(instance)\n                : defaultValue;\n        }\n        else {\n            warn$2(`injection \"${String(key)}\" not found.`);\n        }\n    }\n    else {\n        warn$2(`inject() can only be used inside setup() or functional components.`);\n    }\n}\n\n/**\n * @internal this function needs manual public type declaration because it relies\n * on previously manually authored types from Vue 2\n */\nfunction h(type, props, children) {\n    if (!currentInstance) {\n        warn$2(`globally imported h() can only be invoked when there is an active ` +\n                `component instance, e.g. synchronously in a component's render or setup function.`);\n    }\n    return createElement$1(currentInstance, type, props, children, 2, true);\n}\n\nfunction handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n        if (vm) {\n            let cur = vm;\n            while ((cur = cur.$parent)) {\n                const hooks = cur.$options.errorCaptured;\n                if (hooks) {\n                    for (let i = 0; i < hooks.length; i++) {\n                        try {\n                            const capture = hooks[i].call(cur, err, vm, info) === false;\n                            if (capture)\n                                return;\n                        }\n                        catch (e) {\n                            globalHandleError(e, cur, 'errorCaptured hook');\n                        }\n                    }\n                }\n            }\n        }\n        globalHandleError(err, vm, info);\n    }\n    finally {\n        popTarget();\n    }\n}\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n    let res;\n    try {\n        res = args ? handler.apply(context, args) : handler.call(context);\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\n            res.catch(e => handleError(e, vm, info + ` (Promise/async)`));\n            res._handled = true;\n        }\n    }\n    catch (e) {\n        handleError(e, vm, info);\n    }\n    return res;\n}\nfunction globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n        try {\n            return config.errorHandler.call(null, err, vm, info);\n        }\n        catch (e) {\n            // if the user intentionally throws the original error in the handler,\n            // do not log it twice\n            if (e !== err) {\n                logError(e, null, 'config.errorHandler');\n            }\n        }\n    }\n    logError(err, vm, info);\n}\nfunction logError(err, vm, info) {\n    {\n        warn$2(`Error in ${info}: \"${err.toString()}\"`, vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n        console.error(err);\n    }\n    else {\n        throw err;\n    }\n}\n\n/* globals MutationObserver */\nlet isUsingMicroTask = false;\nconst callbacks = [];\nlet pending = false;\nfunction flushCallbacks() {\n    pending = false;\n    const copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (let i = 0; i < copies.length; i++) {\n        copies[i]();\n    }\n}\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nlet timerFunc;\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n    const p = Promise.resolve();\n    timerFunc = () => {\n        p.then(flushCallbacks);\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\n        // it can get stuck in a weird state where callbacks are pushed into the\n        // microtask queue but the queue isn't being flushed, until the browser\n        // needs to do some other work, e.g. handle a timer. Therefore we can\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\n        if (isIOS)\n            setTimeout(noop);\n    };\n    isUsingMicroTask = true;\n}\nelse if (!isIE &&\n    typeof MutationObserver !== 'undefined' &&\n    (isNative(MutationObserver) ||\n        // PhantomJS and iOS 7.x\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    let counter = 1;\n    const observer = new MutationObserver(flushCallbacks);\n    const textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n        characterData: true\n    });\n    timerFunc = () => {\n        counter = (counter + 1) % 2;\n        textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n}\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Technically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = () => {\n        setImmediate(flushCallbacks);\n    };\n}\nelse {\n    // Fallback to setTimeout.\n    timerFunc = () => {\n        setTimeout(flushCallbacks, 0);\n    };\n}\n/**\n * @internal\n */\nfunction nextTick(cb, ctx) {\n    let _resolve;\n    callbacks.push(() => {\n        if (cb) {\n            try {\n                cb.call(ctx);\n            }\n            catch (e) {\n                handleError(e, ctx, 'nextTick');\n            }\n        }\n        else if (_resolve) {\n            _resolve(ctx);\n        }\n    });\n    if (!pending) {\n        pending = true;\n        timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n        return new Promise(resolve => {\n            _resolve = resolve;\n        });\n    }\n}\n\nfunction useCssModule(name = '$style') {\n    /* istanbul ignore else */\n    {\n        if (!currentInstance) {\n            warn$2(`useCssModule must be called inside setup()`);\n            return emptyObject;\n        }\n        const mod = currentInstance[name];\n        if (!mod) {\n            warn$2(`Current instance does not have CSS module named \"${name}\".`);\n            return emptyObject;\n        }\n        return mod;\n    }\n}\n\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nfunction useCssVars(getter) {\n    if (!inBrowser && !false)\n        return;\n    const instance = currentInstance;\n    if (!instance) {\n        warn$2(`useCssVars is called without current active component instance.`);\n        return;\n    }\n    watchPostEffect(() => {\n        const el = instance.$el;\n        const vars = getter(instance, instance._setupProxy);\n        if (el && el.nodeType === 1) {\n            const style = el.style;\n            for (const key in vars) {\n                style.setProperty(`--${key}`, vars[key]);\n            }\n        }\n    });\n}\n\n/**\n * v3-compatible async component API.\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\n * because it relies on existing manual types\n */\nfunction defineAsyncComponent(source) {\n    if (isFunction(source)) {\n        source = { loader: source };\n    }\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\n    suspensible = false, // in Vue 3 default is true\n    onError: userOnError } = source;\n    if (suspensible) {\n        warn$2(`The suspensiblbe option for async components is not supported in Vue2. It is ignored.`);\n    }\n    let pendingRequest = null;\n    let retries = 0;\n    const retry = () => {\n        retries++;\n        pendingRequest = null;\n        return load();\n    };\n    const load = () => {\n        let thisRequest;\n        return (pendingRequest ||\n            (thisRequest = pendingRequest =\n                loader()\n                    .catch(err => {\n                    err = err instanceof Error ? err : new Error(String(err));\n                    if (userOnError) {\n                        return new Promise((resolve, reject) => {\n                            const userRetry = () => resolve(retry());\n                            const userFail = () => reject(err);\n                            userOnError(err, userRetry, userFail, retries + 1);\n                        });\n                    }\n                    else {\n                        throw err;\n                    }\n                })\n                    .then((comp) => {\n                    if (thisRequest !== pendingRequest && pendingRequest) {\n                        return pendingRequest;\n                    }\n                    if (!comp) {\n                        warn$2(`Async component loader resolved to undefined. ` +\n                            `If you are using retry(), make sure to return its return value.`);\n                    }\n                    // interop module default\n                    if (comp &&\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n                        comp = comp.default;\n                    }\n                    if (comp && !isObject(comp) && !isFunction(comp)) {\n                        throw new Error(`Invalid async component load result: ${comp}`);\n                    }\n                    return comp;\n                })));\n    };\n    return () => {\n        const component = load();\n        return {\n            component,\n            delay,\n            timeout,\n            error: errorComponent,\n            loading: loadingComponent\n        };\n    };\n}\n\nfunction createLifeCycle(hookName) {\n    return (fn, target = currentInstance) => {\n        if (!target) {\n            warn$2(`${formatName(hookName)} is called when there is no active component instance to be ` +\n                    `associated with. ` +\n                    `Lifecycle injection APIs can only be used during execution of setup().`);\n            return;\n        }\n        return injectHook(target, hookName, fn);\n    };\n}\nfunction formatName(name) {\n    if (name === 'beforeDestroy') {\n        name = 'beforeUnmount';\n    }\n    else if (name === 'destroyed') {\n        name = 'unmounted';\n    }\n    return `on${name[0].toUpperCase() + name.slice(1)}`;\n}\nfunction injectHook(instance, hookName, fn) {\n    const options = instance.$options;\n    options[hookName] = mergeLifecycleHook(options[hookName], fn);\n}\nconst onBeforeMount = createLifeCycle('beforeMount');\nconst onMounted = createLifeCycle('mounted');\nconst onBeforeUpdate = createLifeCycle('beforeUpdate');\nconst onUpdated = createLifeCycle('updated');\nconst onBeforeUnmount = createLifeCycle('beforeDestroy');\nconst onUnmounted = createLifeCycle('destroyed');\nconst onActivated = createLifeCycle('activated');\nconst onDeactivated = createLifeCycle('deactivated');\nconst onServerPrefetch = createLifeCycle('serverPrefetch');\nconst onRenderTracked = createLifeCycle('renderTracked');\nconst onRenderTriggered = createLifeCycle('renderTriggered');\nconst injectErrorCapturedHook = createLifeCycle('errorCaptured');\nfunction onErrorCaptured(hook, target = currentInstance) {\n    injectErrorCapturedHook(hook, target);\n}\n\n/**\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\n */\nconst version = '2.7.14';\n/**\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\n */\nfunction defineComponent(options) {\n    return options;\n}\n\nvar vca = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  version: version,\n  defineComponent: defineComponent,\n  ref: ref$1,\n  shallowRef: shallowRef,\n  isRef: isRef,\n  toRef: toRef,\n  toRefs: toRefs,\n  unref: unref,\n  proxyRefs: proxyRefs,\n  customRef: customRef,\n  triggerRef: triggerRef,\n  reactive: reactive,\n  isReactive: isReactive,\n  isReadonly: isReadonly,\n  isShallow: isShallow,\n  isProxy: isProxy,\n  shallowReactive: shallowReactive,\n  markRaw: markRaw,\n  toRaw: toRaw,\n  readonly: readonly,\n  shallowReadonly: shallowReadonly,\n  computed: computed,\n  watch: watch,\n  watchEffect: watchEffect,\n  watchPostEffect: watchPostEffect,\n  watchSyncEffect: watchSyncEffect,\n  EffectScope: EffectScope,\n  effectScope: effectScope,\n  onScopeDispose: onScopeDispose,\n  getCurrentScope: getCurrentScope,\n  provide: provide,\n  inject: inject,\n  h: h,\n  getCurrentInstance: getCurrentInstance,\n  useSlots: useSlots,\n  useAttrs: useAttrs,\n  useListeners: useListeners,\n  mergeDefaults: mergeDefaults,\n  nextTick: nextTick,\n  set: set,\n  del: del,\n  useCssModule: useCssModule,\n  useCssVars: useCssVars,\n  defineAsyncComponent: defineAsyncComponent,\n  onBeforeMount: onBeforeMount,\n  onMounted: onMounted,\n  onBeforeUpdate: onBeforeUpdate,\n  onUpdated: onUpdated,\n  onBeforeUnmount: onBeforeUnmount,\n  onUnmounted: onUnmounted,\n  onActivated: onActivated,\n  onDeactivated: onDeactivated,\n  onServerPrefetch: onServerPrefetch,\n  onRenderTracked: onRenderTracked,\n  onRenderTriggered: onRenderTriggered,\n  onErrorCaptured: onErrorCaptured\n});\n\nconst seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse(val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n    return val;\n}\nfunction _traverse(val, seen) {\n    let i, keys;\n    const isA = isArray(val);\n    if ((!isA && !isObject(val)) ||\n        val.__v_skip /* ReactiveFlags.SKIP */ ||\n        Object.isFrozen(val) ||\n        val instanceof VNode) {\n        return;\n    }\n    if (val.__ob__) {\n        const depId = val.__ob__.dep.id;\n        if (seen.has(depId)) {\n            return;\n        }\n        seen.add(depId);\n    }\n    if (isA) {\n        i = val.length;\n        while (i--)\n            _traverse(val[i], seen);\n    }\n    else if (isRef(val)) {\n        _traverse(val.value, seen);\n    }\n    else {\n        keys = Object.keys(val);\n        i = keys.length;\n        while (i--)\n            _traverse(val[keys[i]], seen);\n    }\n}\n\nlet uid$1 = 0;\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n * @internal\n */\nclass Watcher {\n    constructor(vm, expOrFn, cb, options, isRenderWatcher) {\n        recordEffectScope(this, \n        // if the active effect scope is manually created (not a component scope),\n        // prioritize it\n        activeEffectScope && !activeEffectScope._vm\n            ? activeEffectScope\n            : vm\n                ? vm._scope\n                : undefined);\n        if ((this.vm = vm) && isRenderWatcher) {\n            vm._watcher = this;\n        }\n        // options\n        if (options) {\n            this.deep = !!options.deep;\n            this.user = !!options.user;\n            this.lazy = !!options.lazy;\n            this.sync = !!options.sync;\n            this.before = options.before;\n            {\n                this.onTrack = options.onTrack;\n                this.onTrigger = options.onTrigger;\n            }\n        }\n        else {\n            this.deep = this.user = this.lazy = this.sync = false;\n        }\n        this.cb = cb;\n        this.id = ++uid$1; // uid for batching\n        this.active = true;\n        this.post = false;\n        this.dirty = this.lazy; // for lazy watchers\n        this.deps = [];\n        this.newDeps = [];\n        this.depIds = new _Set();\n        this.newDepIds = new _Set();\n        this.expression = expOrFn.toString() ;\n        // parse expression for getter\n        if (isFunction(expOrFn)) {\n            this.getter = expOrFn;\n        }\n        else {\n            this.getter = parsePath(expOrFn);\n            if (!this.getter) {\n                this.getter = noop;\n                warn$2(`Failed watching path: \"${expOrFn}\" ` +\n                        'Watcher only accepts simple dot-delimited paths. ' +\n                        'For full control, use a function instead.', vm);\n            }\n        }\n        this.value = this.lazy ? undefined : this.get();\n    }\n    /**\n     * Evaluate the getter, and re-collect dependencies.\n     */\n    get() {\n        pushTarget(this);\n        let value;\n        const vm = this.vm;\n        try {\n            value = this.getter.call(vm, vm);\n        }\n        catch (e) {\n            if (this.user) {\n                handleError(e, vm, `getter for watcher \"${this.expression}\"`);\n            }\n            else {\n                throw e;\n            }\n        }\n        finally {\n            // \"touch\" every property so they are all tracked as\n            // dependencies for deep watching\n            if (this.deep) {\n                traverse(value);\n            }\n            popTarget();\n            this.cleanupDeps();\n        }\n        return value;\n    }\n    /**\n     * Add a dependency to this directive.\n     */\n    addDep(dep) {\n        const id = dep.id;\n        if (!this.newDepIds.has(id)) {\n            this.newDepIds.add(id);\n            this.newDeps.push(dep);\n            if (!this.depIds.has(id)) {\n                dep.addSub(this);\n            }\n        }\n    }\n    /**\n     * Clean up for dependency collection.\n     */\n    cleanupDeps() {\n        let i = this.deps.length;\n        while (i--) {\n            const dep = this.deps[i];\n            if (!this.newDepIds.has(dep.id)) {\n                dep.removeSub(this);\n            }\n        }\n        let tmp = this.depIds;\n        this.depIds = this.newDepIds;\n        this.newDepIds = tmp;\n        this.newDepIds.clear();\n        tmp = this.deps;\n        this.deps = this.newDeps;\n        this.newDeps = tmp;\n        this.newDeps.length = 0;\n    }\n    /**\n     * Subscriber interface.\n     * Will be called when a dependency changes.\n     */\n    update() {\n        /* istanbul ignore else */\n        if (this.lazy) {\n            this.dirty = true;\n        }\n        else if (this.sync) {\n            this.run();\n        }\n        else {\n            queueWatcher(this);\n        }\n    }\n    /**\n     * Scheduler job interface.\n     * Will be called by the scheduler.\n     */\n    run() {\n        if (this.active) {\n            const value = this.get();\n            if (value !== this.value ||\n                // Deep watchers and watchers on Object/Arrays should fire even\n                // when the value is the same, because the value may\n                // have mutated.\n                isObject(value) ||\n                this.deep) {\n                // set new value\n                const oldValue = this.value;\n                this.value = value;\n                if (this.user) {\n                    const info = `callback for watcher \"${this.expression}\"`;\n                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n                }\n                else {\n                    this.cb.call(this.vm, value, oldValue);\n                }\n            }\n        }\n    }\n    /**\n     * Evaluate the value of the watcher.\n     * This only gets called for lazy watchers.\n     */\n    evaluate() {\n        this.value = this.get();\n        this.dirty = false;\n    }\n    /**\n     * Depend on all deps collected by this watcher.\n     */\n    depend() {\n        let i = this.deps.length;\n        while (i--) {\n            this.deps[i].depend();\n        }\n    }\n    /**\n     * Remove self from all dependencies' subscriber list.\n     */\n    teardown() {\n        if (this.vm && !this.vm._isBeingDestroyed) {\n            remove$2(this.vm._scope.effects, this);\n        }\n        if (this.active) {\n            let i = this.deps.length;\n            while (i--) {\n                this.deps[i].removeSub(this);\n            }\n            this.active = false;\n            if (this.onStop) {\n                this.onStop();\n            }\n        }\n    }\n}\n\nconst sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n};\nfunction proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n        return this[sourceKey][key];\n    };\n    sharedPropertyDefinition.set = function proxySetter(val) {\n        this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n}\nfunction initState(vm) {\n    const opts = vm.$options;\n    if (opts.props)\n        initProps$1(vm, opts.props);\n    // Composition API\n    initSetup(vm);\n    if (opts.methods)\n        initMethods(vm, opts.methods);\n    if (opts.data) {\n        initData(vm);\n    }\n    else {\n        const ob = observe((vm._data = {}));\n        ob && ob.vmCount++;\n    }\n    if (opts.computed)\n        initComputed$1(vm, opts.computed);\n    if (opts.watch && opts.watch !== nativeWatch) {\n        initWatch(vm, opts.watch);\n    }\n}\nfunction initProps$1(vm, propsOptions) {\n    const propsData = vm.$options.propsData || {};\n    const props = (vm._props = shallowReactive({}));\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    const keys = (vm.$options._propKeys = []);\n    const isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n        toggleObserving(false);\n    }\n    for (const key in propsOptions) {\n        keys.push(key);\n        const value = validateProp(key, propsOptions, propsData, vm);\n        /* istanbul ignore else */\n        {\n            const hyphenatedKey = hyphenate(key);\n            if (isReservedAttribute(hyphenatedKey) ||\n                config.isReservedAttr(hyphenatedKey)) {\n                warn$2(`\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`, vm);\n            }\n            defineReactive(props, key, value, () => {\n                if (!isRoot && !isUpdatingChildComponent) {\n                    warn$2(`Avoid mutating a prop directly since the value will be ` +\n                        `overwritten whenever the parent component re-renders. ` +\n                        `Instead, use a data or computed property based on the prop's ` +\n                        `value. Prop being mutated: \"${key}\"`, vm);\n                }\n            });\n        }\n        // static props are already proxied on the component's prototype\n        // during Vue.extend(). We only need to proxy props defined at\n        // instantiation here.\n        if (!(key in vm)) {\n            proxy(vm, `_props`, key);\n        }\n    }\n    toggleObserving(true);\n}\nfunction initData(vm) {\n    let data = vm.$options.data;\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\n    if (!isPlainObject(data)) {\n        data = {};\n        warn$2('data functions should return an object:\\n' +\n                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    }\n    // proxy data on instance\n    const keys = Object.keys(data);\n    const props = vm.$options.props;\n    const methods = vm.$options.methods;\n    let i = keys.length;\n    while (i--) {\n        const key = keys[i];\n        {\n            if (methods && hasOwn(methods, key)) {\n                warn$2(`Method \"${key}\" has already been defined as a data property.`, vm);\n            }\n        }\n        if (props && hasOwn(props, key)) {\n            warn$2(`The data property \"${key}\" is already declared as a prop. ` +\n                    `Use prop default value instead.`, vm);\n        }\n        else if (!isReserved(key)) {\n            proxy(vm, `_data`, key);\n        }\n    }\n    // observe data\n    const ob = observe(data);\n    ob && ob.vmCount++;\n}\nfunction getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n        return data.call(vm, vm);\n    }\n    catch (e) {\n        handleError(e, vm, `data()`);\n        return {};\n    }\n    finally {\n        popTarget();\n    }\n}\nconst computedWatcherOptions = { lazy: true };\nfunction initComputed$1(vm, computed) {\n    // $flow-disable-line\n    const watchers = (vm._computedWatchers = Object.create(null));\n    // computed properties are just getters during SSR\n    const isSSR = isServerRendering();\n    for (const key in computed) {\n        const userDef = computed[key];\n        const getter = isFunction(userDef) ? userDef : userDef.get;\n        if (getter == null) {\n            warn$2(`Getter is missing for computed property \"${key}\".`, vm);\n        }\n        if (!isSSR) {\n            // create internal watcher for the computed property.\n            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n        }\n        // component-defined computed properties are already defined on the\n        // component prototype. We only need to define computed properties defined\n        // at instantiation here.\n        if (!(key in vm)) {\n            defineComputed(vm, key, userDef);\n        }\n        else {\n            if (key in vm.$data) {\n                warn$2(`The computed property \"${key}\" is already defined in data.`, vm);\n            }\n            else if (vm.$options.props && key in vm.$options.props) {\n                warn$2(`The computed property \"${key}\" is already defined as a prop.`, vm);\n            }\n            else if (vm.$options.methods && key in vm.$options.methods) {\n                warn$2(`The computed property \"${key}\" is already defined as a method.`, vm);\n            }\n        }\n    }\n}\nfunction defineComputed(target, key, userDef) {\n    const shouldCache = !isServerRendering();\n    if (isFunction(userDef)) {\n        sharedPropertyDefinition.get = shouldCache\n            ? createComputedGetter(key)\n            : createGetterInvoker(userDef);\n        sharedPropertyDefinition.set = noop;\n    }\n    else {\n        sharedPropertyDefinition.get = userDef.get\n            ? shouldCache && userDef.cache !== false\n                ? createComputedGetter(key)\n                : createGetterInvoker(userDef.get)\n            : noop;\n        sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n        sharedPropertyDefinition.set = function () {\n            warn$2(`Computed property \"${key}\" was assigned to but it has no setter.`, this);\n        };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n}\nfunction createComputedGetter(key) {\n    return function computedGetter() {\n        const watcher = this._computedWatchers && this._computedWatchers[key];\n        if (watcher) {\n            if (watcher.dirty) {\n                watcher.evaluate();\n            }\n            if (Dep.target) {\n                if (Dep.target.onTrack) {\n                    Dep.target.onTrack({\n                        effect: Dep.target,\n                        target: this,\n                        type: \"get\" /* TrackOpTypes.GET */,\n                        key\n                    });\n                }\n                watcher.depend();\n            }\n            return watcher.value;\n        }\n    };\n}\nfunction createGetterInvoker(fn) {\n    return function computedGetter() {\n        return fn.call(this, this);\n    };\n}\nfunction initMethods(vm, methods) {\n    const props = vm.$options.props;\n    for (const key in methods) {\n        {\n            if (typeof methods[key] !== 'function') {\n                warn$2(`Method \"${key}\" has type \"${typeof methods[key]}\" in the component definition. ` +\n                    `Did you reference the function correctly?`, vm);\n            }\n            if (props && hasOwn(props, key)) {\n                warn$2(`Method \"${key}\" has already been defined as a prop.`, vm);\n            }\n            if (key in vm && isReserved(key)) {\n                warn$2(`Method \"${key}\" conflicts with an existing Vue instance method. ` +\n                    `Avoid defining component methods that start with _ or $.`);\n            }\n        }\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);\n    }\n}\nfunction initWatch(vm, watch) {\n    for (const key in watch) {\n        const handler = watch[key];\n        if (isArray(handler)) {\n            for (let i = 0; i < handler.length; i++) {\n                createWatcher(vm, key, handler[i]);\n            }\n        }\n        else {\n            createWatcher(vm, key, handler);\n        }\n    }\n}\nfunction createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n        options = handler;\n        handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n        handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options);\n}\nfunction stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    const dataDef = {};\n    dataDef.get = function () {\n        return this._data;\n    };\n    const propsDef = {};\n    propsDef.get = function () {\n        return this._props;\n    };\n    {\n        dataDef.set = function () {\n            warn$2('Avoid replacing instance root $data. ' +\n                'Use nested data properties instead.', this);\n        };\n        propsDef.set = function () {\n            warn$2(`$props is readonly.`, this);\n        };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n        const vm = this;\n        if (isPlainObject(cb)) {\n            return createWatcher(vm, expOrFn, cb, options);\n        }\n        options = options || {};\n        options.user = true;\n        const watcher = new Watcher(vm, expOrFn, cb, options);\n        if (options.immediate) {\n            const info = `callback for immediate watcher \"${watcher.expression}\"`;\n            pushTarget();\n            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n            popTarget();\n        }\n        return function unwatchFn() {\n            watcher.teardown();\n        };\n    };\n}\n\nfunction initProvide(vm) {\n    const provideOption = vm.$options.provide;\n    if (provideOption) {\n        const provided = isFunction(provideOption)\n            ? provideOption.call(vm)\n            : provideOption;\n        if (!isObject(provided)) {\n            return;\n        }\n        const source = resolveProvided(vm);\n        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\n        // iterate the keys ourselves.\n        const keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\n        }\n    }\n}\nfunction initInjections(vm) {\n    const result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n        toggleObserving(false);\n        Object.keys(result).forEach(key => {\n            /* istanbul ignore else */\n            {\n                defineReactive(vm, key, result[key], () => {\n                    warn$2(`Avoid mutating an injected value directly since the changes will be ` +\n                        `overwritten whenever the provided component re-renders. ` +\n                        `injection being mutated: \"${key}\"`, vm);\n                });\n            }\n        });\n        toggleObserving(true);\n    }\n}\nfunction resolveInject(inject, vm) {\n    if (inject) {\n        // inject is :any because flow is not smart enough to figure out cached\n        const result = Object.create(null);\n        const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            // #6574 in case the inject object is observed...\n            if (key === '__ob__')\n                continue;\n            const provideKey = inject[key].from;\n            if (provideKey in vm._provided) {\n                result[key] = vm._provided[provideKey];\n            }\n            else if ('default' in inject[key]) {\n                const provideDefault = inject[key].default;\n                result[key] = isFunction(provideDefault)\n                    ? provideDefault.call(vm)\n                    : provideDefault;\n            }\n            else {\n                warn$2(`Injection \"${key}\" not found`, vm);\n            }\n        }\n        return result;\n    }\n}\n\nlet uid = 0;\nfunction initMixin$1(Vue) {\n    Vue.prototype._init = function (options) {\n        const vm = this;\n        // a uid\n        vm._uid = uid++;\n        let startTag, endTag;\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n            startTag = `vue-perf-start:${vm._uid}`;\n            endTag = `vue-perf-end:${vm._uid}`;\n            mark(startTag);\n        }\n        // a flag to mark this as a Vue instance without having to do instanceof\n        // check\n        vm._isVue = true;\n        // avoid instances from being observed\n        vm.__v_skip = true;\n        // effect scope\n        vm._scope = new EffectScope(true /* detached */);\n        vm._scope._vm = true;\n        // merge options\n        if (options && options._isComponent) {\n            // optimize internal component instantiation\n            // since dynamic options merging is pretty slow, and none of the\n            // internal component options needs special treatment.\n            initInternalComponent(vm, options);\n        }\n        else {\n            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n        }\n        /* istanbul ignore else */\n        {\n            initProxy(vm);\n        }\n        // expose real self\n        vm._self = vm;\n        initLifecycle(vm);\n        initEvents(vm);\n        initRender(vm);\n        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);\n        initInjections(vm); // resolve injections before data/props\n        initState(vm);\n        initProvide(vm); // resolve provide after data/props\n        callHook$1(vm, 'created');\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n            vm._name = formatComponentName(vm, false);\n            mark(endTag);\n            measure(`vue ${vm._name} init`, startTag, endTag);\n        }\n        if (vm.$options.el) {\n            vm.$mount(vm.$options.el);\n        }\n    };\n}\nfunction initInternalComponent(vm, options) {\n    const opts = (vm.$options = Object.create(vm.constructor.options));\n    // doing this because it's faster than dynamic enumeration.\n    const parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    const vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n    if (options.render) {\n        opts.render = options.render;\n        opts.staticRenderFns = options.staticRenderFns;\n    }\n}\nfunction resolveConstructorOptions(Ctor) {\n    let options = Ctor.options;\n    if (Ctor.super) {\n        const superOptions = resolveConstructorOptions(Ctor.super);\n        const cachedSuperOptions = Ctor.superOptions;\n        if (superOptions !== cachedSuperOptions) {\n            // super option changed,\n            // need to resolve new options.\n            Ctor.superOptions = superOptions;\n            // check if there are any late-modified/attached options (#4976)\n            const modifiedOptions = resolveModifiedOptions(Ctor);\n            // update base extend options\n            if (modifiedOptions) {\n                extend(Ctor.extendOptions, modifiedOptions);\n            }\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n            if (options.name) {\n                options.components[options.name] = Ctor;\n            }\n        }\n    }\n    return options;\n}\nfunction resolveModifiedOptions(Ctor) {\n    let modified;\n    const latest = Ctor.options;\n    const sealed = Ctor.sealedOptions;\n    for (const key in latest) {\n        if (latest[key] !== sealed[key]) {\n            if (!modified)\n                modified = {};\n            modified[key] = latest[key];\n        }\n    }\n    return modified;\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n    const options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    let contextVm;\n    if (hasOwn(parent, '_uid')) {\n        contextVm = Object.create(parent);\n        contextVm._original = parent;\n    }\n    else {\n        // the context vm passed in is a functional context as well.\n        // in this case we want to make sure we are able to get a hold to the\n        // real context instance.\n        contextVm = parent;\n        // @ts-ignore\n        parent = parent._original;\n    }\n    const isCompiled = isTrue(options._compiled);\n    const needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = () => {\n        if (!this.$slots) {\n            normalizeScopedSlots(parent, data.scopedSlots, (this.$slots = resolveSlots(children, parent)));\n        }\n        return this.$slots;\n    };\n    Object.defineProperty(this, 'scopedSlots', {\n        enumerable: true,\n        get() {\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\n        }\n    });\n    // support for compiled functional template\n    if (isCompiled) {\n        // exposing $options for renderStatic()\n        this.$options = options;\n        // pre-resolve slots for renderSlot()\n        this.$slots = this.slots();\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\n    }\n    if (options._scopeId) {\n        this._c = (a, b, c, d) => {\n            const vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\n            if (vnode && !isArray(vnode)) {\n                vnode.fnScopeId = options._scopeId;\n                vnode.fnContext = parent;\n            }\n            return vnode;\n        };\n    }\n    else {\n        this._c = (a, b, c, d) => createElement$1(contextVm, a, b, c, d, needNormalization);\n    }\n}\ninstallRenderHelpers(FunctionalRenderContext.prototype);\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    const options = Ctor.options;\n    const props = {};\n    const propOptions = options.props;\n    if (isDef(propOptions)) {\n        for (const key in propOptions) {\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\n        }\n    }\n    else {\n        if (isDef(data.attrs))\n            mergeProps(props, data.attrs);\n        if (isDef(data.props))\n            mergeProps(props, data.props);\n    }\n    const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    const vnode = options.render.call(null, renderContext._c, renderContext);\n    if (vnode instanceof VNode) {\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    }\n    else if (isArray(vnode)) {\n        const vnodes = normalizeChildren(vnode) || [];\n        const res = new Array(vnodes.length);\n        for (let i = 0; i < vnodes.length; i++) {\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n        }\n        return res;\n    }\n}\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    const clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =\n            renderContext;\n    }\n    if (data.slot) {\n        (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone;\n}\nfunction mergeProps(to, from) {\n    for (const key in from) {\n        to[camelize(key)] = from[key];\n    }\n}\n\nfunction getComponentName(options) {\n    return options.name || options.__name || options._componentTag;\n}\n// inline hooks to be invoked on component VNodes during patch\nconst componentVNodeHooks = {\n    init(vnode, hydrating) {\n        if (vnode.componentInstance &&\n            !vnode.componentInstance._isDestroyed &&\n            vnode.data.keepAlive) {\n            // kept-alive components, treat as a patch\n            const mountedNode = vnode; // work around flow\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\n        }\n        else {\n            const child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n        }\n    },\n    prepatch(oldVnode, vnode) {\n        const options = vnode.componentOptions;\n        const child = (vnode.componentInstance = oldVnode.componentInstance);\n        updateChildComponent(child, options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n        );\n    },\n    insert(vnode) {\n        const { context, componentInstance } = vnode;\n        if (!componentInstance._isMounted) {\n            componentInstance._isMounted = true;\n            callHook$1(componentInstance, 'mounted');\n        }\n        if (vnode.data.keepAlive) {\n            if (context._isMounted) {\n                // vue-router#1212\n                // During updates, a kept-alive component's child components may\n                // change, so directly walking the tree here may call activated hooks\n                // on incorrect children. Instead we push them into a queue which will\n                // be processed after the whole patch process ended.\n                queueActivatedComponent(componentInstance);\n            }\n            else {\n                activateChildComponent(componentInstance, true /* direct */);\n            }\n        }\n    },\n    destroy(vnode) {\n        const { componentInstance } = vnode;\n        if (!componentInstance._isDestroyed) {\n            if (!vnode.data.keepAlive) {\n                componentInstance.$destroy();\n            }\n            else {\n                deactivateChildComponent(componentInstance, true /* direct */);\n            }\n        }\n    }\n};\nconst hooksToMerge = Object.keys(componentVNodeHooks);\nfunction createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n        return;\n    }\n    const baseCtor = context.$options._base;\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n        Ctor = baseCtor.extend(Ctor);\n    }\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n        {\n            warn$2(`Invalid Component definition: ${String(Ctor)}`, context);\n        }\n        return;\n    }\n    // async component\n    let asyncFactory;\n    // @ts-expect-error\n    if (isUndef(Ctor.cid)) {\n        asyncFactory = Ctor;\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n        if (Ctor === undefined) {\n            // return a placeholder node for async component, which is rendered\n            // as a comment node but preserves all the raw information for the node.\n            // the information will be used for async server-rendering and hydration.\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n        }\n    }\n    data = data || {};\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n        // @ts-expect-error\n        transformModel(Ctor.options, data);\n    }\n    // extract props\n    // @ts-expect-error\n    const propsData = extractPropsFromVNodeData(data, Ctor, tag);\n    // functional component\n    // @ts-expect-error\n    if (isTrue(Ctor.options.functional)) {\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    const listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n    // @ts-expect-error\n    if (isTrue(Ctor.options.abstract)) {\n        // abstract components do not keep anything\n        // other than props & listeners & slot\n        // work around flow\n        const slot = data.slot;\n        data = {};\n        if (slot) {\n            data.slot = slot;\n        }\n    }\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n    // return a placeholder vnode\n    // @ts-expect-error\n    const name = getComponentName(Ctor.options) || tag;\n    const vnode = new VNode(\n    // @ts-expect-error\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, \n    // @ts-expect-error\n    { Ctor, propsData, listeners, tag, children }, asyncFactory);\n    return vnode;\n}\nfunction createComponentInstanceForVnode(\n// we know it's MountedComponentVNode but flow doesn't\nvnode, \n// activeInstance in lifecycle state\nparent) {\n    const options = {\n        _isComponent: true,\n        _parentVnode: vnode,\n        parent\n    };\n    // check inline-template render functions\n    const inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n        options.render = inlineTemplate.render;\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options);\n}\nfunction installComponentHooks(data) {\n    const hooks = data.hook || (data.hook = {});\n    for (let i = 0; i < hooksToMerge.length; i++) {\n        const key = hooksToMerge[i];\n        const existing = hooks[key];\n        const toMerge = componentVNodeHooks[key];\n        // @ts-expect-error\n        if (existing !== toMerge && !(existing && existing._merged)) {\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\n        }\n    }\n}\nfunction mergeHook(f1, f2) {\n    const merged = (a, b) => {\n        // flow complains about extra args which is why we use any\n        f1(a, b);\n        f2(a, b);\n    };\n    merged._merged = true;\n    return merged;\n}\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n    const prop = (options.model && options.model.prop) || 'value';\n    const event = (options.model && options.model.event) || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    const on = data.on || (data.on = {});\n    const existing = on[event];\n    const callback = data.model.callback;\n    if (isDef(existing)) {\n        if (isArray(existing)\n            ? existing.indexOf(callback) === -1\n            : existing !== callback) {\n            on[event] = [callback].concat(existing);\n        }\n    }\n    else {\n        on[event] = callback;\n    }\n}\n\nlet warn$2 = noop;\nlet tip = noop;\nlet generateComponentTrace; // work around flow check\nlet formatComponentName;\n{\n    const hasConsole = typeof console !== 'undefined';\n    const classifyRE = /(?:^|[-_])(\\w)/g;\n    const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\n    warn$2 = (msg, vm = currentInstance) => {\n        const trace = vm ? generateComponentTrace(vm) : '';\n        if (config.warnHandler) {\n            config.warnHandler.call(null, msg, vm, trace);\n        }\n        else if (hasConsole && !config.silent) {\n            console.error(`[Vue warn]: ${msg}${trace}`);\n        }\n    };\n    tip = (msg, vm) => {\n        if (hasConsole && !config.silent) {\n            console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));\n        }\n    };\n    formatComponentName = (vm, includeFile) => {\n        if (vm.$root === vm) {\n            return '<Root>';\n        }\n        const options = isFunction(vm) && vm.cid != null\n            ? vm.options\n            : vm._isVue\n                ? vm.$options || vm.constructor.options\n                : vm;\n        let name = getComponentName(options);\n        const file = options.__file;\n        if (!name && file) {\n            const match = file.match(/([^/\\\\]+)\\.vue$/);\n            name = match && match[1];\n        }\n        return ((name ? `<${classify(name)}>` : `<Anonymous>`) +\n            (file && includeFile !== false ? ` at ${file}` : ''));\n    };\n    const repeat = (str, n) => {\n        let res = '';\n        while (n) {\n            if (n % 2 === 1)\n                res += str;\n            if (n > 1)\n                str += str;\n            n >>= 1;\n        }\n        return res;\n    };\n    generateComponentTrace = (vm) => {\n        if (vm._isVue && vm.$parent) {\n            const tree = [];\n            let currentRecursiveSequence = 0;\n            while (vm) {\n                if (tree.length > 0) {\n                    const last = tree[tree.length - 1];\n                    if (last.constructor === vm.constructor) {\n                        currentRecursiveSequence++;\n                        vm = vm.$parent;\n                        continue;\n                    }\n                    else if (currentRecursiveSequence > 0) {\n                        tree[tree.length - 1] = [last, currentRecursiveSequence];\n                        currentRecursiveSequence = 0;\n                    }\n                }\n                tree.push(vm);\n                vm = vm.$parent;\n            }\n            return ('\\n\\nfound in\\n\\n' +\n                tree\n                    .map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${isArray(vm)\n                    ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`\n                    : formatComponentName(vm)}`)\n                    .join('\\n'));\n        }\n        else {\n            return `\\n\\n(found in ${formatComponentName(vm)})`;\n        }\n    };\n}\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nconst strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\n{\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n        if (!vm) {\n            warn$2(`option \"${key}\" can only be used during instance ` +\n                'creation with the `new` keyword.');\n        }\n        return defaultStrat(parent, child);\n    };\n}\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from, recursive = true) {\n    if (!from)\n        return to;\n    let key, toVal, fromVal;\n    const keys = hasSymbol\n        ? Reflect.ownKeys(from)\n        : Object.keys(from);\n    for (let i = 0; i < keys.length; i++) {\n        key = keys[i];\n        // in case the object is already observed...\n        if (key === '__ob__')\n            continue;\n        toVal = to[key];\n        fromVal = from[key];\n        if (!recursive || !hasOwn(to, key)) {\n            set(to, key, fromVal);\n        }\n        else if (toVal !== fromVal &&\n            isPlainObject(toVal) &&\n            isPlainObject(fromVal)) {\n            mergeData(toVal, fromVal);\n        }\n    }\n    return to;\n}\n/**\n * Data\n */\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n        // in a Vue.extend merge, both should be functions\n        if (!childVal) {\n            return parentVal;\n        }\n        if (!parentVal) {\n            return childVal;\n        }\n        // when parentVal & childVal are both present,\n        // we need to return a function that returns the\n        // merged result of both functions... no need to\n        // check if parentVal is a function here because\n        // it has to be a function to pass previous merges.\n        return function mergedDataFn() {\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\n        };\n    }\n    else {\n        return function mergedInstanceDataFn() {\n            // instance merge\n            const instanceData = isFunction(childVal)\n                ? childVal.call(vm, vm)\n                : childVal;\n            const defaultData = isFunction(parentVal)\n                ? parentVal.call(vm, vm)\n                : parentVal;\n            if (instanceData) {\n                return mergeData(instanceData, defaultData);\n            }\n            else {\n                return defaultData;\n            }\n        };\n    }\n}\nstrats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n        if (childVal && typeof childVal !== 'function') {\n            warn$2('The \"data\" option should be a function ' +\n                    'that returns a per-instance value in component ' +\n                    'definitions.', vm);\n            return parentVal;\n        }\n        return mergeDataOrFn(parentVal, childVal);\n    }\n    return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeLifecycleHook(parentVal, childVal) {\n    const res = childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : isArray(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n    return res ? dedupeHooks(res) : res;\n}\nfunction dedupeHooks(hooks) {\n    const res = [];\n    for (let i = 0; i < hooks.length; i++) {\n        if (res.indexOf(hooks[i]) === -1) {\n            res.push(hooks[i]);\n        }\n    }\n    return res;\n}\nLIFECYCLE_HOOKS.forEach(hook => {\n    strats[hook] = mergeLifecycleHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal, vm, key) {\n    const res = Object.create(parentVal || null);\n    if (childVal) {\n        assertObjectType(key, childVal, vm);\n        return extend(res, childVal);\n    }\n    else {\n        return res;\n    }\n}\nASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    //@ts-expect-error work around\n    if (parentVal === nativeWatch)\n        parentVal = undefined;\n    //@ts-expect-error work around\n    if (childVal === nativeWatch)\n        childVal = undefined;\n    /* istanbul ignore if */\n    if (!childVal)\n        return Object.create(parentVal || null);\n    {\n        assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal)\n        return childVal;\n    const ret = {};\n    extend(ret, parentVal);\n    for (const key in childVal) {\n        let parent = ret[key];\n        const child = childVal[key];\n        if (parent && !isArray(parent)) {\n            parent = [parent];\n        }\n        ret[key] = parent ? parent.concat(child) : isArray(child) ? child : [child];\n    }\n    return ret;\n};\n/**\n * Other object hashes.\n */\nstrats.props =\n    strats.methods =\n        strats.inject =\n            strats.computed =\n                function (parentVal, childVal, vm, key) {\n                    if (childVal && true) {\n                        assertObjectType(key, childVal, vm);\n                    }\n                    if (!parentVal)\n                        return childVal;\n                    const ret = Object.create(null);\n                    extend(ret, parentVal);\n                    if (childVal)\n                        extend(ret, childVal);\n                    return ret;\n                };\nstrats.provide = function (parentVal, childVal) {\n    if (!parentVal)\n        return childVal;\n    return function () {\n        const ret = Object.create(null);\n        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);\n        if (childVal) {\n            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive\n            );\n        }\n        return ret;\n    };\n};\n/**\n * Default strategy.\n */\nconst defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n    for (const key in options.components) {\n        validateComponentName(key);\n    }\n}\nfunction validateComponentName(name) {\n    if (!new RegExp(`^[a-zA-Z][\\\\-\\\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {\n        warn$2('Invalid component name: \"' +\n            name +\n            '\". Component names ' +\n            'should conform to valid custom element name in html5 specification.');\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n        warn$2('Do not use built-in or reserved HTML elements as component ' +\n            'id: ' +\n            name);\n    }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options, vm) {\n    const props = options.props;\n    if (!props)\n        return;\n    const res = {};\n    let i, val, name;\n    if (isArray(props)) {\n        i = props.length;\n        while (i--) {\n            val = props[i];\n            if (typeof val === 'string') {\n                name = camelize(val);\n                res[name] = { type: null };\n            }\n            else {\n                warn$2('props must be strings when using array syntax.');\n            }\n        }\n    }\n    else if (isPlainObject(props)) {\n        for (const key in props) {\n            val = props[key];\n            name = camelize(key);\n            res[name] = isPlainObject(val) ? val : { type: val };\n        }\n    }\n    else {\n        warn$2(`Invalid value for option \"props\": expected an Array or an Object, ` +\n            `but got ${toRawType(props)}.`, vm);\n    }\n    options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject(options, vm) {\n    const inject = options.inject;\n    if (!inject)\n        return;\n    const normalized = (options.inject = {});\n    if (isArray(inject)) {\n        for (let i = 0; i < inject.length; i++) {\n            normalized[inject[i]] = { from: inject[i] };\n        }\n    }\n    else if (isPlainObject(inject)) {\n        for (const key in inject) {\n            const val = inject[key];\n            normalized[key] = isPlainObject(val)\n                ? extend({ from: key }, val)\n                : { from: val };\n        }\n    }\n    else {\n        warn$2(`Invalid value for option \"inject\": expected an Array or an Object, ` +\n            `but got ${toRawType(inject)}.`, vm);\n    }\n}\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives$1(options) {\n    const dirs = options.directives;\n    if (dirs) {\n        for (const key in dirs) {\n            const def = dirs[key];\n            if (isFunction(def)) {\n                dirs[key] = { bind: def, update: def };\n            }\n        }\n    }\n}\nfunction assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n        warn$2(`Invalid value for option \"${name}\": expected an Object, ` +\n            `but got ${toRawType(value)}.`, vm);\n    }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n    {\n        checkComponents(child);\n    }\n    if (isFunction(child)) {\n        // @ts-expect-error\n        child = child.options;\n    }\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives$1(child);\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n        if (child.extends) {\n            parent = mergeOptions(parent, child.extends, vm);\n        }\n        if (child.mixins) {\n            for (let i = 0, l = child.mixins.length; i < l; i++) {\n                parent = mergeOptions(parent, child.mixins[i], vm);\n            }\n        }\n    }\n    const options = {};\n    let key;\n    for (key in parent) {\n        mergeField(key);\n    }\n    for (key in child) {\n        if (!hasOwn(parent, key)) {\n            mergeField(key);\n        }\n    }\n    function mergeField(key) {\n        const strat = strats[key] || defaultStrat;\n        options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n        return;\n    }\n    const assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id))\n        return assets[id];\n    const camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId))\n        return assets[camelizedId];\n    const PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId))\n        return assets[PascalCaseId];\n    // fallback to prototype chain\n    const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n        warn$2('Failed to resolve ' + type.slice(0, -1) + ': ' + id);\n    }\n    return res;\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\n    const prop = propOptions[key];\n    const absent = !hasOwn(propsData, key);\n    let value = propsData[key];\n    // boolean casting\n    const booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n        if (absent && !hasOwn(prop, 'default')) {\n            value = false;\n        }\n        else if (value === '' || value === hyphenate(key)) {\n            // only cast empty string / same name to boolean if\n            // boolean has higher priority\n            const stringIndex = getTypeIndex(String, prop.type);\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\n                value = true;\n            }\n        }\n    }\n    // check default value\n    if (value === undefined) {\n        value = getPropDefaultValue(vm, prop, key);\n        // since the default value is a fresh copy,\n        // make sure to observe it.\n        const prevShouldObserve = shouldObserve;\n        toggleObserving(true);\n        observe(value);\n        toggleObserving(prevShouldObserve);\n    }\n    {\n        assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n}\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n        return undefined;\n    }\n    const def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n        warn$2('Invalid default value for prop \"' +\n            key +\n            '\": ' +\n            'Props with type Object/Array must use a factory function ' +\n            'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm &&\n        vm.$options.propsData &&\n        vm.$options.propsData[key] === undefined &&\n        vm._props[key] !== undefined) {\n        return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return isFunction(def) && getType(prop.type) !== 'Function'\n        ? def.call(vm)\n        : def;\n}\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n        warn$2('Missing required prop: \"' + name + '\"', vm);\n        return;\n    }\n    if (value == null && !prop.required) {\n        return;\n    }\n    let type = prop.type;\n    let valid = !type || type === true;\n    const expectedTypes = [];\n    if (type) {\n        if (!isArray(type)) {\n            type = [type];\n        }\n        for (let i = 0; i < type.length && !valid; i++) {\n            const assertedType = assertType(value, type[i], vm);\n            expectedTypes.push(assertedType.expectedType || '');\n            valid = assertedType.valid;\n        }\n    }\n    const haveExpectedTypes = expectedTypes.some(t => t);\n    if (!valid && haveExpectedTypes) {\n        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);\n        return;\n    }\n    const validator = prop.validator;\n    if (validator) {\n        if (!validator(value)) {\n            warn$2('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n        }\n    }\n}\nconst simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\nfunction assertType(value, type, vm) {\n    let valid;\n    const expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n        const t = typeof value;\n        valid = t === expectedType.toLowerCase();\n        // for primitive wrapper objects\n        if (!valid && t === 'object') {\n            valid = value instanceof type;\n        }\n    }\n    else if (expectedType === 'Object') {\n        valid = isPlainObject(value);\n    }\n    else if (expectedType === 'Array') {\n        valid = isArray(value);\n    }\n    else {\n        try {\n            valid = value instanceof type;\n        }\n        catch (e) {\n            warn$2('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n            valid = false;\n        }\n    }\n    return {\n        valid,\n        expectedType\n    };\n}\nconst functionTypeCheckRE = /^\\s*function (\\w+)/;\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n    const match = fn && fn.toString().match(functionTypeCheckRE);\n    return match ? match[1] : '';\n}\nfunction isSameType(a, b) {\n    return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n    if (!isArray(expectedTypes)) {\n        return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n    for (let i = 0, len = expectedTypes.length; i < len; i++) {\n        if (isSameType(expectedTypes[i], type)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\n        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;\n    const expectedType = expectedTypes[0];\n    const receivedType = toRawType(value);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        isExplicable(typeof value) &&\n        !isBoolean(expectedType, receivedType)) {\n        message += ` with value ${styleValue(value, expectedType)}`;\n    }\n    message += `, got ${receivedType} `;\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n        message += `with value ${styleValue(value, receivedType)}.`;\n    }\n    return message;\n}\nfunction styleValue(value, type) {\n    if (type === 'String') {\n        return `\"${value}\"`;\n    }\n    else if (type === 'Number') {\n        return `${Number(value)}`;\n    }\n    else {\n        return `${value}`;\n    }\n}\nconst EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\nfunction isExplicable(value) {\n    return EXPLICABLE_TYPES.some(elem => value.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n    return args.some(elem => elem.toLowerCase() === 'boolean');\n}\n\nfunction Vue(options) {\n    if (!(this instanceof Vue)) {\n        warn$2('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n}\n//@ts-expect-error Vue has function type\ninitMixin$1(Vue);\n//@ts-expect-error Vue has function type\nstateMixin(Vue);\n//@ts-expect-error Vue has function type\neventsMixin(Vue);\n//@ts-expect-error Vue has function type\nlifecycleMixin(Vue);\n//@ts-expect-error Vue has function type\nrenderMixin(Vue);\n\nfunction initUse(Vue) {\n    Vue.use = function (plugin) {\n        const installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n        if (installedPlugins.indexOf(plugin) > -1) {\n            return this;\n        }\n        // additional parameters\n        const args = toArray(arguments, 1);\n        args.unshift(this);\n        if (isFunction(plugin.install)) {\n            plugin.install.apply(plugin, args);\n        }\n        else if (isFunction(plugin)) {\n            plugin.apply(null, args);\n        }\n        installedPlugins.push(plugin);\n        return this;\n    };\n}\n\nfunction initMixin(Vue) {\n    Vue.mixin = function (mixin) {\n        this.options = mergeOptions(this.options, mixin);\n        return this;\n    };\n}\n\nfunction initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    let cid = 1;\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n        extendOptions = extendOptions || {};\n        const Super = this;\n        const SuperId = Super.cid;\n        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n        if (cachedCtors[SuperId]) {\n            return cachedCtors[SuperId];\n        }\n        const name = getComponentName(extendOptions) || getComponentName(Super.options);\n        if (name) {\n            validateComponentName(name);\n        }\n        const Sub = function VueComponent(options) {\n            this._init(options);\n        };\n        Sub.prototype = Object.create(Super.prototype);\n        Sub.prototype.constructor = Sub;\n        Sub.cid = cid++;\n        Sub.options = mergeOptions(Super.options, extendOptions);\n        Sub['super'] = Super;\n        // For props and computed properties, we define the proxy getters on\n        // the Vue instances at extension time, on the extended prototype. This\n        // avoids Object.defineProperty calls for each instance created.\n        if (Sub.options.props) {\n            initProps(Sub);\n        }\n        if (Sub.options.computed) {\n            initComputed(Sub);\n        }\n        // allow further extension/mixin/plugin usage\n        Sub.extend = Super.extend;\n        Sub.mixin = Super.mixin;\n        Sub.use = Super.use;\n        // create asset registers, so extended classes\n        // can have their private assets too.\n        ASSET_TYPES.forEach(function (type) {\n            Sub[type] = Super[type];\n        });\n        // enable recursive self-lookup\n        if (name) {\n            Sub.options.components[name] = Sub;\n        }\n        // keep a reference to the super options at extension time.\n        // later at instantiation we can check if Super's options have\n        // been updated.\n        Sub.superOptions = Super.options;\n        Sub.extendOptions = extendOptions;\n        Sub.sealedOptions = extend({}, Sub.options);\n        // cache constructor\n        cachedCtors[SuperId] = Sub;\n        return Sub;\n    };\n}\nfunction initProps(Comp) {\n    const props = Comp.options.props;\n    for (const key in props) {\n        proxy(Comp.prototype, `_props`, key);\n    }\n}\nfunction initComputed(Comp) {\n    const computed = Comp.options.computed;\n    for (const key in computed) {\n        defineComputed(Comp.prototype, key, computed[key]);\n    }\n}\n\nfunction initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(type => {\n        // @ts-expect-error function is not exact same type\n        Vue[type] = function (id, definition) {\n            if (!definition) {\n                return this.options[type + 's'][id];\n            }\n            else {\n                /* istanbul ignore if */\n                if (type === 'component') {\n                    validateComponentName(id);\n                }\n                if (type === 'component' && isPlainObject(definition)) {\n                    // @ts-expect-error\n                    definition.name = definition.name || id;\n                    definition = this.options._base.extend(definition);\n                }\n                if (type === 'directive' && isFunction(definition)) {\n                    definition = { bind: definition, update: definition };\n                }\n                this.options[type + 's'][id] = definition;\n                return definition;\n            }\n        };\n    });\n}\n\nfunction _getComponentName(opts) {\n    return opts && (getComponentName(opts.Ctor.options) || opts.tag);\n}\nfunction matches(pattern, name) {\n    if (isArray(pattern)) {\n        return pattern.indexOf(name) > -1;\n    }\n    else if (typeof pattern === 'string') {\n        return pattern.split(',').indexOf(name) > -1;\n    }\n    else if (isRegExp(pattern)) {\n        return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n}\nfunction pruneCache(keepAliveInstance, filter) {\n    const { cache, keys, _vnode } = keepAliveInstance;\n    for (const key in cache) {\n        const entry = cache[key];\n        if (entry) {\n            const name = entry.name;\n            if (name && !filter(name)) {\n                pruneCacheEntry(cache, key, keys, _vnode);\n            }\n        }\n    }\n}\nfunction pruneCacheEntry(cache, key, keys, current) {\n    const entry = cache[key];\n    if (entry && (!current || entry.tag !== current.tag)) {\n        // @ts-expect-error can be undefined\n        entry.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove$2(keys, key);\n}\nconst patternTypes = [String, RegExp, Array];\n// TODO defineComponent\nvar KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    props: {\n        include: patternTypes,\n        exclude: patternTypes,\n        max: [String, Number]\n    },\n    methods: {\n        cacheVNode() {\n            const { cache, keys, vnodeToCache, keyToCache } = this;\n            if (vnodeToCache) {\n                const { tag, componentInstance, componentOptions } = vnodeToCache;\n                cache[keyToCache] = {\n                    name: _getComponentName(componentOptions),\n                    tag,\n                    componentInstance\n                };\n                keys.push(keyToCache);\n                // prune oldest entry\n                if (this.max && keys.length > parseInt(this.max)) {\n                    pruneCacheEntry(cache, keys[0], keys, this._vnode);\n                }\n                this.vnodeToCache = null;\n            }\n        }\n    },\n    created() {\n        this.cache = Object.create(null);\n        this.keys = [];\n    },\n    destroyed() {\n        for (const key in this.cache) {\n            pruneCacheEntry(this.cache, key, this.keys);\n        }\n    },\n    mounted() {\n        this.cacheVNode();\n        this.$watch('include', val => {\n            pruneCache(this, name => matches(val, name));\n        });\n        this.$watch('exclude', val => {\n            pruneCache(this, name => !matches(val, name));\n        });\n    },\n    updated() {\n        this.cacheVNode();\n    },\n    render() {\n        const slot = this.$slots.default;\n        const vnode = getFirstComponentChild(slot);\n        const componentOptions = vnode && vnode.componentOptions;\n        if (componentOptions) {\n            // check pattern\n            const name = _getComponentName(componentOptions);\n            const { include, exclude } = this;\n            if (\n            // not included\n            (include && (!name || !matches(include, name))) ||\n                // excluded\n                (exclude && name && matches(exclude, name))) {\n                return vnode;\n            }\n            const { cache, keys } = this;\n            const key = vnode.key == null\n                ? // same constructor may get registered as different local components\n                    // so cid alone is not enough (#3269)\n                    componentOptions.Ctor.cid +\n                        (componentOptions.tag ? `::${componentOptions.tag}` : '')\n                : vnode.key;\n            if (cache[key]) {\n                vnode.componentInstance = cache[key].componentInstance;\n                // make current key freshest\n                remove$2(keys, key);\n                keys.push(key);\n            }\n            else {\n                // delay setting the cache until update\n                this.vnodeToCache = vnode;\n                this.keyToCache = key;\n            }\n            // @ts-expect-error can vnode.data can be undefined\n            vnode.data.keepAlive = true;\n        }\n        return vnode || (slot && slot[0]);\n    }\n};\n\nvar builtInComponents = {\n    KeepAlive\n};\n\nfunction initGlobalAPI(Vue) {\n    // config\n    const configDef = {};\n    configDef.get = () => config;\n    {\n        configDef.set = () => {\n            warn$2('Do not replace the Vue.config object, set individual fields instead.');\n        };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n        warn: warn$2,\n        extend,\n        mergeOptions,\n        defineReactive\n    };\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n    // 2.6 explicit observable API\n    Vue.observable = (obj) => {\n        observe(obj);\n        return obj;\n    };\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(type => {\n        Vue.options[type + 's'] = Object.create(null);\n    });\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n    get() {\n        /* istanbul ignore next */\n        return this.$vnode && this.$vnode.ssrContext;\n    }\n});\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n});\nVue.version = version;\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nconst isReservedAttr = makeMap('style,class');\n// attributes that should be using props for binding\nconst acceptValue = makeMap('input,textarea,option,select,progress');\nconst mustUseProp = (tag, type, attr) => {\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\n        (attr === 'selected' && tag === 'option') ||\n        (attr === 'checked' && tag === 'input') ||\n        (attr === 'muted' && tag === 'video'));\n};\nconst isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nconst isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\nconst convertEnumeratedValue = (key, value) => {\n    return isFalsyAttrValue(value) || value === 'false'\n        ? 'false'\n        : // allow arbitrary string value for contenteditable\n            key === 'contenteditable' && isValidContentEditableValue(value)\n                ? value\n                : 'true';\n};\nconst isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,' +\n    'truespeed,typemustmatch,visible');\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst isXlink = (name) => {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\nconst getXlinkProp = (name) => {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n};\nconst isFalsyAttrValue = (val) => {\n    return val == null || val === false;\n};\n\nfunction genClassForVnode(vnode) {\n    let data = vnode.data;\n    let parentNode = vnode;\n    let childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode && childNode.data) {\n            data = mergeClassData(childNode.data, data);\n        }\n    }\n    // @ts-expect-error parentNode.parent not VNodeWithData\n    while (isDef((parentNode = parentNode.parent))) {\n        if (parentNode && parentNode.data) {\n            data = mergeClassData(data, parentNode.data);\n        }\n    }\n    return renderClass(data.staticClass, data.class);\n}\nfunction mergeClassData(child, parent) {\n    return {\n        staticClass: concat(child.staticClass, parent.staticClass),\n        class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n}\nfunction renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n        return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n}\nfunction concat(a, b) {\n    return a ? (b ? a + ' ' + b : a) : b || '';\n}\nfunction stringifyClass(value) {\n    if (Array.isArray(value)) {\n        return stringifyArray(value);\n    }\n    if (isObject(value)) {\n        return stringifyObject(value);\n    }\n    if (typeof value === 'string') {\n        return value;\n    }\n    /* istanbul ignore next */\n    return '';\n}\nfunction stringifyArray(value) {\n    let res = '';\n    let stringified;\n    for (let i = 0, l = value.length; i < l; i++) {\n        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {\n            if (res)\n                res += ' ';\n            res += stringified;\n        }\n    }\n    return res;\n}\nfunction stringifyObject(value) {\n    let res = '';\n    for (const key in value) {\n        if (value[key]) {\n            if (res)\n                res += ' ';\n            res += key;\n        }\n    }\n    return res;\n}\n\nconst namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n};\nconst isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot');\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nconst isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\nconst isPreTag = (tag) => tag === 'pre';\nconst isReservedTag = (tag) => {\n    return isHTMLTag(tag) || isSVG(tag);\n};\nfunction getTagNamespace(tag) {\n    if (isSVG(tag)) {\n        return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n        return 'math';\n    }\n}\nconst unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n        return true;\n    }\n    if (isReservedTag(tag)) {\n        return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n        return unknownElementCache[tag];\n    }\n    const el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n        // http://stackoverflow.com/a/28210364/1070244\n        return (unknownElementCache[tag] =\n            el.constructor === window.HTMLUnknownElement ||\n                el.constructor === window.HTMLElement);\n    }\n    else {\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));\n    }\n}\nconst isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n    if (typeof el === 'string') {\n        const selected = document.querySelector(el);\n        if (!selected) {\n            warn$2('Cannot find element: ' + el);\n            return document.createElement('div');\n        }\n        return selected;\n    }\n    else {\n        return el;\n    }\n}\n\nfunction createElement(tagName, vnode) {\n    const elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n        return elm;\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data &&\n        vnode.data.attrs &&\n        vnode.data.attrs.multiple !== undefined) {\n        elm.setAttribute('multiple', 'multiple');\n    }\n    return elm;\n}\nfunction createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(node) {\n    return node.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\nvar ref = {\n    create(_, vnode) {\n        registerRef(vnode);\n    },\n    update(oldVnode, vnode) {\n        if (oldVnode.data.ref !== vnode.data.ref) {\n            registerRef(oldVnode, true);\n            registerRef(vnode);\n        }\n    },\n    destroy(vnode) {\n        registerRef(vnode, true);\n    }\n};\nfunction registerRef(vnode, isRemoval) {\n    const ref = vnode.data.ref;\n    if (!isDef(ref))\n        return;\n    const vm = vnode.context;\n    const refValue = vnode.componentInstance || vnode.elm;\n    const value = isRemoval ? null : refValue;\n    const $refsValue = isRemoval ? undefined : refValue;\n    if (isFunction(ref)) {\n        invokeWithErrorHandling(ref, vm, [value], vm, `template ref function`);\n        return;\n    }\n    const isFor = vnode.data.refInFor;\n    const _isString = typeof ref === 'string' || typeof ref === 'number';\n    const _isRef = isRef(ref);\n    const refs = vm.$refs;\n    if (_isString || _isRef) {\n        if (isFor) {\n            const existing = _isString ? refs[ref] : ref.value;\n            if (isRemoval) {\n                isArray(existing) && remove$2(existing, refValue);\n            }\n            else {\n                if (!isArray(existing)) {\n                    if (_isString) {\n                        refs[ref] = [refValue];\n                        setSetupRef(vm, ref, refs[ref]);\n                    }\n                    else {\n                        ref.value = [refValue];\n                    }\n                }\n                else if (!existing.includes(refValue)) {\n                    existing.push(refValue);\n                }\n            }\n        }\n        else if (_isString) {\n            if (isRemoval && refs[ref] !== refValue) {\n                return;\n            }\n            refs[ref] = $refsValue;\n            setSetupRef(vm, ref, value);\n        }\n        else if (_isRef) {\n            if (isRemoval && ref.value !== refValue) {\n                return;\n            }\n            ref.value = value;\n        }\n        else {\n            warn$2(`Invalid template ref type: ${typeof ref}`);\n        }\n    }\n}\nfunction setSetupRef({ _setupState }, key, val) {\n    if (_setupState && hasOwn(_setupState, key)) {\n        if (isRef(_setupState[key])) {\n            _setupState[key].value = val;\n        }\n        else {\n            _setupState[key] = val;\n        }\n    }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\nconst emptyNode = new VNode('', {}, []);\nconst hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\nfunction sameVnode(a, b) {\n    return (a.key === b.key &&\n        a.asyncFactory === b.asyncFactory &&\n        ((a.tag === b.tag &&\n            a.isComment === b.isComment &&\n            isDef(a.data) === isDef(b.data) &&\n            sameInputType(a, b)) ||\n            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));\n}\nfunction sameInputType(a, b) {\n    if (a.tag !== 'input')\n        return true;\n    let i;\n    const typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;\n    const typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;\n    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    let i, key;\n    const map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n        key = children[i].key;\n        if (isDef(key))\n            map[key] = i;\n    }\n    return map;\n}\nfunction createPatchFunction(backend) {\n    let i, j;\n    const cbs = {};\n    const { modules, nodeOps } = backend;\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            if (isDef(modules[j][hooks[i]])) {\n                cbs[hooks[i]].push(modules[j][hooks[i]]);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n    function createRmCb(childElm, listeners) {\n        function remove() {\n            if (--remove.listeners === 0) {\n                removeNode(childElm);\n            }\n        }\n        remove.listeners = listeners;\n        return remove;\n    }\n    function removeNode(el) {\n        const parent = nodeOps.parentNode(el);\n        // element may have already been removed due to v-html / v-text\n        if (isDef(parent)) {\n            nodeOps.removeChild(parent, el);\n        }\n    }\n    function isUnknownElement(vnode, inVPre) {\n        return (!inVPre &&\n            !vnode.ns &&\n            !(config.ignoredElements.length &&\n                config.ignoredElements.some(ignore => {\n                    return isRegExp(ignore)\n                        ? ignore.test(vnode.tag)\n                        : ignore === vnode.tag;\n                })) &&\n            config.isUnknownElement(vnode.tag));\n    }\n    let creatingElmInVPre = 0;\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\n            // This vnode was used in a previous render!\n            // now it's used as a new node, overwriting its elm would cause\n            // potential patch errors down the road when it's used as an insertion\n            // reference node. Instead, we clone the node on-demand before creating\n            // associated DOM element for it.\n            vnode = ownerArray[index] = cloneVNode(vnode);\n        }\n        vnode.isRootInsert = !nested; // for transition enter check\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n            return;\n        }\n        const data = vnode.data;\n        const children = vnode.children;\n        const tag = vnode.tag;\n        if (isDef(tag)) {\n            {\n                if (data && data.pre) {\n                    creatingElmInVPre++;\n                }\n                if (isUnknownElement(vnode, creatingElmInVPre)) {\n                    warn$2('Unknown custom element: <' +\n                        tag +\n                        '> - did you ' +\n                        'register the component correctly? For recursive components, ' +\n                        'make sure to provide the \"name\" option.', vnode.context);\n                }\n            }\n            vnode.elm = vnode.ns\n                ? nodeOps.createElementNS(vnode.ns, tag)\n                : nodeOps.createElement(tag, vnode);\n            setScope(vnode);\n            createChildren(vnode, children, insertedVnodeQueue);\n            if (isDef(data)) {\n                invokeCreateHooks(vnode, insertedVnodeQueue);\n            }\n            insert(parentElm, vnode.elm, refElm);\n            if (data && data.pre) {\n                creatingElmInVPre--;\n            }\n        }\n        else if (isTrue(vnode.isComment)) {\n            vnode.elm = nodeOps.createComment(vnode.text);\n            insert(parentElm, vnode.elm, refElm);\n        }\n        else {\n            vnode.elm = nodeOps.createTextNode(vnode.text);\n            insert(parentElm, vnode.elm, refElm);\n        }\n    }\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n        let i = vnode.data;\n        if (isDef(i)) {\n            const isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n            if (isDef((i = i.hook)) && isDef((i = i.init))) {\n                i(vnode, false /* hydrating */);\n            }\n            // after calling the init hook, if the vnode is a child component\n            // it should've created a child instance and mounted it. the child\n            // component also has set the placeholder vnode's elm.\n            // in that case we can just return the element and be done.\n            if (isDef(vnode.componentInstance)) {\n                initComponent(vnode, insertedVnodeQueue);\n                insert(parentElm, vnode.elm, refElm);\n                if (isTrue(isReactivated)) {\n                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n                }\n                return true;\n            }\n        }\n    }\n    function initComponent(vnode, insertedVnodeQueue) {\n        if (isDef(vnode.data.pendingInsert)) {\n            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n            vnode.data.pendingInsert = null;\n        }\n        vnode.elm = vnode.componentInstance.$el;\n        if (isPatchable(vnode)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            setScope(vnode);\n        }\n        else {\n            // empty component root.\n            // skip all element-related modules except for ref (#3455)\n            registerRef(vnode);\n            // make sure to invoke the insert hook\n            insertedVnodeQueue.push(vnode);\n        }\n    }\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n        let i;\n        // hack for #4339: a reactivated component with inner transition\n        // does not trigger because the inner node's created hooks are not called\n        // again. It's not ideal to involve module-specific logic in here but\n        // there doesn't seem to be a better way to do it.\n        let innerNode = vnode;\n        while (innerNode.componentInstance) {\n            innerNode = innerNode.componentInstance._vnode;\n            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {\n                for (i = 0; i < cbs.activate.length; ++i) {\n                    cbs.activate[i](emptyNode, innerNode);\n                }\n                insertedVnodeQueue.push(innerNode);\n                break;\n            }\n        }\n        // unlike a newly created component,\n        // a reactivated keep-alive component doesn't insert itself\n        insert(parentElm, vnode.elm, refElm);\n    }\n    function insert(parent, elm, ref) {\n        if (isDef(parent)) {\n            if (isDef(ref)) {\n                if (nodeOps.parentNode(ref) === parent) {\n                    nodeOps.insertBefore(parent, elm, ref);\n                }\n            }\n            else {\n                nodeOps.appendChild(parent, elm);\n            }\n        }\n    }\n    function createChildren(vnode, children, insertedVnodeQueue) {\n        if (isArray(children)) {\n            {\n                checkDuplicateKeys(children);\n            }\n            for (let i = 0; i < children.length; ++i) {\n                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n            }\n        }\n        else if (isPrimitive(vnode.text)) {\n            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n        }\n    }\n    function isPatchable(vnode) {\n        while (vnode.componentInstance) {\n            vnode = vnode.componentInstance._vnode;\n        }\n        return isDef(vnode.tag);\n    }\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n        for (let i = 0; i < cbs.create.length; ++i) {\n            cbs.create[i](emptyNode, vnode);\n        }\n        i = vnode.data.hook; // Reuse variable\n        if (isDef(i)) {\n            if (isDef(i.create))\n                i.create(emptyNode, vnode);\n            if (isDef(i.insert))\n                insertedVnodeQueue.push(vnode);\n        }\n    }\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n        let i;\n        if (isDef((i = vnode.fnScopeId))) {\n            nodeOps.setStyleScope(vnode.elm, i);\n        }\n        else {\n            let ancestor = vnode;\n            while (ancestor) {\n                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {\n                    nodeOps.setStyleScope(vnode.elm, i);\n                }\n                ancestor = ancestor.parent;\n            }\n        }\n        // for slot content they should also get the scopeId from the host instance.\n        if (isDef((i = activeInstance)) &&\n            i !== vnode.context &&\n            i !== vnode.fnContext &&\n            isDef((i = i.$options._scopeId))) {\n            nodeOps.setStyleScope(vnode.elm, i);\n        }\n    }\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        let i, j;\n        const data = vnode.data;\n        if (isDef(data)) {\n            if (isDef((i = data.hook)) && isDef((i = i.destroy)))\n                i(vnode);\n            for (i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n        }\n        if (isDef((i = vnode.children))) {\n            for (j = 0; j < vnode.children.length; ++j) {\n                invokeDestroyHook(vnode.children[j]);\n            }\n        }\n    }\n    function removeVnodes(vnodes, startIdx, endIdx) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (isDef(ch)) {\n                if (isDef(ch.tag)) {\n                    removeAndInvokeRemoveHook(ch);\n                    invokeDestroyHook(ch);\n                }\n                else {\n                    // Text node\n                    removeNode(ch.elm);\n                }\n            }\n        }\n    }\n    function removeAndInvokeRemoveHook(vnode, rm) {\n        if (isDef(rm) || isDef(vnode.data)) {\n            let i;\n            const listeners = cbs.remove.length + 1;\n            if (isDef(rm)) {\n                // we have a recursively passed down rm callback\n                // increase the listeners count\n                rm.listeners += listeners;\n            }\n            else {\n                // directly removing\n                rm = createRmCb(vnode.elm, listeners);\n            }\n            // recursively invoke hooks on child component root node\n            if (isDef((i = vnode.componentInstance)) &&\n                isDef((i = i._vnode)) &&\n                isDef(i.data)) {\n                removeAndInvokeRemoveHook(i, rm);\n            }\n            for (i = 0; i < cbs.remove.length; ++i) {\n                cbs.remove[i](vnode, rm);\n            }\n            if (isDef((i = vnode.data.hook)) && isDef((i = i.remove))) {\n                i(vnode, rm);\n            }\n            else {\n                rm();\n            }\n        }\n        else {\n            removeNode(vnode.elm);\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n        // removeOnly is a special flag used only by <transition-group>\n        // to ensure removed elements stay in correct relative positions\n        // during leaving transitions\n        const canMove = !removeOnly;\n        {\n            checkDuplicateKeys(newCh);\n        }\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (isUndef(oldStartVnode)) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n            }\n            else if (isUndef(oldEndVnode)) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n                canMove &&\n                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                canMove &&\n                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (isUndef(oldKeyToIdx))\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                idxInOld = isDef(newStartVnode.key)\n                    ? oldKeyToIdx[newStartVnode.key]\n                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n                if (isUndef(idxInOld)) {\n                    // New element\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n                }\n                else {\n                    vnodeToMove = oldCh[idxInOld];\n                    if (sameVnode(vnodeToMove, newStartVnode)) {\n                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n                        oldCh[idxInOld] = undefined;\n                        canMove &&\n                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n                    }\n                    else {\n                        // same key but different element. treat as new element\n                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n        if (oldStartIdx > oldEndIdx) {\n            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        else if (newStartIdx > newEndIdx) {\n            removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function checkDuplicateKeys(children) {\n        const seenKeys = {};\n        for (let i = 0; i < children.length; i++) {\n            const vnode = children[i];\n            const key = vnode.key;\n            if (isDef(key)) {\n                if (seenKeys[key]) {\n                    warn$2(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);\n                }\n                else {\n                    seenKeys[key] = true;\n                }\n            }\n        }\n    }\n    function findIdxInOld(node, oldCh, start, end) {\n        for (let i = start; i < end; i++) {\n            const c = oldCh[i];\n            if (isDef(c) && sameVnode(node, c))\n                return i;\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n        if (oldVnode === vnode) {\n            return;\n        }\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\n            // clone reused vnode\n            vnode = ownerArray[index] = cloneVNode(vnode);\n        }\n        const elm = (vnode.elm = oldVnode.elm);\n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\n            if (isDef(vnode.asyncFactory.resolved)) {\n                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n            }\n            else {\n                vnode.isAsyncPlaceholder = true;\n            }\n            return;\n        }\n        // reuse element for static trees.\n        // note we only do this if the vnode is cloned -\n        // if the new node is not cloned it means the render functions have been\n        // reset by the hot-reload-api and we need to do a proper re-render.\n        if (isTrue(vnode.isStatic) &&\n            isTrue(oldVnode.isStatic) &&\n            vnode.key === oldVnode.key &&\n            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n            vnode.componentInstance = oldVnode.componentInstance;\n            return;\n        }\n        let i;\n        const data = vnode.data;\n        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {\n            i(oldVnode, vnode);\n        }\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if (isDef(data) && isPatchable(vnode)) {\n            for (i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            if (isDef((i = data.hook)) && isDef((i = i.update)))\n                i(oldVnode, vnode);\n        }\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n            }\n            else if (isDef(ch)) {\n                {\n                    checkDuplicateKeys(ch);\n                }\n                if (isDef(oldVnode.text))\n                    nodeOps.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                nodeOps.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            nodeOps.setTextContent(elm, vnode.text);\n        }\n        if (isDef(data)) {\n            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))\n                i(oldVnode, vnode);\n        }\n    }\n    function invokeInsertHook(vnode, queue, initial) {\n        // delay insert hooks for component root nodes, invoke them after the\n        // element is really inserted\n        if (isTrue(initial) && isDef(vnode.parent)) {\n            vnode.parent.data.pendingInsert = queue;\n        }\n        else {\n            for (let i = 0; i < queue.length; ++i) {\n                queue[i].data.hook.insert(queue[i]);\n            }\n        }\n    }\n    let hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    const isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n        let i;\n        const { tag, data, children } = vnode;\n        inVPre = inVPre || (data && data.pre);\n        vnode.elm = elm;\n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n            vnode.isAsyncPlaceholder = true;\n            return true;\n        }\n        // assert node match\n        {\n            if (!assertNodeMatch(elm, vnode, inVPre)) {\n                return false;\n            }\n        }\n        if (isDef(data)) {\n            if (isDef((i = data.hook)) && isDef((i = i.init)))\n                i(vnode, true /* hydrating */);\n            if (isDef((i = vnode.componentInstance))) {\n                // child component. it should have hydrated its own tree.\n                initComponent(vnode, insertedVnodeQueue);\n                return true;\n            }\n        }\n        if (isDef(tag)) {\n            if (isDef(children)) {\n                // empty element, allow client to pick up and populate children\n                if (!elm.hasChildNodes()) {\n                    createChildren(vnode, children, insertedVnodeQueue);\n                }\n                else {\n                    // v-html and domProps: innerHTML\n                    if (isDef((i = data)) &&\n                        isDef((i = i.domProps)) &&\n                        isDef((i = i.innerHTML))) {\n                        if (i !== elm.innerHTML) {\n                            /* istanbul ignore if */\n                            if (typeof console !== 'undefined' &&\n                                !hydrationBailed) {\n                                hydrationBailed = true;\n                                console.warn('Parent: ', elm);\n                                console.warn('server innerHTML: ', i);\n                                console.warn('client innerHTML: ', elm.innerHTML);\n                            }\n                            return false;\n                        }\n                    }\n                    else {\n                        // iterate and compare children lists\n                        let childrenMatch = true;\n                        let childNode = elm.firstChild;\n                        for (let i = 0; i < children.length; i++) {\n                            if (!childNode ||\n                                !hydrate(childNode, children[i], insertedVnodeQueue, inVPre)) {\n                                childrenMatch = false;\n                                break;\n                            }\n                            childNode = childNode.nextSibling;\n                        }\n                        // if childNode is not null, it means the actual childNodes list is\n                        // longer than the virtual children list.\n                        if (!childrenMatch || childNode) {\n                            /* istanbul ignore if */\n                            if (typeof console !== 'undefined' &&\n                                !hydrationBailed) {\n                                hydrationBailed = true;\n                                console.warn('Parent: ', elm);\n                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                            }\n                            return false;\n                        }\n                    }\n                }\n            }\n            if (isDef(data)) {\n                let fullInvoke = false;\n                for (const key in data) {\n                    if (!isRenderedModule(key)) {\n                        fullInvoke = true;\n                        invokeCreateHooks(vnode, insertedVnodeQueue);\n                        break;\n                    }\n                }\n                if (!fullInvoke && data['class']) {\n                    // ensure collecting deps for deep class bindings for future updates\n                    traverse(data['class']);\n                }\n            }\n        }\n        else if (elm.data !== vnode.text) {\n            elm.data = vnode.text;\n        }\n        return true;\n    }\n    function assertNodeMatch(node, vnode, inVPre) {\n        if (isDef(vnode.tag)) {\n            return (vnode.tag.indexOf('vue-component') === 0 ||\n                (!isUnknownElement(vnode, inVPre) &&\n                    vnode.tag.toLowerCase() ===\n                        (node.tagName && node.tagName.toLowerCase())));\n        }\n        else {\n            return node.nodeType === (vnode.isComment ? 8 : 3);\n        }\n    }\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n        if (isUndef(vnode)) {\n            if (isDef(oldVnode))\n                invokeDestroyHook(oldVnode);\n            return;\n        }\n        let isInitialPatch = false;\n        const insertedVnodeQueue = [];\n        if (isUndef(oldVnode)) {\n            // empty mount (likely as component), create new root element\n            isInitialPatch = true;\n            createElm(vnode, insertedVnodeQueue);\n        }\n        else {\n            const isRealElement = isDef(oldVnode.nodeType);\n            if (!isRealElement && sameVnode(oldVnode, vnode)) {\n                // patch existing root node\n                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n            }\n            else {\n                if (isRealElement) {\n                    // mounting to a real element\n                    // check if this is server-rendered content and if we can perform\n                    // a successful hydration.\n                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n                        oldVnode.removeAttribute(SSR_ATTR);\n                        hydrating = true;\n                    }\n                    if (isTrue(hydrating)) {\n                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                            invokeInsertHook(vnode, insertedVnodeQueue, true);\n                            return oldVnode;\n                        }\n                        else {\n                            warn$2('The client-side rendered virtual DOM tree is not matching ' +\n                                'server-rendered content. This is likely caused by incorrect ' +\n                                'HTML markup, for example nesting block-level elements inside ' +\n                                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                                'full client-side render.');\n                        }\n                    }\n                    // either not server-rendered, or hydration failed.\n                    // create an empty node and replace it\n                    oldVnode = emptyNodeAt(oldVnode);\n                }\n                // replacing existing element\n                const oldElm = oldVnode.elm;\n                const parentElm = nodeOps.parentNode(oldElm);\n                // create new node\n                createElm(vnode, insertedVnodeQueue, \n                // extremely rare edge case: do not insert if old element is in a\n                // leaving transition. Only happens when combining transition +\n                // keep-alive + HOCs. (#4590)\n                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\n                // update parent placeholder node element, recursively\n                if (isDef(vnode.parent)) {\n                    let ancestor = vnode.parent;\n                    const patchable = isPatchable(vnode);\n                    while (ancestor) {\n                        for (let i = 0; i < cbs.destroy.length; ++i) {\n                            cbs.destroy[i](ancestor);\n                        }\n                        ancestor.elm = vnode.elm;\n                        if (patchable) {\n                            for (let i = 0; i < cbs.create.length; ++i) {\n                                cbs.create[i](emptyNode, ancestor);\n                            }\n                            // #6513\n                            // invoke insert hooks that may have been merged by create hooks.\n                            // e.g. for directives that uses the \"inserted\" hook.\n                            const insert = ancestor.data.hook.insert;\n                            if (insert.merged) {\n                                // start at index 1 to avoid re-invoking component mounted hook\n                                for (let i = 1; i < insert.fns.length; i++) {\n                                    insert.fns[i]();\n                                }\n                            }\n                        }\n                        else {\n                            registerRef(ancestor);\n                        }\n                        ancestor = ancestor.parent;\n                    }\n                }\n                // destroy old node\n                if (isDef(parentElm)) {\n                    removeVnodes([oldVnode], 0, 0);\n                }\n                else if (isDef(oldVnode.tag)) {\n                    invokeDestroyHook(oldVnode);\n                }\n            }\n        }\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n        return vnode.elm;\n    };\n}\n\nvar directives$1 = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n        // @ts-expect-error emptyNode is not VNodeWithData\n        updateDirectives(vnode, emptyNode);\n    }\n};\nfunction updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n        _update(oldVnode, vnode);\n    }\n}\nfunction _update(oldVnode, vnode) {\n    const isCreate = oldVnode === emptyNode;\n    const isDestroy = vnode === emptyNode;\n    const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\n    const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\n    const dirsWithInsert = [];\n    const dirsWithPostpatch = [];\n    let key, oldDir, dir;\n    for (key in newDirs) {\n        oldDir = oldDirs[key];\n        dir = newDirs[key];\n        if (!oldDir) {\n            // new directive, bind\n            callHook(dir, 'bind', vnode, oldVnode);\n            if (dir.def && dir.def.inserted) {\n                dirsWithInsert.push(dir);\n            }\n        }\n        else {\n            // existing directive, update\n            dir.oldValue = oldDir.value;\n            dir.oldArg = oldDir.arg;\n            callHook(dir, 'update', vnode, oldVnode);\n            if (dir.def && dir.def.componentUpdated) {\n                dirsWithPostpatch.push(dir);\n            }\n        }\n    }\n    if (dirsWithInsert.length) {\n        const callInsert = () => {\n            for (let i = 0; i < dirsWithInsert.length; i++) {\n                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n            }\n        };\n        if (isCreate) {\n            mergeVNodeHook(vnode, 'insert', callInsert);\n        }\n        else {\n            callInsert();\n        }\n    }\n    if (dirsWithPostpatch.length) {\n        mergeVNodeHook(vnode, 'postpatch', () => {\n            for (let i = 0; i < dirsWithPostpatch.length; i++) {\n                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n            }\n        });\n    }\n    if (!isCreate) {\n        for (key in oldDirs) {\n            if (!newDirs[key]) {\n                // no longer present, unbind\n                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n            }\n        }\n    }\n}\nconst emptyModifiers = Object.create(null);\nfunction normalizeDirectives(dirs, vm) {\n    const res = Object.create(null);\n    if (!dirs) {\n        // $flow-disable-line\n        return res;\n    }\n    let i, dir;\n    for (i = 0; i < dirs.length; i++) {\n        dir = dirs[i];\n        if (!dir.modifiers) {\n            // $flow-disable-line\n            dir.modifiers = emptyModifiers;\n        }\n        res[getRawDirName(dir)] = dir;\n        if (vm._setupState && vm._setupState.__sfc) {\n            const setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\n            if (typeof setupDef === 'function') {\n                dir.def = {\n                    bind: setupDef,\n                    update: setupDef,\n                };\n            }\n            else {\n                dir.def = setupDef;\n            }\n        }\n        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res;\n}\nfunction getRawDirName(dir) {\n    return (dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`);\n}\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\n    const fn = dir.def && dir.def[hook];\n    if (fn) {\n        try {\n            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n        }\n        catch (e) {\n            handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`);\n        }\n    }\n}\n\nvar baseModules = [ref, directives$1];\n\nfunction updateAttrs(oldVnode, vnode) {\n    const opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n        return;\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n        return;\n    }\n    let key, cur, old;\n    const elm = vnode.elm;\n    const oldAttrs = oldVnode.data.attrs || {};\n    let attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\n        attrs = vnode.data.attrs = extend({}, attrs);\n    }\n    for (key in attrs) {\n        cur = attrs[key];\n        old = oldAttrs[key];\n        if (old !== cur) {\n            setAttr(elm, key, cur, vnode.data.pre);\n        }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n        setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n        if (isUndef(attrs[key])) {\n            if (isXlink(key)) {\n                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n            }\n            else if (!isEnumeratedAttr(key)) {\n                elm.removeAttribute(key);\n            }\n        }\n    }\n}\nfunction setAttr(el, key, value, isInPre) {\n    if (isInPre || el.tagName.indexOf('-') > -1) {\n        baseSetAttr(el, key, value);\n    }\n    else if (isBooleanAttr(key)) {\n        // set attribute for blank value\n        // e.g. <option disabled>Select one</option>\n        if (isFalsyAttrValue(value)) {\n            el.removeAttribute(key);\n        }\n        else {\n            // technically allowfullscreen is a boolean attribute for <iframe>,\n            // but Flash expects a value of \"true\" when used on <embed> tag\n            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n            el.setAttribute(key, value);\n        }\n    }\n    else if (isEnumeratedAttr(key)) {\n        el.setAttribute(key, convertEnumeratedValue(key, value));\n    }\n    else if (isXlink(key)) {\n        if (isFalsyAttrValue(value)) {\n            el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        }\n        else {\n            el.setAttributeNS(xlinkNS, key, value);\n        }\n    }\n    else {\n        baseSetAttr(el, key, value);\n    }\n}\nfunction baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n    }\n    else {\n        // #7138: IE10 & 11 fires input event when setting placeholder on\n        // <textarea>... block the first input event and remove the blocker\n        // immediately.\n        /* istanbul ignore if */\n        if (isIE &&\n            !isIE9 &&\n            el.tagName === 'TEXTAREA' &&\n            key === 'placeholder' &&\n            value !== '' &&\n            !el.__ieph) {\n            const blocker = e => {\n                e.stopImmediatePropagation();\n                el.removeEventListener('input', blocker);\n            };\n            el.addEventListener('input', blocker);\n            // $flow-disable-line\n            el.__ieph = true; /* IE placeholder patched */\n        }\n        el.setAttribute(key, value);\n    }\n}\nvar attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n};\n\nfunction updateClass(oldVnode, vnode) {\n    const el = vnode.elm;\n    const data = vnode.data;\n    const oldData = oldVnode.data;\n    if (isUndef(data.staticClass) &&\n        isUndef(data.class) &&\n        (isUndef(oldData) ||\n            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {\n        return;\n    }\n    let cls = genClassForVnode(vnode);\n    // handle transition classes\n    const transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n        cls = concat(cls, stringifyClass(transitionClass));\n    }\n    // set the class\n    if (cls !== el._prevClass) {\n        el.setAttribute('class', cls);\n        el._prevClass = cls;\n    }\n}\nvar klass$1 = {\n    create: updateClass,\n    update: updateClass\n};\n\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/;\nfunction parseFilters(exp) {\n    let inSingle = false;\n    let inDouble = false;\n    let inTemplateString = false;\n    let inRegex = false;\n    let curly = 0;\n    let square = 0;\n    let paren = 0;\n    let lastFilterIndex = 0;\n    let c, prev, i, expression, filters;\n    for (i = 0; i < exp.length; i++) {\n        prev = c;\n        c = exp.charCodeAt(i);\n        if (inSingle) {\n            if (c === 0x27 && prev !== 0x5c)\n                inSingle = false;\n        }\n        else if (inDouble) {\n            if (c === 0x22 && prev !== 0x5c)\n                inDouble = false;\n        }\n        else if (inTemplateString) {\n            if (c === 0x60 && prev !== 0x5c)\n                inTemplateString = false;\n        }\n        else if (inRegex) {\n            if (c === 0x2f && prev !== 0x5c)\n                inRegex = false;\n        }\n        else if (c === 0x7c && // pipe\n            exp.charCodeAt(i + 1) !== 0x7c &&\n            exp.charCodeAt(i - 1) !== 0x7c &&\n            !curly &&\n            !square &&\n            !paren) {\n            if (expression === undefined) {\n                // first filter, end of expression\n                lastFilterIndex = i + 1;\n                expression = exp.slice(0, i).trim();\n            }\n            else {\n                pushFilter();\n            }\n        }\n        else {\n            switch (c) {\n                case 0x22:\n                    inDouble = true;\n                    break; // \"\n                case 0x27:\n                    inSingle = true;\n                    break; // '\n                case 0x60:\n                    inTemplateString = true;\n                    break; // `\n                case 0x28:\n                    paren++;\n                    break; // (\n                case 0x29:\n                    paren--;\n                    break; // )\n                case 0x5b:\n                    square++;\n                    break; // [\n                case 0x5d:\n                    square--;\n                    break; // ]\n                case 0x7b:\n                    curly++;\n                    break; // {\n                case 0x7d:\n                    curly--;\n                    break; // }\n            }\n            if (c === 0x2f) {\n                // /\n                let j = i - 1;\n                let p;\n                // find first non-whitespace prev char\n                for (; j >= 0; j--) {\n                    p = exp.charAt(j);\n                    if (p !== ' ')\n                        break;\n                }\n                if (!p || !validDivisionCharRE.test(p)) {\n                    inRegex = true;\n                }\n            }\n        }\n    }\n    if (expression === undefined) {\n        expression = exp.slice(0, i).trim();\n    }\n    else if (lastFilterIndex !== 0) {\n        pushFilter();\n    }\n    function pushFilter() {\n        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n        lastFilterIndex = i + 1;\n    }\n    if (filters) {\n        for (i = 0; i < filters.length; i++) {\n            expression = wrapFilter(expression, filters[i]);\n        }\n    }\n    return expression;\n}\nfunction wrapFilter(exp, filter) {\n    const i = filter.indexOf('(');\n    if (i < 0) {\n        // _f: resolveFilter\n        return `_f(\"${filter}\")(${exp})`;\n    }\n    else {\n        const name = filter.slice(0, i);\n        const args = filter.slice(i + 1);\n        return `_f(\"${name}\")(${exp}${args !== ')' ? ',' + args : args}`;\n    }\n}\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn(msg, range) {\n    console.error(`[Vue compiler]: ${msg}`);\n}\n/* eslint-enable no-unused-vars */\nfunction pluckModuleFunction(modules, key) {\n    return modules ? modules.map(m => m[key]).filter(_ => _) : [];\n}\nfunction addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name, value, dynamic }, range));\n    el.plain = false;\n}\nfunction addAttr(el, name, value, range, dynamic) {\n    const attrs = dynamic\n        ? el.dynamicAttrs || (el.dynamicAttrs = [])\n        : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({ name, value, dynamic }, range));\n    el.plain = false;\n}\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name, value }, range));\n}\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n        name,\n        rawName,\n        value,\n        arg,\n        isDynamicArg,\n        modifiers\n    }, range));\n    el.plain = false;\n}\nfunction prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? `_p(${name},\"${symbol}\")` : symbol + name; // mark the event as captured\n}\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (warn && modifiers.prevent && modifiers.passive) {\n        warn(\"passive and prevent can't be used together. \" +\n            \"Passive handler can't prevent default event.\", range);\n    }\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n        if (dynamic) {\n            name = `(${name})==='click'?'contextmenu':(${name})`;\n        }\n        else if (name === 'click') {\n            name = 'contextmenu';\n            delete modifiers.right;\n        }\n    }\n    else if (modifiers.middle) {\n        if (dynamic) {\n            name = `(${name})==='click'?'mouseup':(${name})`;\n        }\n        else if (name === 'click') {\n            name = 'mouseup';\n        }\n    }\n    // check capture modifier\n    if (modifiers.capture) {\n        delete modifiers.capture;\n        name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n        delete modifiers.once;\n        name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n        delete modifiers.passive;\n        name = prependModifierMarker('&', name, dynamic);\n    }\n    let events;\n    if (modifiers.native) {\n        delete modifiers.native;\n        events = el.nativeEvents || (el.nativeEvents = {});\n    }\n    else {\n        events = el.events || (el.events = {});\n    }\n    const newHandler = rangeSetItem({ value: value.trim(), dynamic }, range);\n    if (modifiers !== emptyObject) {\n        newHandler.modifiers = modifiers;\n    }\n    const handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n        important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    }\n    else if (handlers) {\n        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    }\n    else {\n        events[name] = newHandler;\n    }\n    el.plain = false;\n}\nfunction getRawBindingAttr(el, name) {\n    return (el.rawAttrsMap[':' + name] ||\n        el.rawAttrsMap['v-bind:' + name] ||\n        el.rawAttrsMap[name]);\n}\nfunction getBindingAttr(el, name, getStatic) {\n    const dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n        return parseFilters(dynamicValue);\n    }\n    else if (getStatic !== false) {\n        const staticValue = getAndRemoveAttr(el, name);\n        if (staticValue != null) {\n            return JSON.stringify(staticValue);\n        }\n    }\n}\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr(el, name, removeFromMap) {\n    let val;\n    if ((val = el.attrsMap[name]) != null) {\n        const list = el.attrsList;\n        for (let i = 0, l = list.length; i < l; i++) {\n            if (list[i].name === name) {\n                list.splice(i, 1);\n                break;\n            }\n        }\n    }\n    if (removeFromMap) {\n        delete el.attrsMap[name];\n    }\n    return val;\n}\nfunction getAndRemoveAttrByRegex(el, name) {\n    const list = el.attrsList;\n    for (let i = 0, l = list.length; i < l; i++) {\n        const attr = list[i];\n        if (name.test(attr.name)) {\n            list.splice(i, 1);\n            return attr;\n        }\n    }\n}\nfunction rangeSetItem(item, range) {\n    if (range) {\n        if (range.start != null) {\n            item.start = range.start;\n        }\n        if (range.end != null) {\n            item.end = range.end;\n        }\n    }\n    return item;\n}\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel(el, value, modifiers) {\n    const { number, trim } = modifiers || {};\n    const baseValueExpression = '$$v';\n    let valueExpression = baseValueExpression;\n    if (trim) {\n        valueExpression =\n            `(typeof ${baseValueExpression} === 'string'` +\n                `? ${baseValueExpression}.trim()` +\n                `: ${baseValueExpression})`;\n    }\n    if (number) {\n        valueExpression = `_n(${valueExpression})`;\n    }\n    const assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n        value: `(${value})`,\n        expression: JSON.stringify(value),\n        callback: `function (${baseValueExpression}) {${assignment}}`\n    };\n}\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode(value, assignment) {\n    const res = parseModel(value);\n    if (res.key === null) {\n        return `${value}=${assignment}`;\n    }\n    else {\n        return `$set(${res.exp}, ${res.key}, ${assignment})`;\n    }\n}\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\nlet len, str, chr, index, expressionPos, expressionEndPos;\nfunction parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n        index = val.lastIndexOf('.');\n        if (index > -1) {\n            return {\n                exp: val.slice(0, index),\n                key: '\"' + val.slice(index + 1) + '\"'\n            };\n        }\n        else {\n            return {\n                exp: val,\n                key: null\n            };\n        }\n    }\n    str = val;\n    index = expressionPos = expressionEndPos = 0;\n    while (!eof()) {\n        chr = next();\n        /* istanbul ignore if */\n        if (isStringStart(chr)) {\n            parseString(chr);\n        }\n        else if (chr === 0x5b) {\n            parseBracket(chr);\n        }\n    }\n    return {\n        exp: val.slice(0, expressionPos),\n        key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n}\nfunction next() {\n    return str.charCodeAt(++index);\n}\nfunction eof() {\n    return index >= len;\n}\nfunction isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n}\nfunction parseBracket(chr) {\n    let inBracket = 1;\n    expressionPos = index;\n    while (!eof()) {\n        chr = next();\n        if (isStringStart(chr)) {\n            parseString(chr);\n            continue;\n        }\n        if (chr === 0x5b)\n            inBracket++;\n        if (chr === 0x5d)\n            inBracket--;\n        if (inBracket === 0) {\n            expressionEndPos = index;\n            break;\n        }\n    }\n}\nfunction parseString(chr) {\n    const stringQuote = chr;\n    while (!eof()) {\n        chr = next();\n        if (chr === stringQuote) {\n            break;\n        }\n    }\n}\n\nlet warn$1;\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nconst RANGE_TOKEN = '__r';\nconst CHECKBOX_RADIO_TOKEN = '__c';\nfunction model$1(el, dir, _warn) {\n    warn$1 = _warn;\n    const value = dir.value;\n    const modifiers = dir.modifiers;\n    const tag = el.tag;\n    const type = el.attrsMap.type;\n    {\n        // inputs with type=\"file\" are read only and setting the input's\n        // value will throw an error.\n        if (tag === 'input' && type === 'file') {\n            warn$1(`<${el.tag} v-model=\"${value}\" type=\"file\">:\\n` +\n                `File inputs are read only. Use a v-on:change listener instead.`, el.rawAttrsMap['v-model']);\n        }\n    }\n    if (el.component) {\n        genComponentModel(el, value, modifiers);\n        // component v-model doesn't need extra runtime\n        return false;\n    }\n    else if (tag === 'select') {\n        genSelect(el, value, modifiers);\n    }\n    else if (tag === 'input' && type === 'checkbox') {\n        genCheckboxModel(el, value, modifiers);\n    }\n    else if (tag === 'input' && type === 'radio') {\n        genRadioModel(el, value, modifiers);\n    }\n    else if (tag === 'input' || tag === 'textarea') {\n        genDefaultModel(el, value, modifiers);\n    }\n    else if (!config.isReservedTag(tag)) {\n        genComponentModel(el, value, modifiers);\n        // component v-model doesn't need extra runtime\n        return false;\n    }\n    else {\n        warn$1(`<${el.tag} v-model=\"${value}\">: ` +\n            `v-model is not supported on this element type. ` +\n            \"If you are working with contenteditable, it's recommended to \" +\n            'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    }\n    // ensure runtime directive metadata\n    return true;\n}\nfunction genCheckboxModel(el, value, modifiers) {\n    const number = modifiers && modifiers.number;\n    const valueBinding = getBindingAttr(el, 'value') || 'null';\n    const trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    const falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', `Array.isArray(${value})` +\n        `?_i(${value},${valueBinding})>-1` +\n        (trueValueBinding === 'true'\n            ? `:(${value})`\n            : `:_q(${value},${trueValueBinding})`));\n    addHandler(el, 'change', `var $$a=${value},` +\n        '$$el=$event.target,' +\n        `$$c=$$el.checked?(${trueValueBinding}):(${falseValueBinding});` +\n        'if(Array.isArray($$a)){' +\n        `var $$v=${number ? '_n(' + valueBinding + ')' : valueBinding},` +\n        '$$i=_i($$a,$$v);' +\n        `if($$el.checked){$$i<0&&(${genAssignmentCode(value, '$$a.concat([$$v])')})}` +\n        `else{$$i>-1&&(${genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')})}` +\n        `}else{${genAssignmentCode(value, '$$c')}}`, null, true);\n}\nfunction genRadioModel(el, value, modifiers) {\n    const number = modifiers && modifiers.number;\n    let valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? `_n(${valueBinding})` : valueBinding;\n    addProp(el, 'checked', `_q(${value},${valueBinding})`);\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\nfunction genSelect(el, value, modifiers) {\n    const number = modifiers && modifiers.number;\n    const selectedVal = `Array.prototype.filter` +\n        `.call($event.target.options,function(o){return o.selected})` +\n        `.map(function(o){var val = \"_value\" in o ? o._value : o.value;` +\n        `return ${number ? '_n(val)' : 'val'}})`;\n    const assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    let code = `var $$selectedVal = ${selectedVal};`;\n    code = `${code} ${genAssignmentCode(value, assignment)}`;\n    addHandler(el, 'change', code, null, true);\n}\nfunction genDefaultModel(el, value, modifiers) {\n    const type = el.attrsMap.type;\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n        const value = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n        const typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n        if (value && !typeBinding) {\n            const binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n            warn$1(`${binding}=\"${value}\" conflicts with v-model on the same element ` +\n                'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n        }\n    }\n    const { lazy, number, trim } = modifiers || {};\n    const needCompositionGuard = !lazy && type !== 'range';\n    const event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    let valueExpression = '$event.target.value';\n    if (trim) {\n        valueExpression = `$event.target.value.trim()`;\n    }\n    if (number) {\n        valueExpression = `_n(${valueExpression})`;\n    }\n    let code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n        code = `if($event.target.composing)return;${code}`;\n    }\n    addProp(el, 'value', `(${value})`);\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n        addHandler(el, 'blur', '$forceUpdate()');\n    }\n}\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n        // IE input[type=range] only supports `change` event\n        const event = isIE ? 'change' : 'input';\n        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n        delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n        delete on[CHECKBOX_RADIO_TOKEN];\n    }\n}\nlet target;\nfunction createOnceHandler(event, handler, capture) {\n    const _target = target; // save current target element in closure\n    return function onceHandler() {\n        const res = handler.apply(null, arguments);\n        if (res !== null) {\n            remove(event, onceHandler, capture, _target);\n        }\n    };\n}\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nconst useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\nfunction add(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n        const attachedTimestamp = currentFlushTimestamp;\n        const original = handler;\n        //@ts-expect-error\n        handler = original._wrapper = function (e) {\n            if (\n            // no bubbling, should always fire.\n            // this is just a safety net in case event.timeStamp is unreliable in\n            // certain weird environments...\n            e.target === e.currentTarget ||\n                // event is fired after handler attachment\n                e.timeStamp >= attachedTimestamp ||\n                // bail for environments that have buggy event.timeStamp implementations\n                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n                // #9681 QtWebEngine event.timeStamp is negative value\n                e.timeStamp <= 0 ||\n                // #9448 bail if event is fired in another document in a multi-page\n                // electron/nw.js app, since event.timeStamp will be using a different\n                // starting reference\n                e.target.ownerDocument !== document) {\n                return original.apply(this, arguments);\n            }\n        };\n    }\n    target.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);\n}\nfunction remove(name, handler, capture, _target) {\n    (_target || target).removeEventListener(name, \n    //@ts-expect-error\n    handler._wrapper || handler, capture);\n}\nfunction updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n        return;\n    }\n    const on = vnode.data.on || {};\n    const oldOn = oldVnode.data.on || {};\n    // vnode is empty when removing all listeners,\n    // and use old vnode dom element\n    target = vnode.elm || oldVnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\n    target = undefined;\n}\nvar events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners,\n    // @ts-expect-error emptyNode has actually data\n    destroy: (vnode) => updateDOMListeners(vnode, emptyNode)\n};\n\nlet svgContainer;\nfunction updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n        return;\n    }\n    let key, cur;\n    const elm = vnode.elm;\n    const oldProps = oldVnode.data.domProps || {};\n    let props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\n        props = vnode.data.domProps = extend({}, props);\n    }\n    for (key in oldProps) {\n        if (!(key in props)) {\n            elm[key] = '';\n        }\n    }\n    for (key in props) {\n        cur = props[key];\n        // ignore children if the node has textContent or innerHTML,\n        // as these will throw away existing DOM nodes and cause removal errors\n        // on subsequent patches (#3360)\n        if (key === 'textContent' || key === 'innerHTML') {\n            if (vnode.children)\n                vnode.children.length = 0;\n            if (cur === oldProps[key])\n                continue;\n            // #6601 work around Chrome version <= 55 bug where single textNode\n            // replaced by innerHTML/textContent retains its parentNode property\n            if (elm.childNodes.length === 1) {\n                elm.removeChild(elm.childNodes[0]);\n            }\n        }\n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\n            // store value as _value as well since\n            // non-string values will be stringified\n            elm._value = cur;\n            // avoid resetting cursor position when value is the same\n            const strCur = isUndef(cur) ? '' : String(cur);\n            if (shouldUpdateValue(elm, strCur)) {\n                elm.value = strCur;\n            }\n        }\n        else if (key === 'innerHTML' &&\n            isSVG(elm.tagName) &&\n            isUndef(elm.innerHTML)) {\n            // IE doesn't support innerHTML for SVG elements\n            svgContainer = svgContainer || document.createElement('div');\n            svgContainer.innerHTML = `<svg>${cur}</svg>`;\n            const svg = svgContainer.firstChild;\n            while (elm.firstChild) {\n                elm.removeChild(elm.firstChild);\n            }\n            while (svg.firstChild) {\n                elm.appendChild(svg.firstChild);\n            }\n        }\n        else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecessary `checked` update.\n        cur !== oldProps[key]) {\n            // some property updates can throw\n            // e.g. `value` on <progress> w/ non-finite value\n            try {\n                elm[key] = cur;\n            }\n            catch (e) { }\n        }\n    }\n}\nfunction shouldUpdateValue(elm, checkVal) {\n    return (\n    //@ts-expect-error\n    !elm.composing &&\n        (elm.tagName === 'OPTION' ||\n            isNotInFocusAndDirty(elm, checkVal) ||\n            isDirtyWithModifiers(elm, checkVal)));\n}\nfunction isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    let notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try {\n        notInFocus = document.activeElement !== elm;\n    }\n    catch (e) { }\n    return notInFocus && elm.value !== checkVal;\n}\nfunction isDirtyWithModifiers(elm, newVal) {\n    const value = elm.value;\n    const modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n        if (modifiers.number) {\n            return toNumber(value) !== toNumber(newVal);\n        }\n        if (modifiers.trim) {\n            return value.trim() !== newVal.trim();\n        }\n    }\n    return value !== newVal;\n}\nvar domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n};\n\nconst parseStyleText = cached(function (cssText) {\n    const res = {};\n    const listDelimiter = /;(?![^(]*\\))/g;\n    const propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n        if (item) {\n            const tmp = item.split(propertyDelimiter);\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return res;\n});\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n    const style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n        return toObject(bindingStyle);\n    }\n    if (typeof bindingStyle === 'string') {\n        return parseStyleText(bindingStyle);\n    }\n    return bindingStyle;\n}\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n    const res = {};\n    let styleData;\n    if (checkChild) {\n        let childNode = vnode;\n        while (childNode.componentInstance) {\n            childNode = childNode.componentInstance._vnode;\n            if (childNode &&\n                childNode.data &&\n                (styleData = normalizeStyleData(childNode.data))) {\n                extend(res, styleData);\n            }\n        }\n    }\n    if ((styleData = normalizeStyleData(vnode.data))) {\n        extend(res, styleData);\n    }\n    let parentNode = vnode;\n    // @ts-expect-error parentNode.parent not VNodeWithData\n    while ((parentNode = parentNode.parent)) {\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n            extend(res, styleData);\n        }\n    }\n    return res;\n}\n\nconst cssVarRE = /^--/;\nconst importantRE = /\\s*!important$/;\nconst setProp = (el, name, val) => {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n        el.style.setProperty(name, val);\n    }\n    else if (importantRE.test(val)) {\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    }\n    else {\n        const normalizedName = normalize(name);\n        if (Array.isArray(val)) {\n            // Support values array created by autoprefixer, e.g.\n            // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n            // Set them one by one, and the browser will only set those it can recognize\n            for (let i = 0, len = val.length; i < len; i++) {\n                el.style[normalizedName] = val[i];\n            }\n        }\n        else {\n            el.style[normalizedName] = val;\n        }\n    }\n};\nconst vendorNames = ['Webkit', 'Moz', 'ms'];\nlet emptyStyle;\nconst normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in emptyStyle) {\n        return prop;\n    }\n    const capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (let i = 0; i < vendorNames.length; i++) {\n        const name = vendorNames[i] + capName;\n        if (name in emptyStyle) {\n            return name;\n        }\n    }\n});\nfunction updateStyle(oldVnode, vnode) {\n    const data = vnode.data;\n    const oldData = oldVnode.data;\n    if (isUndef(data.staticStyle) &&\n        isUndef(data.style) &&\n        isUndef(oldData.staticStyle) &&\n        isUndef(oldData.style)) {\n        return;\n    }\n    let cur, name;\n    const el = vnode.elm;\n    const oldStaticStyle = oldData.staticStyle;\n    const oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    const oldStyle = oldStaticStyle || oldStyleBinding;\n    const style = normalizeStyleBinding(vnode.data.style) || {};\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    const newStyle = getStyle(vnode, true);\n    for (name in oldStyle) {\n        if (isUndef(newStyle[name])) {\n            setProp(el, name, '');\n        }\n    }\n    for (name in newStyle) {\n        cur = newStyle[name];\n        if (cur !== oldStyle[name]) {\n            // ie9 setting to null has no effect, must use empty string\n            setProp(el, name, cur == null ? '' : cur);\n        }\n    }\n}\nvar style$1 = {\n    create: updateStyle,\n    update: updateStyle\n};\n\nconst whitespaceRE$1 = /\\s+/;\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n        return;\n    }\n    /* istanbul ignore else */\n    if (el.classList) {\n        if (cls.indexOf(' ') > -1) {\n            cls.split(whitespaceRE$1).forEach(c => el.classList.add(c));\n        }\n        else {\n            el.classList.add(cls);\n        }\n    }\n    else {\n        const cur = ` ${el.getAttribute('class') || ''} `;\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\n            el.setAttribute('class', (cur + cls).trim());\n        }\n    }\n}\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n        return;\n    }\n    /* istanbul ignore else */\n    if (el.classList) {\n        if (cls.indexOf(' ') > -1) {\n            cls.split(whitespaceRE$1).forEach(c => el.classList.remove(c));\n        }\n        else {\n            el.classList.remove(cls);\n        }\n        if (!el.classList.length) {\n            el.removeAttribute('class');\n        }\n    }\n    else {\n        let cur = ` ${el.getAttribute('class') || ''} `;\n        const tar = ' ' + cls + ' ';\n        while (cur.indexOf(tar) >= 0) {\n            cur = cur.replace(tar, ' ');\n        }\n        cur = cur.trim();\n        if (cur) {\n            el.setAttribute('class', cur);\n        }\n        else {\n            el.removeAttribute('class');\n        }\n    }\n}\n\nfunction resolveTransition(def) {\n    if (!def) {\n        return;\n    }\n    /* istanbul ignore else */\n    if (typeof def === 'object') {\n        const res = {};\n        if (def.css !== false) {\n            extend(res, autoCssTransition(def.name || 'v'));\n        }\n        extend(res, def);\n        return res;\n    }\n    else if (typeof def === 'string') {\n        return autoCssTransition(def);\n    }\n}\nconst autoCssTransition = cached(name => {\n    return {\n        enterClass: `${name}-enter`,\n        enterToClass: `${name}-enter-to`,\n        enterActiveClass: `${name}-enter-active`,\n        leaveClass: `${name}-leave`,\n        leaveToClass: `${name}-leave-to`,\n        leaveActiveClass: `${name}-leave-active`\n    };\n});\nconst hasTransition = inBrowser && !isIE9;\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n// Transition property/event sniffing\nlet transitionProp = 'transition';\nlet transitionEndEvent = 'transitionend';\nlet animationProp = 'animation';\nlet animationEndEvent = 'animationend';\nif (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n        window.onwebkittransitionend !== undefined) {\n        transitionProp = 'WebkitTransition';\n        transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n        window.onwebkitanimationend !== undefined) {\n        animationProp = 'WebkitAnimation';\n        animationEndEvent = 'webkitAnimationEnd';\n    }\n}\n// binding to window is necessary to make hot reload work in IE in strict mode\nconst raf = inBrowser\n    ? window.requestAnimationFrame\n        ? window.requestAnimationFrame.bind(window)\n        : setTimeout\n    : /* istanbul ignore next */ /* istanbul ignore next */ fn => fn();\nfunction nextFrame(fn) {\n    raf(() => {\n        // @ts-expect-error\n        raf(fn);\n    });\n}\nfunction addTransitionClass(el, cls) {\n    const transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n        transitionClasses.push(cls);\n        addClass(el, cls);\n    }\n}\nfunction removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n        remove$2(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n}\nfunction whenTransitionEnds(el, expectedType, cb) {\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n    if (!type)\n        return cb();\n    const event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    let ended = 0;\n    const end = () => {\n        el.removeEventListener(event, onEnd);\n        cb();\n    };\n    const onEnd = e => {\n        if (e.target === el) {\n            if (++ended >= propCount) {\n                end();\n            }\n        }\n    };\n    setTimeout(() => {\n        if (ended < propCount) {\n            end();\n        }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n}\nconst transformRE = /\\b(transform|all)(,|$)/;\nfunction getTransitionInfo(el, expectedType) {\n    const styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    const transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    const transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    const animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    const animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\n    let type;\n    let timeout = 0;\n    let propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n        if (transitionTimeout > 0) {\n            type = TRANSITION;\n            timeout = transitionTimeout;\n            propCount = transitionDurations.length;\n        }\n    }\n    else if (expectedType === ANIMATION) {\n        if (animationTimeout > 0) {\n            type = ANIMATION;\n            timeout = animationTimeout;\n            propCount = animationDurations.length;\n        }\n    }\n    else {\n        timeout = Math.max(transitionTimeout, animationTimeout);\n        type =\n            timeout > 0\n                ? transitionTimeout > animationTimeout\n                    ? TRANSITION\n                    : ANIMATION\n                : null;\n        propCount = type\n            ? type === TRANSITION\n                ? transitionDurations.length\n                : animationDurations.length\n            : 0;\n    }\n    const hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n        type,\n        timeout,\n        propCount,\n        hasTransform\n    };\n}\nfunction getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n        delays = delays.concat(delays);\n    }\n    return Math.max.apply(null, durations.map((d, i) => {\n        return toMs(d) + toMs(delays[i]);\n    }));\n}\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n\nfunction enter(vnode, toggleDisplay) {\n    const el = vnode.elm;\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n        el._leaveCb.cancelled = true;\n        el._leaveCb();\n    }\n    const data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n        return;\n    }\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n        return;\n    }\n    const { css, type, enterClass, enterToClass, enterActiveClass, appearClass, appearToClass, appearActiveClass, beforeEnter, enter, afterEnter, enterCancelled, beforeAppear, appear, afterAppear, appearCancelled, duration } = data;\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    let context = activeInstance;\n    let transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n        context = transitionNode.context;\n        transitionNode = transitionNode.parent;\n    }\n    const isAppear = !context._isMounted || !vnode.isRootInsert;\n    if (isAppear && !appear && appear !== '') {\n        return;\n    }\n    const startClass = isAppear && appearClass ? appearClass : enterClass;\n    const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    const toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    const enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;\n    const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    const enterCancelledHook = isAppear\n        ? appearCancelled || enterCancelled\n        : enterCancelled;\n    const explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n    if (explicitEnterDuration != null) {\n        checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n    const expectsCSS = css !== false && !isIE9;\n    const userWantsControl = getHookArgumentsLength(enterHook);\n    const cb = (el._enterCb = once(() => {\n        if (expectsCSS) {\n            removeTransitionClass(el, toClass);\n            removeTransitionClass(el, activeClass);\n        }\n        // @ts-expect-error\n        if (cb.cancelled) {\n            if (expectsCSS) {\n                removeTransitionClass(el, startClass);\n            }\n            enterCancelledHook && enterCancelledHook(el);\n        }\n        else {\n            afterEnterHook && afterEnterHook(el);\n        }\n        el._enterCb = null;\n    }));\n    if (!vnode.data.show) {\n        // remove pending leave element on enter by injecting an insert hook\n        mergeVNodeHook(vnode, 'insert', () => {\n            const parent = el.parentNode;\n            const pendingNode = parent && parent._pending && parent._pending[vnode.key];\n            if (pendingNode &&\n                pendingNode.tag === vnode.tag &&\n                pendingNode.elm._leaveCb) {\n                pendingNode.elm._leaveCb();\n            }\n            enterHook && enterHook(el, cb);\n        });\n    }\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n        addTransitionClass(el, startClass);\n        addTransitionClass(el, activeClass);\n        nextFrame(() => {\n            removeTransitionClass(el, startClass);\n            // @ts-expect-error\n            if (!cb.cancelled) {\n                addTransitionClass(el, toClass);\n                if (!userWantsControl) {\n                    if (isValidDuration(explicitEnterDuration)) {\n                        setTimeout(cb, explicitEnterDuration);\n                    }\n                    else {\n                        whenTransitionEnds(el, type, cb);\n                    }\n                }\n            }\n        });\n    }\n    if (vnode.data.show) {\n        toggleDisplay && toggleDisplay();\n        enterHook && enterHook(el, cb);\n    }\n    if (!expectsCSS && !userWantsControl) {\n        cb();\n    }\n}\nfunction leave(vnode, rm) {\n    const el = vnode.elm;\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n        el._enterCb.cancelled = true;\n        el._enterCb();\n    }\n    const data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n        return rm();\n    }\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n        return;\n    }\n    const { css, type, leaveClass, leaveToClass, leaveActiveClass, beforeLeave, leave, afterLeave, leaveCancelled, delayLeave, duration } = data;\n    const expectsCSS = css !== false && !isIE9;\n    const userWantsControl = getHookArgumentsLength(leave);\n    const explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n    if (isDef(explicitLeaveDuration)) {\n        checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n    const cb = (el._leaveCb = once(() => {\n        if (el.parentNode && el.parentNode._pending) {\n            el.parentNode._pending[vnode.key] = null;\n        }\n        if (expectsCSS) {\n            removeTransitionClass(el, leaveToClass);\n            removeTransitionClass(el, leaveActiveClass);\n        }\n        // @ts-expect-error\n        if (cb.cancelled) {\n            if (expectsCSS) {\n                removeTransitionClass(el, leaveClass);\n            }\n            leaveCancelled && leaveCancelled(el);\n        }\n        else {\n            rm();\n            afterLeave && afterLeave(el);\n        }\n        el._leaveCb = null;\n    }));\n    if (delayLeave) {\n        delayLeave(performLeave);\n    }\n    else {\n        performLeave();\n    }\n    function performLeave() {\n        // the delayed leave may have already been cancelled\n        // @ts-expect-error\n        if (cb.cancelled) {\n            return;\n        }\n        // record leaving element\n        if (!vnode.data.show && el.parentNode) {\n            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =\n                vnode;\n        }\n        beforeLeave && beforeLeave(el);\n        if (expectsCSS) {\n            addTransitionClass(el, leaveClass);\n            addTransitionClass(el, leaveActiveClass);\n            nextFrame(() => {\n                removeTransitionClass(el, leaveClass);\n                // @ts-expect-error\n                if (!cb.cancelled) {\n                    addTransitionClass(el, leaveToClass);\n                    if (!userWantsControl) {\n                        if (isValidDuration(explicitLeaveDuration)) {\n                            setTimeout(cb, explicitLeaveDuration);\n                        }\n                        else {\n                            whenTransitionEnds(el, type, cb);\n                        }\n                    }\n                }\n            });\n        }\n        leave && leave(el, cb);\n        if (!expectsCSS && !userWantsControl) {\n            cb();\n        }\n    }\n}\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n        warn$2(`<transition> explicit ${name} duration is not a valid number - ` +\n            `got ${JSON.stringify(val)}.`, vnode.context);\n    }\n    else if (isNaN(val)) {\n        warn$2(`<transition> explicit ${name} duration is NaN - ` +\n            'the duration expression might be incorrect.', vnode.context);\n    }\n}\nfunction isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n}\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n        return false;\n    }\n    // @ts-expect-error\n    const invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n        // invoker\n        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    }\n    else {\n        // @ts-expect-error\n        return (fn._length || fn.length) > 1;\n    }\n}\nfunction _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n        enter(vnode);\n    }\n}\nvar transition = inBrowser\n    ? {\n        create: _enter,\n        activate: _enter,\n        remove(vnode, rm) {\n            /* istanbul ignore else */\n            if (vnode.data.show !== true) {\n                // @ts-expect-error\n                leave(vnode, rm);\n            }\n            else {\n                rm();\n            }\n        }\n    }\n    : {};\n\nvar platformModules = [attrs, klass$1, events, domProps, style$1, transition];\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nconst modules$1 = platformModules.concat(baseModules);\nconst patch = createPatchFunction({ nodeOps, modules: modules$1 });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n/* istanbul ignore if */\nif (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', () => {\n        const el = document.activeElement;\n        // @ts-expect-error\n        if (el && el.vmodel) {\n            trigger(el, 'input');\n        }\n    });\n}\nconst directive = {\n    inserted(el, binding, vnode, oldVnode) {\n        if (vnode.tag === 'select') {\n            // #6903\n            if (oldVnode.elm && !oldVnode.elm._vOptions) {\n                mergeVNodeHook(vnode, 'postpatch', () => {\n                    directive.componentUpdated(el, binding, vnode);\n                });\n            }\n            else {\n                setSelected(el, binding, vnode.context);\n            }\n            el._vOptions = [].map.call(el.options, getValue);\n        }\n        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n            el._vModifiers = binding.modifiers;\n            if (!binding.modifiers.lazy) {\n                el.addEventListener('compositionstart', onCompositionStart);\n                el.addEventListener('compositionend', onCompositionEnd);\n                // Safari < 10.2 & UIWebView doesn't fire compositionend when\n                // switching focus before confirming composition choice\n                // this also fixes the issue where some browsers e.g. iOS Chrome\n                // fires \"change\" instead of \"input\" on autocomplete.\n                el.addEventListener('change', onCompositionEnd);\n                /* istanbul ignore if */\n                if (isIE9) {\n                    el.vmodel = true;\n                }\n            }\n        }\n    },\n    componentUpdated(el, binding, vnode) {\n        if (vnode.tag === 'select') {\n            setSelected(el, binding, vnode.context);\n            // in case the options rendered by v-for have changed,\n            // it's possible that the value is out-of-sync with the rendered options.\n            // detect such cases and filter out values that no longer has a matching\n            // option in the DOM.\n            const prevOptions = el._vOptions;\n            const curOptions = (el._vOptions = [].map.call(el.options, getValue));\n            if (curOptions.some((o, i) => !looseEqual(o, prevOptions[i]))) {\n                // trigger change event if\n                // no matching option found for at least one value\n                const needReset = el.multiple\n                    ? binding.value.some(v => hasNoMatchingOption(v, curOptions))\n                    : binding.value !== binding.oldValue &&\n                        hasNoMatchingOption(binding.value, curOptions);\n                if (needReset) {\n                    trigger(el, 'change');\n                }\n            }\n        }\n    }\n};\nfunction setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n        setTimeout(() => {\n            actuallySetSelected(el, binding, vm);\n        }, 0);\n    }\n}\nfunction actuallySetSelected(el, binding, vm) {\n    const value = binding.value;\n    const isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n        warn$2(`<select multiple v-model=\"${binding.expression}\"> ` +\n                `expects an Array value for its binding, but got ${Object.prototype.toString\n                    .call(value)\n                    .slice(8, -1)}`, vm);\n        return;\n    }\n    let selected, option;\n    for (let i = 0, l = el.options.length; i < l; i++) {\n        option = el.options[i];\n        if (isMultiple) {\n            selected = looseIndexOf(value, getValue(option)) > -1;\n            if (option.selected !== selected) {\n                option.selected = selected;\n            }\n        }\n        else {\n            if (looseEqual(getValue(option), value)) {\n                if (el.selectedIndex !== i) {\n                    el.selectedIndex = i;\n                }\n                return;\n            }\n        }\n    }\n    if (!isMultiple) {\n        el.selectedIndex = -1;\n    }\n}\nfunction hasNoMatchingOption(value, options) {\n    return options.every(o => !looseEqual(o, value));\n}\nfunction getValue(option) {\n    return '_value' in option ? option._value : option.value;\n}\nfunction onCompositionStart(e) {\n    e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing)\n        return;\n    e.target.composing = false;\n    trigger(e.target, 'input');\n}\nfunction trigger(el, type) {\n    const e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n}\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n    // @ts-expect-error\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n        ? locateNode(vnode.componentInstance._vnode)\n        : vnode;\n}\nvar show = {\n    bind(el, { value }, vnode) {\n        vnode = locateNode(vnode);\n        const transition = vnode.data && vnode.data.transition;\n        const originalDisplay = (el.__vOriginalDisplay =\n            el.style.display === 'none' ? '' : el.style.display);\n        if (value && transition) {\n            vnode.data.show = true;\n            enter(vnode, () => {\n                el.style.display = originalDisplay;\n            });\n        }\n        else {\n            el.style.display = value ? originalDisplay : 'none';\n        }\n    },\n    update(el, { value, oldValue }, vnode) {\n        /* istanbul ignore if */\n        if (!value === !oldValue)\n            return;\n        vnode = locateNode(vnode);\n        const transition = vnode.data && vnode.data.transition;\n        if (transition) {\n            vnode.data.show = true;\n            if (value) {\n                enter(vnode, () => {\n                    el.style.display = el.__vOriginalDisplay;\n                });\n            }\n            else {\n                leave(vnode, () => {\n                    el.style.display = 'none';\n                });\n            }\n        }\n        else {\n            el.style.display = value ? el.__vOriginalDisplay : 'none';\n        }\n    },\n    unbind(el, binding, vnode, oldVnode, isDestroy) {\n        if (!isDestroy) {\n            el.style.display = el.__vOriginalDisplay;\n        }\n    }\n};\n\nvar platformDirectives = {\n    model: directive,\n    show\n};\n\n// Provides transition support for a single element/component.\nconst transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n};\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n    const compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n        return getRealChild(getFirstComponentChild(compOptions.children));\n    }\n    else {\n        return vnode;\n    }\n}\nfunction extractTransitionData(comp) {\n    const data = {};\n    const options = comp.$options;\n    // props\n    for (const key in options.propsData) {\n        data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    const listeners = options._parentListeners;\n    for (const key in listeners) {\n        data[camelize(key)] = listeners[key];\n    }\n    return data;\n}\nfunction placeholder(h, rawChild) {\n    // @ts-expect-error\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n        return h('keep-alive', {\n            props: rawChild.componentOptions.propsData\n        });\n    }\n}\nfunction hasParentTransition(vnode) {\n    while ((vnode = vnode.parent)) {\n        if (vnode.data.transition) {\n            return true;\n        }\n    }\n}\nfunction isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n}\nconst isNotTextNode = (c) => c.tag || isAsyncPlaceholder(c);\nconst isVShowDirective = d => d.name === 'show';\nvar Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render(h) {\n        let children = this.$slots.default;\n        if (!children) {\n            return;\n        }\n        // filter out text nodes (possible whitespaces)\n        children = children.filter(isNotTextNode);\n        /* istanbul ignore if */\n        if (!children.length) {\n            return;\n        }\n        // warn multiple elements\n        if (children.length > 1) {\n            warn$2('<transition> can only be used on a single element. Use ' +\n                '<transition-group> for lists.', this.$parent);\n        }\n        const mode = this.mode;\n        // warn invalid mode\n        if (mode && mode !== 'in-out' && mode !== 'out-in') {\n            warn$2('invalid <transition> mode: ' + mode, this.$parent);\n        }\n        const rawChild = children[0];\n        // if this is a component root node and the component's\n        // parent container node also has transition, skip.\n        if (hasParentTransition(this.$vnode)) {\n            return rawChild;\n        }\n        // apply transition data to child\n        // use getRealChild() to ignore abstract components e.g. keep-alive\n        const child = getRealChild(rawChild);\n        /* istanbul ignore if */\n        if (!child) {\n            return rawChild;\n        }\n        if (this._leaving) {\n            return placeholder(h, rawChild);\n        }\n        // ensure a key that is unique to the vnode type and to this transition\n        // component instance. This key will be used to remove pending leaving nodes\n        // during entering.\n        const id = `__transition-${this._uid}-`;\n        child.key =\n            child.key == null\n                ? child.isComment\n                    ? id + 'comment'\n                    : id + child.tag\n                : isPrimitive(child.key)\n                    ? String(child.key).indexOf(id) === 0\n                        ? child.key\n                        : id + child.key\n                    : child.key;\n        const data = ((child.data || (child.data = {})).transition =\n            extractTransitionData(this));\n        const oldRawChild = this._vnode;\n        const oldChild = getRealChild(oldRawChild);\n        // mark v-show\n        // so that the transition module can hand over the control to the directive\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n            child.data.show = true;\n        }\n        if (oldChild &&\n            oldChild.data &&\n            !isSameChild(child, oldChild) &&\n            !isAsyncPlaceholder(oldChild) &&\n            // #6687 component root is a comment node\n            !(oldChild.componentInstance &&\n                oldChild.componentInstance._vnode.isComment)) {\n            // replace old child transition data with fresh one\n            // important for dynamic transitions!\n            const oldData = (oldChild.data.transition = extend({}, data));\n            // handle transition mode\n            if (mode === 'out-in') {\n                // return placeholder node and queue update when leave finishes\n                this._leaving = true;\n                mergeVNodeHook(oldData, 'afterLeave', () => {\n                    this._leaving = false;\n                    this.$forceUpdate();\n                });\n                return placeholder(h, rawChild);\n            }\n            else if (mode === 'in-out') {\n                if (isAsyncPlaceholder(child)) {\n                    return oldRawChild;\n                }\n                let delayedLeave;\n                const performLeave = () => {\n                    delayedLeave();\n                };\n                mergeVNodeHook(data, 'afterEnter', performLeave);\n                mergeVNodeHook(data, 'enterCancelled', performLeave);\n                mergeVNodeHook(oldData, 'delayLeave', leave => {\n                    delayedLeave = leave;\n                });\n            }\n        }\n        return rawChild;\n    }\n};\n\n// Provides transition support for list items.\nconst props = extend({\n    tag: String,\n    moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n    props,\n    beforeMount() {\n        const update = this._update;\n        this._update = (vnode, hydrating) => {\n            const restoreActiveInstance = setActiveInstance(this);\n            // force removing pass\n            this.__patch__(this._vnode, this.kept, false, // hydrating\n            true // removeOnly (!important, avoids unnecessary moves)\n            );\n            this._vnode = this.kept;\n            restoreActiveInstance();\n            update.call(this, vnode, hydrating);\n        };\n    },\n    render(h) {\n        const tag = this.tag || this.$vnode.data.tag || 'span';\n        const map = Object.create(null);\n        const prevChildren = (this.prevChildren = this.children);\n        const rawChildren = this.$slots.default || [];\n        const children = (this.children = []);\n        const transitionData = extractTransitionData(this);\n        for (let i = 0; i < rawChildren.length; i++) {\n            const c = rawChildren[i];\n            if (c.tag) {\n                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n                    children.push(c);\n                    map[c.key] = c;\n                    (c.data || (c.data = {})).transition = transitionData;\n                }\n                else {\n                    const opts = c.componentOptions;\n                    const name = opts\n                        ? getComponentName(opts.Ctor.options) || opts.tag || ''\n                        : c.tag;\n                    warn$2(`<transition-group> children must be keyed: <${name}>`);\n                }\n            }\n        }\n        if (prevChildren) {\n            const kept = [];\n            const removed = [];\n            for (let i = 0; i < prevChildren.length; i++) {\n                const c = prevChildren[i];\n                c.data.transition = transitionData;\n                // @ts-expect-error .getBoundingClientRect is not typed in Node\n                c.data.pos = c.elm.getBoundingClientRect();\n                if (map[c.key]) {\n                    kept.push(c);\n                }\n                else {\n                    removed.push(c);\n                }\n            }\n            this.kept = h(tag, null, kept);\n            this.removed = removed;\n        }\n        return h(tag, null, children);\n    },\n    updated() {\n        const children = this.prevChildren;\n        const moveClass = this.moveClass || (this.name || 'v') + '-move';\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n            return;\n        }\n        // we divide the work into three loops to avoid mixing DOM reads and writes\n        // in each iteration - which helps prevent layout thrashing.\n        children.forEach(callPendingCbs);\n        children.forEach(recordPosition);\n        children.forEach(applyTranslation);\n        // force reflow to put everything in position\n        // assign to this to avoid being removed in tree-shaking\n        // $flow-disable-line\n        this._reflow = document.body.offsetHeight;\n        children.forEach((c) => {\n            if (c.data.moved) {\n                const el = c.elm;\n                const s = el.style;\n                addTransitionClass(el, moveClass);\n                s.transform = s.WebkitTransform = s.transitionDuration = '';\n                el.addEventListener(transitionEndEvent, (el._moveCb = function cb(e) {\n                    if (e && e.target !== el) {\n                        return;\n                    }\n                    if (!e || /transform$/.test(e.propertyName)) {\n                        el.removeEventListener(transitionEndEvent, cb);\n                        el._moveCb = null;\n                        removeTransitionClass(el, moveClass);\n                    }\n                }));\n            }\n        });\n    },\n    methods: {\n        hasMove(el, moveClass) {\n            /* istanbul ignore if */\n            if (!hasTransition) {\n                return false;\n            }\n            /* istanbul ignore if */\n            if (this._hasMove) {\n                return this._hasMove;\n            }\n            // Detect whether an element with the move class applied has\n            // CSS transitions. Since the element may be inside an entering\n            // transition at this very moment, we make a clone of it and remove\n            // all other transition classes applied to ensure only the move class\n            // is applied.\n            const clone = el.cloneNode();\n            if (el._transitionClasses) {\n                el._transitionClasses.forEach((cls) => {\n                    removeClass(clone, cls);\n                });\n            }\n            addClass(clone, moveClass);\n            clone.style.display = 'none';\n            this.$el.appendChild(clone);\n            const info = getTransitionInfo(clone);\n            this.$el.removeChild(clone);\n            return (this._hasMove = info.hasTransform);\n        }\n    }\n};\nfunction callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n        c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n        c.elm._enterCb();\n    }\n}\nfunction recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n}\nfunction applyTranslation(c) {\n    const oldPos = c.data.pos;\n    const newPos = c.data.newPos;\n    const dx = oldPos.left - newPos.left;\n    const dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n        c.data.moved = true;\n        const s = c.elm.style;\n        s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;\n        s.transitionDuration = '0s';\n    }\n}\n\nvar platformComponents = {\n    Transition,\n    TransitionGroup\n};\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n// public mount method\nVue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n};\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n    setTimeout(() => {\n        if (config.devtools) {\n            if (devtools) {\n                devtools.emit('init', Vue);\n            }\n            else {\n                // @ts-expect-error\n                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' +\n                    'https://github.com/vuejs/vue-devtools');\n            }\n        }\n        if (config.productionTip !== false &&\n            typeof console !== 'undefined') {\n            // @ts-expect-error\n            console[console.info ? 'info' : 'log'](`You are running Vue in development mode.\\n` +\n                `Make sure to turn on production mode when deploying for production.\\n` +\n                `See more tips at https://vuejs.org/guide/deployment.html`);\n        }\n    }, 0);\n}\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nconst regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\nconst buildRegex = cached(delimiters => {\n    const open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    const close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\nfunction parseText(text, delimiters) {\n    //@ts-expect-error\n    const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n        return;\n    }\n    const tokens = [];\n    const rawTokens = [];\n    let lastIndex = (tagRE.lastIndex = 0);\n    let match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n        index = match.index;\n        // push text token\n        if (index > lastIndex) {\n            rawTokens.push((tokenValue = text.slice(lastIndex, index)));\n            tokens.push(JSON.stringify(tokenValue));\n        }\n        // tag token\n        const exp = parseFilters(match[1].trim());\n        tokens.push(`_s(${exp})`);\n        rawTokens.push({ '@binding': exp });\n        lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n        rawTokens.push((tokenValue = text.slice(lastIndex)));\n        tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n        expression: tokens.join('+'),\n        tokens: rawTokens\n    };\n}\n\nfunction transformNode$1(el, options) {\n    const warn = options.warn || baseWarn;\n    const staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n        const res = parseText(staticClass, options.delimiters);\n        if (res) {\n            warn(`class=\"${staticClass}\": ` +\n                'Interpolation inside attributes has been removed. ' +\n                'Use v-bind or the colon shorthand instead. For example, ' +\n                'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n        }\n    }\n    if (staticClass) {\n        el.staticClass = JSON.stringify(staticClass.replace(/\\s+/g, ' ').trim());\n    }\n    const classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n        el.classBinding = classBinding;\n    }\n}\nfunction genData$2(el) {\n    let data = '';\n    if (el.staticClass) {\n        data += `staticClass:${el.staticClass},`;\n    }\n    if (el.classBinding) {\n        data += `class:${el.classBinding},`;\n    }\n    return data;\n}\nvar klass = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode$1,\n    genData: genData$2\n};\n\nfunction transformNode(el, options) {\n    const warn = options.warn || baseWarn;\n    const staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n        /* istanbul ignore if */\n        {\n            const res = parseText(staticStyle, options.delimiters);\n            if (res) {\n                warn(`style=\"${staticStyle}\": ` +\n                    'Interpolation inside attributes has been removed. ' +\n                    'Use v-bind or the colon shorthand instead. For example, ' +\n                    'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n            }\n        }\n        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n    const styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n        el.styleBinding = styleBinding;\n    }\n}\nfunction genData$1(el) {\n    let data = '';\n    if (el.staticStyle) {\n        data += `staticStyle:${el.staticStyle},`;\n    }\n    if (el.styleBinding) {\n        data += `style:(${el.styleBinding}),`;\n    }\n    return data;\n}\nvar style = {\n    staticKeys: ['staticStyle'],\n    transformNode,\n    genData: genData$1\n};\n\nlet decoder;\nvar he = {\n    decode(html) {\n        decoder = decoder || document.createElement('div');\n        decoder.innerHTML = html;\n        return decoder.textContent;\n    }\n};\n\nconst isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr');\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nconst canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nconst isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track');\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n// Regular Expressions for parsing tags and attributes\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z${unicodeRegExp.source}]*`;\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^<${qnameCapture}`);\nconst startTagClose = /^\\s*(\\/?)>/;\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);\nconst doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being passed as HTML comment when inlined in page\nconst comment = /^<!\\--/;\nconst conditionalComment = /^<!\\[/;\n// Special Elements (can contain anything)\nconst isPlainTextElement = makeMap('script,style,textarea', true);\nconst reCache = {};\nconst decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n};\nconst encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nconst encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n// #5992\nconst isIgnoreNewlineTag = makeMap('pre,textarea', true);\nconst shouldIgnoreFirstNewline = (tag, html) => tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\nfunction decodeAttr(value, shouldDecodeNewlines) {\n    const re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, match => decodingMap[match]);\n}\nfunction parseHTML(html, options) {\n    const stack = [];\n    const expectHTML = options.expectHTML;\n    const isUnaryTag = options.isUnaryTag || no;\n    const canBeLeftOpenTag = options.canBeLeftOpenTag || no;\n    let index = 0;\n    let last, lastTag;\n    while (html) {\n        last = html;\n        // Make sure we're not in a plaintext content element like script/style\n        if (!lastTag || !isPlainTextElement(lastTag)) {\n            let textEnd = html.indexOf('<');\n            if (textEnd === 0) {\n                // Comment:\n                if (comment.test(html)) {\n                    const commentEnd = html.indexOf('-->');\n                    if (commentEnd >= 0) {\n                        if (options.shouldKeepComment && options.comment) {\n                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n                        }\n                        advance(commentEnd + 3);\n                        continue;\n                    }\n                }\n                // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n                if (conditionalComment.test(html)) {\n                    const conditionalEnd = html.indexOf(']>');\n                    if (conditionalEnd >= 0) {\n                        advance(conditionalEnd + 2);\n                        continue;\n                    }\n                }\n                // Doctype:\n                const doctypeMatch = html.match(doctype);\n                if (doctypeMatch) {\n                    advance(doctypeMatch[0].length);\n                    continue;\n                }\n                // End tag:\n                const endTagMatch = html.match(endTag);\n                if (endTagMatch) {\n                    const curIndex = index;\n                    advance(endTagMatch[0].length);\n                    parseEndTag(endTagMatch[1], curIndex, index);\n                    continue;\n                }\n                // Start tag:\n                const startTagMatch = parseStartTag();\n                if (startTagMatch) {\n                    handleStartTag(startTagMatch);\n                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n                        advance(1);\n                    }\n                    continue;\n                }\n            }\n            let text, rest, next;\n            if (textEnd >= 0) {\n                rest = html.slice(textEnd);\n                while (!endTag.test(rest) &&\n                    !startTagOpen.test(rest) &&\n                    !comment.test(rest) &&\n                    !conditionalComment.test(rest)) {\n                    // < in plain text, be forgiving and treat it as text\n                    next = rest.indexOf('<', 1);\n                    if (next < 0)\n                        break;\n                    textEnd += next;\n                    rest = html.slice(textEnd);\n                }\n                text = html.substring(0, textEnd);\n            }\n            if (textEnd < 0) {\n                text = html;\n            }\n            if (text) {\n                advance(text.length);\n            }\n            if (options.chars && text) {\n                options.chars(text, index - text.length, index);\n            }\n        }\n        else {\n            let endTagLength = 0;\n            const stackedTag = lastTag.toLowerCase();\n            const reStackedTag = reCache[stackedTag] ||\n                (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n            const rest = html.replace(reStackedTag, function (all, text, endTag) {\n                endTagLength = endTag.length;\n                if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n                    text = text\n                        .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n                        .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n                }\n                if (shouldIgnoreFirstNewline(stackedTag, text)) {\n                    text = text.slice(1);\n                }\n                if (options.chars) {\n                    options.chars(text);\n                }\n                return '';\n            });\n            index += html.length - rest.length;\n            html = rest;\n            parseEndTag(stackedTag, index - endTagLength, index);\n        }\n        if (html === last) {\n            options.chars && options.chars(html);\n            if (!stack.length && options.warn) {\n                options.warn(`Mal-formatted tag at end of template: \"${html}\"`, {\n                    start: index + html.length\n                });\n            }\n            break;\n        }\n    }\n    // Clean up any remaining tags\n    parseEndTag();\n    function advance(n) {\n        index += n;\n        html = html.substring(n);\n    }\n    function parseStartTag() {\n        const start = html.match(startTagOpen);\n        if (start) {\n            const match = {\n                tagName: start[1],\n                attrs: [],\n                start: index\n            };\n            advance(start[0].length);\n            let end, attr;\n            while (!(end = html.match(startTagClose)) &&\n                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n                attr.start = index;\n                advance(attr[0].length);\n                attr.end = index;\n                match.attrs.push(attr);\n            }\n            if (end) {\n                match.unarySlash = end[1];\n                advance(end[0].length);\n                match.end = index;\n                return match;\n            }\n        }\n    }\n    function handleStartTag(match) {\n        const tagName = match.tagName;\n        const unarySlash = match.unarySlash;\n        if (expectHTML) {\n            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n                parseEndTag(lastTag);\n            }\n            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n                parseEndTag(tagName);\n            }\n        }\n        const unary = isUnaryTag(tagName) || !!unarySlash;\n        const l = match.attrs.length;\n        const attrs = new Array(l);\n        for (let i = 0; i < l; i++) {\n            const args = match.attrs[i];\n            const value = args[3] || args[4] || args[5] || '';\n            const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n                ? options.shouldDecodeNewlinesForHref\n                : options.shouldDecodeNewlines;\n            attrs[i] = {\n                name: args[1],\n                value: decodeAttr(value, shouldDecodeNewlines)\n            };\n            if (options.outputSourceRange) {\n                attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n                attrs[i].end = args.end;\n            }\n        }\n        if (!unary) {\n            stack.push({\n                tag: tagName,\n                lowerCasedTag: tagName.toLowerCase(),\n                attrs: attrs,\n                start: match.start,\n                end: match.end\n            });\n            lastTag = tagName;\n        }\n        if (options.start) {\n            options.start(tagName, attrs, unary, match.start, match.end);\n        }\n    }\n    function parseEndTag(tagName, start, end) {\n        let pos, lowerCasedTagName;\n        if (start == null)\n            start = index;\n        if (end == null)\n            end = index;\n        // Find the closest opened tag of the same type\n        if (tagName) {\n            lowerCasedTagName = tagName.toLowerCase();\n            for (pos = stack.length - 1; pos >= 0; pos--) {\n                if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n                    break;\n                }\n            }\n        }\n        else {\n            // If no tag name is provided, clean shop\n            pos = 0;\n        }\n        if (pos >= 0) {\n            // Close all the open elements, up the stack\n            for (let i = stack.length - 1; i >= pos; i--) {\n                if ((i > pos || !tagName) && options.warn) {\n                    options.warn(`tag <${stack[i].tag}> has no matching end tag.`, {\n                        start: stack[i].start,\n                        end: stack[i].end\n                    });\n                }\n                if (options.end) {\n                    options.end(stack[i].tag, start, end);\n                }\n            }\n            // Remove the open elements from the stack\n            stack.length = pos;\n            lastTag = pos && stack[pos - 1].tag;\n        }\n        else if (lowerCasedTagName === 'br') {\n            if (options.start) {\n                options.start(tagName, [], true, start, end);\n            }\n        }\n        else if (lowerCasedTagName === 'p') {\n            if (options.start) {\n                options.start(tagName, [], false, start, end);\n            }\n            if (options.end) {\n                options.end(tagName, start, end);\n            }\n        }\n    }\n}\n\nconst onRE = /^@|^v-on:/;\nconst dirRE = /^v-|^@|^:|^#/;\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nconst stripParensRE = /^\\(|\\)$/g;\nconst dynamicArgRE = /^\\[.*\\]$/;\nconst argRE = /:(.*)$/;\nconst bindRE = /^:|^\\.|^v-bind:/;\nconst modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\nconst slotRE = /^v-slot(:|$)|^#/;\nconst lineBreakRE = /[\\r\\n]/;\nconst whitespaceRE = /[ \\f\\t\\r\\n]+/g;\nconst invalidAttributeRE = /[\\s\"'<>\\/=]/;\nconst decodeHTMLCached = cached(he.decode);\nconst emptySlotScopeToken = `_empty_`;\n// configurable state\nlet warn;\nlet delimiters;\nlet transforms;\nlet preTransforms;\nlet postTransforms;\nlet platformIsPreTag;\nlet platformMustUseProp;\nlet platformGetTagNamespace;\nlet maybeComponent;\nfunction createASTElement(tag, attrs, parent) {\n    return {\n        type: 1,\n        tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        rawAttrsMap: {},\n        parent,\n        children: []\n    };\n}\n/**\n * Convert HTML string to AST.\n */\nfunction parse(template, options) {\n    warn = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    const isReservedTag = options.isReservedTag || no;\n    maybeComponent = (el) => !!(el.component ||\n        el.attrsMap[':is'] ||\n        el.attrsMap['v-bind:is'] ||\n        !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    const stack = [];\n    const preserveWhitespace = options.preserveWhitespace !== false;\n    const whitespaceOption = options.whitespace;\n    let root;\n    let currentParent;\n    let inVPre = false;\n    let inPre = false;\n    let warned = false;\n    function warnOnce(msg, range) {\n        if (!warned) {\n            warned = true;\n            warn(msg, range);\n        }\n    }\n    function closeElement(element) {\n        trimEndingWhitespace(element);\n        if (!inVPre && !element.processed) {\n            element = processElement(element, options);\n        }\n        // tree management\n        if (!stack.length && element !== root) {\n            // allow root elements with v-if, v-else-if and v-else\n            if (root.if && (element.elseif || element.else)) {\n                {\n                    checkRootConstraints(element);\n                }\n                addIfCondition(root, {\n                    exp: element.elseif,\n                    block: element\n                });\n            }\n            else {\n                warnOnce(`Component template should contain exactly one root element. ` +\n                    `If you are using v-if on multiple elements, ` +\n                    `use v-else-if to chain them instead.`, { start: element.start });\n            }\n        }\n        if (currentParent && !element.forbidden) {\n            if (element.elseif || element.else) {\n                processIfConditions(element, currentParent);\n            }\n            else {\n                if (element.slotScope) {\n                    // scoped slot\n                    // keep it in the children list so that v-else(-if) conditions can\n                    // find it as the prev node.\n                    const name = element.slotTarget || '\"default\"';\n                    (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n                }\n                currentParent.children.push(element);\n                element.parent = currentParent;\n            }\n        }\n        // final children cleanup\n        // filter out scoped slots\n        element.children = element.children.filter(c => !c.slotScope);\n        // remove trailing whitespace node again\n        trimEndingWhitespace(element);\n        // check pre state\n        if (element.pre) {\n            inVPre = false;\n        }\n        if (platformIsPreTag(element.tag)) {\n            inPre = false;\n        }\n        // apply post-transforms\n        for (let i = 0; i < postTransforms.length; i++) {\n            postTransforms[i](element, options);\n        }\n    }\n    function trimEndingWhitespace(el) {\n        // remove trailing whitespace node\n        if (!inPre) {\n            let lastNode;\n            while ((lastNode = el.children[el.children.length - 1]) &&\n                lastNode.type === 3 &&\n                lastNode.text === ' ') {\n                el.children.pop();\n            }\n        }\n    }\n    function checkRootConstraints(el) {\n        if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(`Cannot use <${el.tag}> as component root element because it may ` +\n                'contain multiple nodes.', { start: el.start });\n        }\n        if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce('Cannot use v-for on stateful component root element because ' +\n                'it renders multiple elements.', el.rawAttrsMap['v-for']);\n        }\n    }\n    parseHTML(template, {\n        warn,\n        expectHTML: options.expectHTML,\n        isUnaryTag: options.isUnaryTag,\n        canBeLeftOpenTag: options.canBeLeftOpenTag,\n        shouldDecodeNewlines: options.shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n        shouldKeepComment: options.comments,\n        outputSourceRange: options.outputSourceRange,\n        start(tag, attrs, unary, start, end) {\n            // check namespace.\n            // inherit parent ns if there is one\n            const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n            // handle IE svg bug\n            /* istanbul ignore if */\n            if (isIE && ns === 'svg') {\n                attrs = guardIESVGBug(attrs);\n            }\n            let element = createASTElement(tag, attrs, currentParent);\n            if (ns) {\n                element.ns = ns;\n            }\n            {\n                if (options.outputSourceRange) {\n                    element.start = start;\n                    element.end = end;\n                    element.rawAttrsMap = element.attrsList.reduce((cumulated, attr) => {\n                        cumulated[attr.name] = attr;\n                        return cumulated;\n                    }, {});\n                }\n                attrs.forEach(attr => {\n                    if (invalidAttributeRE.test(attr.name)) {\n                        warn(`Invalid dynamic argument expression: attribute names cannot contain ` +\n                            `spaces, quotes, <, >, / or =.`, options.outputSourceRange\n                            ? {\n                                start: attr.start + attr.name.indexOf(`[`),\n                                end: attr.start + attr.name.length\n                            }\n                            : undefined);\n                    }\n                });\n            }\n            if (isForbiddenTag(element) && !isServerRendering()) {\n                element.forbidden = true;\n                warn('Templates should only be responsible for mapping the state to the ' +\n                        'UI. Avoid placing tags with side-effects in your templates, such as ' +\n                        `<${tag}>` +\n                        ', as they will not be parsed.', { start: element.start });\n            }\n            // apply pre-transforms\n            for (let i = 0; i < preTransforms.length; i++) {\n                element = preTransforms[i](element, options) || element;\n            }\n            if (!inVPre) {\n                processPre(element);\n                if (element.pre) {\n                    inVPre = true;\n                }\n            }\n            if (platformIsPreTag(element.tag)) {\n                inPre = true;\n            }\n            if (inVPre) {\n                processRawAttrs(element);\n            }\n            else if (!element.processed) {\n                // structural directives\n                processFor(element);\n                processIf(element);\n                processOnce(element);\n            }\n            if (!root) {\n                root = element;\n                {\n                    checkRootConstraints(root);\n                }\n            }\n            if (!unary) {\n                currentParent = element;\n                stack.push(element);\n            }\n            else {\n                closeElement(element);\n            }\n        },\n        end(tag, start, end) {\n            const element = stack[stack.length - 1];\n            // pop stack\n            stack.length -= 1;\n            currentParent = stack[stack.length - 1];\n            if (options.outputSourceRange) {\n                element.end = end;\n            }\n            closeElement(element);\n        },\n        chars(text, start, end) {\n            if (!currentParent) {\n                {\n                    if (text === template) {\n                        warnOnce('Component template requires a root element, rather than just text.', { start });\n                    }\n                    else if ((text = text.trim())) {\n                        warnOnce(`text \"${text}\" outside root element will be ignored.`, {\n                            start\n                        });\n                    }\n                }\n                return;\n            }\n            // IE textarea placeholder bug\n            /* istanbul ignore if */\n            if (isIE &&\n                currentParent.tag === 'textarea' &&\n                currentParent.attrsMap.placeholder === text) {\n                return;\n            }\n            const children = currentParent.children;\n            if (inPre || text.trim()) {\n                text = isTextTag(currentParent)\n                    ? text\n                    : decodeHTMLCached(text);\n            }\n            else if (!children.length) {\n                // remove the whitespace-only node right after an opening tag\n                text = '';\n            }\n            else if (whitespaceOption) {\n                if (whitespaceOption === 'condense') {\n                    // in condense mode, remove the whitespace node if it contains\n                    // line break, otherwise condense to a single space\n                    text = lineBreakRE.test(text) ? '' : ' ';\n                }\n                else {\n                    text = ' ';\n                }\n            }\n            else {\n                text = preserveWhitespace ? ' ' : '';\n            }\n            if (text) {\n                if (!inPre && whitespaceOption === 'condense') {\n                    // condense consecutive whitespaces into single space\n                    text = text.replace(whitespaceRE, ' ');\n                }\n                let res;\n                let child;\n                if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n                    child = {\n                        type: 2,\n                        expression: res.expression,\n                        tokens: res.tokens,\n                        text\n                    };\n                }\n                else if (text !== ' ' ||\n                    !children.length ||\n                    children[children.length - 1].text !== ' ') {\n                    child = {\n                        type: 3,\n                        text\n                    };\n                }\n                if (child) {\n                    if (options.outputSourceRange) {\n                        child.start = start;\n                        child.end = end;\n                    }\n                    children.push(child);\n                }\n            }\n        },\n        comment(text, start, end) {\n            // adding anything as a sibling to the root node is forbidden\n            // comments should still be allowed, but ignored\n            if (currentParent) {\n                const child = {\n                    type: 3,\n                    text,\n                    isComment: true\n                };\n                if (options.outputSourceRange) {\n                    child.start = start;\n                    child.end = end;\n                }\n                currentParent.children.push(child);\n            }\n        }\n    });\n    return root;\n}\nfunction processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n        el.pre = true;\n    }\n}\nfunction processRawAttrs(el) {\n    const list = el.attrsList;\n    const len = list.length;\n    if (len) {\n        const attrs = (el.attrs = new Array(len));\n        for (let i = 0; i < len; i++) {\n            attrs[i] = {\n                name: list[i].name,\n                value: JSON.stringify(list[i].value)\n            };\n            if (list[i].start != null) {\n                attrs[i].start = list[i].start;\n                attrs[i].end = list[i].end;\n            }\n        }\n    }\n    else if (!el.pre) {\n        // non root node in pre blocks with no attributes\n        el.plain = true;\n    }\n}\nfunction processElement(element, options) {\n    processKey(element);\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain =\n        !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (let i = 0; i < transforms.length; i++) {\n        element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element;\n}\nfunction processKey(el) {\n    const exp = getBindingAttr(el, 'key');\n    if (exp) {\n        {\n            if (el.tag === 'template') {\n                warn(`<template> cannot be keyed. Place the key on real elements instead.`, getRawBindingAttr(el, 'key'));\n            }\n            if (el.for) {\n                const iterator = el.iterator2 || el.iterator1;\n                const parent = el.parent;\n                if (iterator &&\n                    iterator === exp &&\n                    parent &&\n                    parent.tag === 'transition-group') {\n                    warn(`Do not use v-for index as key on <transition-group> children, ` +\n                        `this is the same as not using keys.`, getRawBindingAttr(el, 'key'), true /* tip */);\n                }\n            }\n        }\n        el.key = exp;\n    }\n}\nfunction processRef(el) {\n    const ref = getBindingAttr(el, 'ref');\n    if (ref) {\n        el.ref = ref;\n        el.refInFor = checkInFor(el);\n    }\n}\nfunction processFor(el) {\n    let exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n        const res = parseFor(exp);\n        if (res) {\n            extend(el, res);\n        }\n        else {\n            warn(`Invalid v-for expression: ${exp}`, el.rawAttrsMap['v-for']);\n        }\n    }\n}\nfunction parseFor(exp) {\n    const inMatch = exp.match(forAliasRE);\n    if (!inMatch)\n        return;\n    const res = {};\n    res.for = inMatch[2].trim();\n    const alias = inMatch[1].trim().replace(stripParensRE, '');\n    const iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n        res.alias = alias.replace(forIteratorRE, '').trim();\n        res.iterator1 = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n            res.iterator2 = iteratorMatch[2].trim();\n        }\n    }\n    else {\n        res.alias = alias;\n    }\n    return res;\n}\nfunction processIf(el) {\n    const exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n        el.if = exp;\n        addIfCondition(el, {\n            exp: exp,\n            block: el\n        });\n    }\n    else {\n        if (getAndRemoveAttr(el, 'v-else') != null) {\n            el.else = true;\n        }\n        const elseif = getAndRemoveAttr(el, 'v-else-if');\n        if (elseif) {\n            el.elseif = elseif;\n        }\n    }\n}\nfunction processIfConditions(el, parent) {\n    const prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n        addIfCondition(prev, {\n            exp: el.elseif,\n            block: el\n        });\n    }\n    else {\n        warn(`v-${el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else'} ` +\n            `used on element <${el.tag}> without corresponding v-if.`, el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n}\nfunction findPrevElement(children) {\n    let i = children.length;\n    while (i--) {\n        if (children[i].type === 1) {\n            return children[i];\n        }\n        else {\n            if (children[i].text !== ' ') {\n                warn(`text \"${children[i].text.trim()}\" between v-if and v-else(-if) ` +\n                    `will be ignored.`, children[i]);\n            }\n            children.pop();\n        }\n    }\n}\nfunction addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n        el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n}\nfunction processOnce(el) {\n    const once = getAndRemoveAttr(el, 'v-once');\n    if (once != null) {\n        el.once = true;\n    }\n}\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent(el) {\n    let slotScope;\n    if (el.tag === 'template') {\n        slotScope = getAndRemoveAttr(el, 'scope');\n        /* istanbul ignore if */\n        if (slotScope) {\n            warn(`the \"scope\" attribute for scoped slots have been deprecated and ` +\n                `replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute ` +\n                `can also be used on plain elements in addition to <template> to ` +\n                `denote scoped slots.`, el.rawAttrsMap['scope'], true);\n        }\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    }\n    else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n        /* istanbul ignore if */\n        if (el.attrsMap['v-for']) {\n            warn(`Ambiguous combined usage of slot-scope and v-for on <${el.tag}> ` +\n                `(v-for takes higher priority). Use a wrapper <template> for the ` +\n                `scoped slot to make it clearer.`, el.rawAttrsMap['slot-scope'], true);\n        }\n        el.slotScope = slotScope;\n    }\n    // slot=\"xxx\"\n    const slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n        // preserve slot as an attribute for native shadow DOM compat\n        // only for non-scoped slots.\n        if (el.tag !== 'template' && !el.slotScope) {\n            addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n        }\n    }\n    // 2.6 v-slot syntax\n    {\n        if (el.tag === 'template') {\n            // v-slot on <template>\n            const slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n            if (slotBinding) {\n                {\n                    if (el.slotTarget || el.slotScope) {\n                        warn(`Unexpected mixed usage of different slot syntaxes.`, el);\n                    }\n                    if (el.parent && !maybeComponent(el.parent)) {\n                        warn(`<template v-slot> can only appear at the root level inside ` +\n                            `the receiving component`, el);\n                    }\n                }\n                const { name, dynamic } = getSlotName(slotBinding);\n                el.slotTarget = name;\n                el.slotTargetDynamic = dynamic;\n                el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n            }\n        }\n        else {\n            // v-slot on component, denotes default slot\n            const slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n            if (slotBinding) {\n                {\n                    if (!maybeComponent(el)) {\n                        warn(`v-slot can only be used on components or <template>.`, slotBinding);\n                    }\n                    if (el.slotScope || el.slotTarget) {\n                        warn(`Unexpected mixed usage of different slot syntaxes.`, el);\n                    }\n                    if (el.scopedSlots) {\n                        warn(`To avoid scope ambiguity, the default slot should also use ` +\n                            `<template> syntax when there are other named slots.`, slotBinding);\n                    }\n                }\n                // add the component's children to its default slot\n                const slots = el.scopedSlots || (el.scopedSlots = {});\n                const { name, dynamic } = getSlotName(slotBinding);\n                const slotContainer = (slots[name] = createASTElement('template', [], el));\n                slotContainer.slotTarget = name;\n                slotContainer.slotTargetDynamic = dynamic;\n                slotContainer.children = el.children.filter((c) => {\n                    if (!c.slotScope) {\n                        c.parent = slotContainer;\n                        return true;\n                    }\n                });\n                slotContainer.slotScope = slotBinding.value || emptySlotScopeToken;\n                // remove children as they are returned from scopedSlots now\n                el.children = [];\n                // mark el non-plain so data gets generated\n                el.plain = false;\n            }\n        }\n    }\n}\nfunction getSlotName(binding) {\n    let name = binding.name.replace(slotRE, '');\n    if (!name) {\n        if (binding.name[0] !== '#') {\n            name = 'default';\n        }\n        else {\n            warn(`v-slot shorthand syntax requires a slot name.`, binding);\n        }\n    }\n    return dynamicArgRE.test(name)\n        ? // dynamic [name]\n            { name: name.slice(1, -1), dynamic: true }\n        : // static name\n            { name: `\"${name}\"`, dynamic: false };\n}\n// handle <slot/> outlets\nfunction processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n        el.slotName = getBindingAttr(el, 'name');\n        if (el.key) {\n            warn(`\\`key\\` does not work on <slot> because slots are abstract outlets ` +\n                `and can possibly expand into multiple elements. ` +\n                `Use the key on a wrapping element instead.`, getRawBindingAttr(el, 'key'));\n        }\n    }\n}\nfunction processComponent(el) {\n    let binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n        el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n        el.inlineTemplate = true;\n    }\n}\nfunction processAttrs(el) {\n    const list = el.attrsList;\n    let i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n        name = rawName = list[i].name;\n        value = list[i].value;\n        if (dirRE.test(name)) {\n            // mark element as dynamic\n            el.hasBindings = true;\n            // modifiers\n            modifiers = parseModifiers(name.replace(dirRE, ''));\n            // support .foo shorthand syntax for the .prop modifier\n            if (modifiers) {\n                name = name.replace(modifierRE, '');\n            }\n            if (bindRE.test(name)) {\n                // v-bind\n                name = name.replace(bindRE, '');\n                value = parseFilters(value);\n                isDynamic = dynamicArgRE.test(name);\n                if (isDynamic) {\n                    name = name.slice(1, -1);\n                }\n                if (value.trim().length === 0) {\n                    warn(`The value for a v-bind expression cannot be empty. Found in \"v-bind:${name}\"`);\n                }\n                if (modifiers) {\n                    if (modifiers.prop && !isDynamic) {\n                        name = camelize(name);\n                        if (name === 'innerHtml')\n                            name = 'innerHTML';\n                    }\n                    if (modifiers.camel && !isDynamic) {\n                        name = camelize(name);\n                    }\n                    if (modifiers.sync) {\n                        syncGen = genAssignmentCode(value, `$event`);\n                        if (!isDynamic) {\n                            addHandler(el, `update:${camelize(name)}`, syncGen, null, false, warn, list[i]);\n                            if (hyphenate(name) !== camelize(name)) {\n                                addHandler(el, `update:${hyphenate(name)}`, syncGen, null, false, warn, list[i]);\n                            }\n                        }\n                        else {\n                            // handler w/ dynamic event name\n                            addHandler(el, `\"update:\"+(${name})`, syncGen, null, false, warn, list[i], true // dynamic\n                            );\n                        }\n                    }\n                }\n                if ((modifiers && modifiers.prop) ||\n                    (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {\n                    addProp(el, name, value, list[i], isDynamic);\n                }\n                else {\n                    addAttr(el, name, value, list[i], isDynamic);\n                }\n            }\n            else if (onRE.test(name)) {\n                // v-on\n                name = name.replace(onRE, '');\n                isDynamic = dynamicArgRE.test(name);\n                if (isDynamic) {\n                    name = name.slice(1, -1);\n                }\n                addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);\n            }\n            else {\n                // normal directives\n                name = name.replace(dirRE, '');\n                // parse arg\n                const argMatch = name.match(argRE);\n                let arg = argMatch && argMatch[1];\n                isDynamic = false;\n                if (arg) {\n                    name = name.slice(0, -(arg.length + 1));\n                    if (dynamicArgRE.test(arg)) {\n                        arg = arg.slice(1, -1);\n                        isDynamic = true;\n                    }\n                }\n                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n                if (name === 'model') {\n                    checkForAliasModel(el, value);\n                }\n            }\n        }\n        else {\n            // literal attribute\n            {\n                const res = parseText(value, delimiters);\n                if (res) {\n                    warn(`${name}=\"${value}\": ` +\n                        'Interpolation inside attributes has been removed. ' +\n                        'Use v-bind or the colon shorthand instead. For example, ' +\n                        'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n                }\n            }\n            addAttr(el, name, JSON.stringify(value), list[i]);\n            // #6887 firefox doesn't update muted state if set via attribute\n            // even immediately after element creation\n            if (!el.component &&\n                name === 'muted' &&\n                platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n                addProp(el, name, 'true', list[i]);\n            }\n        }\n    }\n}\nfunction checkInFor(el) {\n    let parent = el;\n    while (parent) {\n        if (parent.for !== undefined) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction parseModifiers(name) {\n    const match = name.match(modifierRE);\n    if (match) {\n        const ret = {};\n        match.forEach(m => {\n            ret[m.slice(1)] = true;\n        });\n        return ret;\n    }\n}\nfunction makeAttrsMap(attrs) {\n    const map = {};\n    for (let i = 0, l = attrs.length; i < l; i++) {\n        if (map[attrs[i].name] && !isIE && !isEdge) {\n            warn('duplicate attribute: ' + attrs[i].name, attrs[i]);\n        }\n        map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n}\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n}\nfunction isForbiddenTag(el) {\n    return (el.tag === 'style' ||\n        (el.tag === 'script' &&\n            (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));\n}\nconst ieNSBug = /^xmlns:NS\\d+/;\nconst ieNSPrefix = /^NS\\d+:/;\n/* istanbul ignore next */\nfunction guardIESVGBug(attrs) {\n    const res = [];\n    for (let i = 0; i < attrs.length; i++) {\n        const attr = attrs[i];\n        if (!ieNSBug.test(attr.name)) {\n            attr.name = attr.name.replace(ieNSPrefix, '');\n            res.push(attr);\n        }\n    }\n    return res;\n}\nfunction checkForAliasModel(el, value) {\n    let _el = el;\n    while (_el) {\n        if (_el.for && _el.alias === value) {\n            warn(`<${el.tag} v-model=\"${value}\">: ` +\n                `You are binding v-model directly to a v-for iteration alias. ` +\n                `This will not be able to modify the v-for source array because ` +\n                `writing to the alias is like modifying a function local variable. ` +\n                `Consider using an array of objects and use v-model on an object property instead.`, el.rawAttrsMap['v-model']);\n        }\n        _el = _el.parent;\n    }\n}\n\n/**\n * Expand input[v-model] with dynamic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\nfunction preTransformNode(el, options) {\n    if (el.tag === 'input') {\n        const map = el.attrsMap;\n        if (!map['v-model']) {\n            return;\n        }\n        let typeBinding;\n        if (map[':type'] || map['v-bind:type']) {\n            typeBinding = getBindingAttr(el, 'type');\n        }\n        if (!map.type && !typeBinding && map['v-bind']) {\n            typeBinding = `(${map['v-bind']}).type`;\n        }\n        if (typeBinding) {\n            const ifCondition = getAndRemoveAttr(el, 'v-if', true);\n            const ifConditionExtra = ifCondition ? `&&(${ifCondition})` : ``;\n            const hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n            const elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n            // 1. checkbox\n            const branch0 = cloneASTElement(el);\n            // process for on the main node\n            processFor(branch0);\n            addRawAttr(branch0, 'type', 'checkbox');\n            processElement(branch0, options);\n            branch0.processed = true; // prevent it from double-processed\n            branch0.if = `(${typeBinding})==='checkbox'` + ifConditionExtra;\n            addIfCondition(branch0, {\n                exp: branch0.if,\n                block: branch0\n            });\n            // 2. add radio else-if condition\n            const branch1 = cloneASTElement(el);\n            getAndRemoveAttr(branch1, 'v-for', true);\n            addRawAttr(branch1, 'type', 'radio');\n            processElement(branch1, options);\n            addIfCondition(branch0, {\n                exp: `(${typeBinding})==='radio'` + ifConditionExtra,\n                block: branch1\n            });\n            // 3. other\n            const branch2 = cloneASTElement(el);\n            getAndRemoveAttr(branch2, 'v-for', true);\n            addRawAttr(branch2, ':type', typeBinding);\n            processElement(branch2, options);\n            addIfCondition(branch0, {\n                exp: ifCondition,\n                block: branch2\n            });\n            if (hasElse) {\n                branch0.else = true;\n            }\n            else if (elseIfCondition) {\n                branch0.elseif = elseIfCondition;\n            }\n            return branch0;\n        }\n    }\n}\nfunction cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n}\nvar model = {\n    preTransformNode\n};\n\nvar modules = [klass, style, model];\n\nfunction text(el, dir) {\n    if (dir.value) {\n        addProp(el, 'textContent', `_s(${dir.value})`, dir);\n    }\n}\n\nfunction html(el, dir) {\n    if (dir.value) {\n        addProp(el, 'innerHTML', `_s(${dir.value})`, dir);\n    }\n}\n\nvar directives = {\n    model: model$1,\n    text,\n    html\n};\n\nconst baseOptions = {\n    expectHTML: true,\n    modules,\n    directives,\n    isPreTag,\n    isUnaryTag,\n    mustUseProp,\n    canBeLeftOpenTag,\n    isReservedTag,\n    getTagNamespace,\n    staticKeys: genStaticKeys$1(modules)\n};\n\nlet isStaticKey;\nlet isPlatformReservedTag;\nconst genStaticKeysCached = cached(genStaticKeys);\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize(root, options) {\n    if (!root)\n        return;\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n}\nfunction genStaticKeys(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n        (keys ? ',' + keys : ''));\n}\nfunction markStatic(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n        // do not make component slot content static. this avoids\n        // 1. components not able to mutate slot nodes\n        // 2. static slot content fails for hot-reloading\n        if (!isPlatformReservedTag(node.tag) &&\n            node.tag !== 'slot' &&\n            node.attrsMap['inline-template'] == null) {\n            return;\n        }\n        for (let i = 0, l = node.children.length; i < l; i++) {\n            const child = node.children[i];\n            markStatic(child);\n            if (!child.static) {\n                node.static = false;\n            }\n        }\n        if (node.ifConditions) {\n            for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n                const block = node.ifConditions[i].block;\n                markStatic(block);\n                if (!block.static) {\n                    node.static = false;\n                }\n            }\n        }\n    }\n}\nfunction markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n        if (node.static || node.once) {\n            node.staticInFor = isInFor;\n        }\n        // For a node to qualify as a static root, it should have children that\n        // are not just static text. Otherwise the cost of hoisting out will\n        // outweigh the benefits and it's better off to just always render it fresh.\n        if (node.static &&\n            node.children.length &&\n            !(node.children.length === 1 && node.children[0].type === 3)) {\n            node.staticRoot = true;\n            return;\n        }\n        else {\n            node.staticRoot = false;\n        }\n        if (node.children) {\n            for (let i = 0, l = node.children.length; i < l; i++) {\n                markStaticRoots(node.children[i], isInFor || !!node.for);\n            }\n        }\n        if (node.ifConditions) {\n            for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n                markStaticRoots(node.ifConditions[i].block, isInFor);\n            }\n        }\n    }\n}\nfunction isStatic(node) {\n    if (node.type === 2) {\n        // expression\n        return false;\n    }\n    if (node.type === 3) {\n        // text\n        return true;\n    }\n    return !!(node.pre ||\n        (!node.hasBindings && // no dynamic bindings\n            !node.if &&\n            !node.for && // not v-if or v-for or v-else\n            !isBuiltInTag(node.tag) && // not a built-in\n            isPlatformReservedTag(node.tag) && // not a component\n            !isDirectChildOfTemplateFor(node) &&\n            Object.keys(node).every(isStaticKey)));\n}\nfunction isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n        node = node.parent;\n        if (node.tag !== 'template') {\n            return false;\n        }\n        if (node.for) {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\nconst fnInvokeRE = /\\([^)]*?\\);*$/;\nconst simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n// KeyboardEvent.keyCode aliases\nconst keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    delete: [8, 46]\n};\n// KeyboardEvent.key aliases\nconst keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    delete: ['Backspace', 'Delete', 'Del']\n};\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nconst genGuard = condition => `if(${condition})return null;`;\nconst modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(`$event.target !== $event.currentTarget`),\n    ctrl: genGuard(`!$event.ctrlKey`),\n    shift: genGuard(`!$event.shiftKey`),\n    alt: genGuard(`!$event.altKey`),\n    meta: genGuard(`!$event.metaKey`),\n    left: genGuard(`'button' in $event && $event.button !== 0`),\n    middle: genGuard(`'button' in $event && $event.button !== 1`),\n    right: genGuard(`'button' in $event && $event.button !== 2`)\n};\nfunction genHandlers(events, isNative) {\n    const prefix = isNative ? 'nativeOn:' : 'on:';\n    let staticHandlers = ``;\n    let dynamicHandlers = ``;\n    for (const name in events) {\n        const handlerCode = genHandler(events[name]);\n        //@ts-expect-error\n        if (events[name] && events[name].dynamic) {\n            dynamicHandlers += `${name},${handlerCode},`;\n        }\n        else {\n            staticHandlers += `\"${name}\":${handlerCode},`;\n        }\n    }\n    staticHandlers = `{${staticHandlers.slice(0, -1)}}`;\n    if (dynamicHandlers) {\n        return prefix + `_d(${staticHandlers},[${dynamicHandlers.slice(0, -1)}])`;\n    }\n    else {\n        return prefix + staticHandlers;\n    }\n}\nfunction genHandler(handler) {\n    if (!handler) {\n        return 'function(){}';\n    }\n    if (Array.isArray(handler)) {\n        return `[${handler.map(handler => genHandler(handler)).join(',')}]`;\n    }\n    const isMethodPath = simplePathRE.test(handler.value);\n    const isFunctionExpression = fnExpRE.test(handler.value);\n    const isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n    if (!handler.modifiers) {\n        if (isMethodPath || isFunctionExpression) {\n            return handler.value;\n        }\n        return `function($event){${isFunctionInvocation ? `return ${handler.value}` : handler.value}}`; // inline statement\n    }\n    else {\n        let code = '';\n        let genModifierCode = '';\n        const keys = [];\n        for (const key in handler.modifiers) {\n            if (modifierCode[key]) {\n                genModifierCode += modifierCode[key];\n                // left/right\n                if (keyCodes[key]) {\n                    keys.push(key);\n                }\n            }\n            else if (key === 'exact') {\n                const modifiers = handler.modifiers;\n                genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']\n                    .filter(keyModifier => !modifiers[keyModifier])\n                    .map(keyModifier => `$event.${keyModifier}Key`)\n                    .join('||'));\n            }\n            else {\n                keys.push(key);\n            }\n        }\n        if (keys.length) {\n            code += genKeyFilter(keys);\n        }\n        // Make sure modifiers like prevent and stop get executed after key filtering\n        if (genModifierCode) {\n            code += genModifierCode;\n        }\n        const handlerCode = isMethodPath\n            ? `return ${handler.value}.apply(null, arguments)`\n            : isFunctionExpression\n                ? `return (${handler.value}).apply(null, arguments)`\n                : isFunctionInvocation\n                    ? `return ${handler.value}`\n                    : handler.value;\n        return `function($event){${code}${handlerCode}}`;\n    }\n}\nfunction genKeyFilter(keys) {\n    return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    `if(!$event.type.indexOf('key')&&` +\n        `${keys.map(genFilterCode).join('&&')})return null;`);\n}\nfunction genFilterCode(key) {\n    const keyVal = parseInt(key, 10);\n    if (keyVal) {\n        return `$event.keyCode!==${keyVal}`;\n    }\n    const keyCode = keyCodes[key];\n    const keyName = keyNames[key];\n    return (`_k($event.keyCode,` +\n        `${JSON.stringify(key)},` +\n        `${JSON.stringify(keyCode)},` +\n        `$event.key,` +\n        `${JSON.stringify(keyName)}` +\n        `)`);\n}\n\nfunction on(el, dir) {\n    if (dir.modifiers) {\n        warn$2(`v-on without argument does not support modifiers.`);\n    }\n    el.wrapListeners = (code) => `_g(${code},${dir.value})`;\n}\n\nfunction bind(el, dir) {\n    el.wrapData = (code) => {\n        return `_b(${code},'${el.tag}',${dir.value},${dir.modifiers && dir.modifiers.prop ? 'true' : 'false'}${dir.modifiers && dir.modifiers.sync ? ',true' : ''})`;\n    };\n}\n\nvar baseDirectives = {\n    on,\n    bind,\n    cloak: noop\n};\n\nclass CodegenState {\n    constructor(options) {\n        this.options = options;\n        this.warn = options.warn || baseWarn;\n        this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n        this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n        this.directives = extend(extend({}, baseDirectives), options.directives);\n        const isReservedTag = options.isReservedTag || no;\n        this.maybeComponent = (el) => !!el.component || !isReservedTag(el.tag);\n        this.onceId = 0;\n        this.staticRenderFns = [];\n        this.pre = false;\n    }\n}\nfunction generate(ast, options) {\n    const state = new CodegenState(options);\n    // fix #11483, Root level <script> tags should not be rendered.\n    const code = ast\n        ? ast.tag === 'script'\n            ? 'null'\n            : genElement(ast, state)\n        : '_c(\"div\")';\n    return {\n        render: `with(this){return ${code}}`,\n        staticRenderFns: state.staticRenderFns\n    };\n}\nfunction genElement(el, state) {\n    if (el.parent) {\n        el.pre = el.pre || el.parent.pre;\n    }\n    if (el.staticRoot && !el.staticProcessed) {\n        return genStatic(el, state);\n    }\n    else if (el.once && !el.onceProcessed) {\n        return genOnce(el, state);\n    }\n    else if (el.for && !el.forProcessed) {\n        return genFor(el, state);\n    }\n    else if (el.if && !el.ifProcessed) {\n        return genIf(el, state);\n    }\n    else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n        return genChildren(el, state) || 'void 0';\n    }\n    else if (el.tag === 'slot') {\n        return genSlot(el, state);\n    }\n    else {\n        // component or element\n        let code;\n        if (el.component) {\n            code = genComponent(el.component, el, state);\n        }\n        else {\n            let data;\n            const maybeComponent = state.maybeComponent(el);\n            if (!el.plain || (el.pre && maybeComponent)) {\n                data = genData(el, state);\n            }\n            let tag;\n            // check if this is a component in <script setup>\n            const bindings = state.options.bindings;\n            if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\n                tag = checkBindingType(bindings, el.tag);\n            }\n            if (!tag)\n                tag = `'${el.tag}'`;\n            const children = el.inlineTemplate ? null : genChildren(el, state, true);\n            code = `_c(${tag}${data ? `,${data}` : '' // data\n            }${children ? `,${children}` : '' // children\n            })`;\n        }\n        // module transforms\n        for (let i = 0; i < state.transforms.length; i++) {\n            code = state.transforms[i](el, code);\n        }\n        return code;\n    }\n}\nfunction checkBindingType(bindings, key) {\n    const camelName = camelize(key);\n    const PascalName = capitalize(camelName);\n    const checkType = (type) => {\n        if (bindings[key] === type) {\n            return key;\n        }\n        if (bindings[camelName] === type) {\n            return camelName;\n        }\n        if (bindings[PascalName] === type) {\n            return PascalName;\n        }\n    };\n    const fromConst = checkType(\"setup-const\" /* BindingTypes.SETUP_CONST */) ||\n        checkType(\"setup-reactive-const\" /* BindingTypes.SETUP_REACTIVE_CONST */);\n    if (fromConst) {\n        return fromConst;\n    }\n    const fromMaybeRef = checkType(\"setup-let\" /* BindingTypes.SETUP_LET */) ||\n        checkType(\"setup-ref\" /* BindingTypes.SETUP_REF */) ||\n        checkType(\"setup-maybe-ref\" /* BindingTypes.SETUP_MAYBE_REF */);\n    if (fromMaybeRef) {\n        return fromMaybeRef;\n    }\n}\n// hoist static sub-trees out\nfunction genStatic(el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    const originalPreState = state.pre;\n    if (el.pre) {\n        state.pre = el.pre;\n    }\n    state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`);\n    state.pre = originalPreState;\n    return `_m(${state.staticRenderFns.length - 1}${el.staticInFor ? ',true' : ''})`;\n}\n// v-once\nfunction genOnce(el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n        return genIf(el, state);\n    }\n    else if (el.staticInFor) {\n        let key = '';\n        let parent = el.parent;\n        while (parent) {\n            if (parent.for) {\n                key = parent.key;\n                break;\n            }\n            parent = parent.parent;\n        }\n        if (!key) {\n            state.warn(`v-once can only be used inside v-for that is keyed. `, el.rawAttrsMap['v-once']);\n            return genElement(el, state);\n        }\n        return `_o(${genElement(el, state)},${state.onceId++},${key})`;\n    }\n    else {\n        return genStatic(el, state);\n    }\n}\nfunction genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n        return altEmpty || '_e()';\n    }\n    const condition = conditions.shift();\n    if (condition.exp) {\n        return `(${condition.exp})?${genTernaryExp(condition.block)}:${genIfConditions(conditions, state, altGen, altEmpty)}`;\n    }\n    else {\n        return `${genTernaryExp(condition.block)}`;\n    }\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp(el) {\n        return altGen\n            ? altGen(el, state)\n            : el.once\n                ? genOnce(el, state)\n                : genElement(el, state);\n    }\n}\nfunction genFor(el, state, altGen, altHelper) {\n    const exp = el.for;\n    const alias = el.alias;\n    const iterator1 = el.iterator1 ? `,${el.iterator1}` : '';\n    const iterator2 = el.iterator2 ? `,${el.iterator2}` : '';\n    if (state.maybeComponent(el) &&\n        el.tag !== 'slot' &&\n        el.tag !== 'template' &&\n        !el.key) {\n        state.warn(`<${el.tag} v-for=\"${alias} in ${exp}\">: component lists rendered with ` +\n            `v-for should have explicit keys. ` +\n            `See https://v2.vuejs.org/v2/guide/list.html#key for more info.`, el.rawAttrsMap['v-for'], true /* tip */);\n    }\n    el.forProcessed = true; // avoid recursion\n    return (`${altHelper || '_l'}((${exp}),` +\n        `function(${alias}${iterator1}${iterator2}){` +\n        `return ${(altGen || genElement)(el, state)}` +\n        '})');\n}\nfunction genData(el, state) {\n    let data = '{';\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    const dirs = genDirectives(el, state);\n    if (dirs)\n        data += dirs + ',';\n    // key\n    if (el.key) {\n        data += `key:${el.key},`;\n    }\n    // ref\n    if (el.ref) {\n        data += `ref:${el.ref},`;\n    }\n    if (el.refInFor) {\n        data += `refInFor:true,`;\n    }\n    // pre\n    if (el.pre) {\n        data += `pre:true,`;\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n        data += `tag:\"${el.tag}\",`;\n    }\n    // module data generation functions\n    for (let i = 0; i < state.dataGenFns.length; i++) {\n        data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n        data += `attrs:${genProps(el.attrs)},`;\n    }\n    // DOM props\n    if (el.props) {\n        data += `domProps:${genProps(el.props)},`;\n    }\n    // event handlers\n    if (el.events) {\n        data += `${genHandlers(el.events, false)},`;\n    }\n    if (el.nativeEvents) {\n        data += `${genHandlers(el.nativeEvents, true)},`;\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n        data += `slot:${el.slotTarget},`;\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n        data += `${genScopedSlots(el, el.scopedSlots, state)},`;\n    }\n    // component v-model\n    if (el.model) {\n        data += `model:{value:${el.model.value},callback:${el.model.callback},expression:${el.model.expression}},`;\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n        const inlineTemplate = genInlineTemplate(el, state);\n        if (inlineTemplate) {\n            data += `${inlineTemplate},`;\n        }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n        data = `_b(${data},\"${el.tag}\",${genProps(el.dynamicAttrs)})`;\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n        data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n        data = el.wrapListeners(data);\n    }\n    return data;\n}\nfunction genDirectives(el, state) {\n    const dirs = el.directives;\n    if (!dirs)\n        return;\n    let res = 'directives:[';\n    let hasRuntime = false;\n    let i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n        dir = dirs[i];\n        needRuntime = true;\n        const gen = state.directives[dir.name];\n        if (gen) {\n            // compile-time directive that manipulates AST.\n            // returns true if it also needs a runtime counterpart.\n            needRuntime = !!gen(el, dir, state.warn);\n        }\n        if (needRuntime) {\n            hasRuntime = true;\n            res += `{name:\"${dir.name}\",rawName:\"${dir.rawName}\"${dir.value\n                ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}`\n                : ''}${dir.arg ? `,arg:${dir.isDynamicArg ? dir.arg : `\"${dir.arg}\"`}` : ''}${dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ''}},`;\n        }\n    }\n    if (hasRuntime) {\n        return res.slice(0, -1) + ']';\n    }\n}\nfunction genInlineTemplate(el, state) {\n    const ast = el.children[0];\n    if ((el.children.length !== 1 || ast.type !== 1)) {\n        state.warn('Inline-template components must have exactly one child element.', { start: el.start });\n    }\n    if (ast && ast.type === 1) {\n        const inlineRenderFns = generate(ast, state.options);\n        return `inlineTemplate:{render:function(){${inlineRenderFns.render}},staticRenderFns:[${inlineRenderFns.staticRenderFns\n            .map(code => `function(){${code}}`)\n            .join(',')}]}`;\n    }\n}\nfunction genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    let needsForceUpdate = el.for ||\n        Object.keys(slots).some(key => {\n            const slot = slots[key];\n            return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n            );\n        });\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    let needsKey = !!el.if;\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n        let parent = el.parent;\n        while (parent) {\n            if ((parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n                parent.for) {\n                needsForceUpdate = true;\n                break;\n            }\n            if (parent.if) {\n                needsKey = true;\n            }\n            parent = parent.parent;\n        }\n    }\n    const generatedSlots = Object.keys(slots)\n        .map(key => genScopedSlot(slots[key], state))\n        .join(',');\n    return `scopedSlots:_u([${generatedSlots}]${needsForceUpdate ? `,null,true` : ``}${!needsForceUpdate && needsKey ? `,null,false,${hash(generatedSlots)}` : ``})`;\n}\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i) {\n        hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0;\n}\nfunction containsSlotChild(el) {\n    if (el.type === 1) {\n        if (el.tag === 'slot') {\n            return true;\n        }\n        return el.children.some(containsSlotChild);\n    }\n    return false;\n}\nfunction genScopedSlot(el, state) {\n    const isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n        return genIf(el, state, genScopedSlot, `null`);\n    }\n    if (el.for && !el.forProcessed) {\n        return genFor(el, state, genScopedSlot);\n    }\n    const slotScope = el.slotScope === emptySlotScopeToken ? `` : String(el.slotScope);\n    const fn = `function(${slotScope}){` +\n        `return ${el.tag === 'template'\n            ? el.if && isLegacySyntax\n                ? `(${el.if})?${genChildren(el, state) || 'undefined'}:undefined`\n                : genChildren(el, state) || 'undefined'\n            : genElement(el, state)}}`;\n    // reverse proxy v-slot without scope on this.$slots\n    const reverseProxy = slotScope ? `` : `,proxy:true`;\n    return `{key:${el.slotTarget || `\"default\"`},fn:${fn}${reverseProxy}}`;\n}\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    const children = el.children;\n    if (children.length) {\n        const el = children[0];\n        // optimize single v-for\n        if (children.length === 1 &&\n            el.for &&\n            el.tag !== 'template' &&\n            el.tag !== 'slot') {\n            const normalizationType = checkSkip\n                ? state.maybeComponent(el)\n                    ? `,1`\n                    : `,0`\n                : ``;\n            return `${(altGenElement || genElement)(el, state)}${normalizationType}`;\n        }\n        const normalizationType = checkSkip\n            ? getNormalizationType(children, state.maybeComponent)\n            : 0;\n        const gen = altGenNode || genNode;\n        return `[${children.map(c => gen(c, state)).join(',')}]${normalizationType ? `,${normalizationType}` : ''}`;\n    }\n}\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType(children, maybeComponent) {\n    let res = 0;\n    for (let i = 0; i < children.length; i++) {\n        const el = children[i];\n        if (el.type !== 1) {\n            continue;\n        }\n        if (needsNormalization(el) ||\n            (el.ifConditions &&\n                el.ifConditions.some(c => needsNormalization(c.block)))) {\n            res = 2;\n            break;\n        }\n        if (maybeComponent(el) ||\n            (el.ifConditions && el.ifConditions.some(c => maybeComponent(c.block)))) {\n            res = 1;\n        }\n    }\n    return res;\n}\nfunction needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\nfunction genNode(node, state) {\n    if (node.type === 1) {\n        return genElement(node, state);\n    }\n    else if (node.type === 3 && node.isComment) {\n        return genComment(node);\n    }\n    else {\n        return genText(node);\n    }\n}\nfunction genText(text) {\n    return `_v(${text.type === 2\n        ? text.expression // no need for () because already wrapped in _s()\n        : transformSpecialNewlines(JSON.stringify(text.text))})`;\n}\nfunction genComment(comment) {\n    return `_e(${JSON.stringify(comment.text)})`;\n}\nfunction genSlot(el, state) {\n    const slotName = el.slotName || '\"default\"';\n    const children = genChildren(el, state);\n    let res = `_t(${slotName}${children ? `,function(){return ${children}}` : ''}`;\n    const attrs = el.attrs || el.dynamicAttrs\n        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(attr => ({\n            // slot props are camelized\n            name: camelize(attr.name),\n            value: attr.value,\n            dynamic: attr.dynamic\n        })))\n        : null;\n    const bind = el.attrsMap['v-bind'];\n    if ((attrs || bind) && !children) {\n        res += `,null`;\n    }\n    if (attrs) {\n        res += `,${attrs}`;\n    }\n    if (bind) {\n        res += `${attrs ? '' : ',null'},${bind}`;\n    }\n    return res + ')';\n}\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent(componentName, el, state) {\n    const children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return `_c(${componentName},${genData(el, state)}${children ? `,${children}` : ''})`;\n}\nfunction genProps(props) {\n    let staticProps = ``;\n    let dynamicProps = ``;\n    for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        const value = transformSpecialNewlines(prop.value);\n        if (prop.dynamic) {\n            dynamicProps += `${prop.name},${value},`;\n        }\n        else {\n            staticProps += `\"${prop.name}\":${value},`;\n        }\n    }\n    staticProps = `{${staticProps.slice(0, -1)}}`;\n    if (dynamicProps) {\n        return `_d(${staticProps},[${dynamicProps.slice(0, -1)}])`;\n    }\n    else {\n        return staticProps;\n    }\n}\n// #3895, #4268\nfunction transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nconst prohibitedKeywordRE = new RegExp('\\\\b' +\n    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n        'super,throw,while,yield,delete,export,import,return,switch,default,' +\n        'extends,finally,continue,debugger,function,arguments')\n        .split(',')\n        .join('\\\\b|\\\\b') +\n    '\\\\b');\n// these unary operators should not be used as property/method names\nconst unaryOperatorsRE = new RegExp('\\\\b' +\n    'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') +\n    '\\\\s*\\\\([^\\\\)]*\\\\)');\n// strip strings in expressions\nconst stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n// detect problematic expressions in a template\nfunction detectErrors(ast, warn) {\n    if (ast) {\n        checkNode(ast, warn);\n    }\n}\nfunction checkNode(node, warn) {\n    if (node.type === 1) {\n        for (const name in node.attrsMap) {\n            if (dirRE.test(name)) {\n                const value = node.attrsMap[name];\n                if (value) {\n                    const range = node.rawAttrsMap[name];\n                    if (name === 'v-for') {\n                        checkFor(node, `v-for=\"${value}\"`, warn, range);\n                    }\n                    else if (name === 'v-slot' || name[0] === '#') {\n                        checkFunctionParameterExpression(value, `${name}=\"${value}\"`, warn, range);\n                    }\n                    else if (onRE.test(name)) {\n                        checkEvent(value, `${name}=\"${value}\"`, warn, range);\n                    }\n                    else {\n                        checkExpression(value, `${name}=\"${value}\"`, warn, range);\n                    }\n                }\n            }\n        }\n        if (node.children) {\n            for (let i = 0; i < node.children.length; i++) {\n                checkNode(node.children[i], warn);\n            }\n        }\n    }\n    else if (node.type === 2) {\n        checkExpression(node.expression, node.text, warn, node);\n    }\n}\nfunction checkEvent(exp, text, warn, range) {\n    const stripped = exp.replace(stripStringRE, '');\n    const keywordMatch = stripped.match(unaryOperatorsRE);\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n        warn(`avoid using JavaScript unary operator as property name: ` +\n            `\"${keywordMatch[0]}\" in expression ${text.trim()}`, range);\n    }\n    checkExpression(exp, text, warn, range);\n}\nfunction checkFor(node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\nfunction checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n        try {\n            new Function(`var ${ident}=_`);\n        }\n        catch (e) {\n            warn(`invalid ${type} \"${ident}\" in expression: ${text.trim()}`, range);\n        }\n    }\n}\nfunction checkExpression(exp, text, warn, range) {\n    try {\n        new Function(`return ${exp}`);\n    }\n    catch (e) {\n        const keywordMatch = exp\n            .replace(stripStringRE, '')\n            .match(prohibitedKeywordRE);\n        if (keywordMatch) {\n            warn(`avoid using JavaScript keyword as property name: ` +\n                `\"${keywordMatch[0]}\"\\n  Raw expression: ${text.trim()}`, range);\n        }\n        else {\n            warn(`invalid expression: ${e.message} in\\n\\n` +\n                `    ${exp}\\n\\n` +\n                `  Raw expression: ${text.trim()}\\n`, range);\n        }\n    }\n}\nfunction checkFunctionParameterExpression(exp, text, warn, range) {\n    try {\n        new Function(exp, '');\n    }\n    catch (e) {\n        warn(`invalid function parameter expression: ${e.message} in\\n\\n` +\n            `    ${exp}\\n\\n` +\n            `  Raw expression: ${text.trim()}\\n`, range);\n    }\n}\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    const lines = source.split(/\\r?\\n/);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count += lines[i].length + 1;\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                res.push(`${j + 1}${repeat(` `, 3 - String(j + 1).length)}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - lineLength) + 1;\n                    const length = end > count ? lineLength - pad : end - start;\n                    res.push(`   |  ` + repeat(` `, pad) + repeat(`^`, length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.min(end - count, lineLength);\n                        res.push(`   |  ` + repeat(`^`, length));\n                    }\n                    count += lineLength + 1;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\nfunction repeat(str, n) {\n    let result = '';\n    if (n > 0) {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // eslint-disable-line\n            if (n & 1)\n                result += str;\n            n >>>= 1;\n            if (n <= 0)\n                break;\n            str += str;\n        }\n    }\n    return result;\n}\n\nfunction createFunction(code, errors) {\n    try {\n        return new Function(code);\n    }\n    catch (err) {\n        errors.push({ err, code });\n        return noop;\n    }\n}\nfunction createCompileToFunctionFn(compile) {\n    const cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n        options = extend({}, options);\n        const warn = options.warn || warn$2;\n        delete options.warn;\n        /* istanbul ignore if */\n        {\n            // detect possible CSP restriction\n            try {\n                new Function('return 1');\n            }\n            catch (e) {\n                if (e.toString().match(/unsafe-eval|CSP/)) {\n                    warn('It seems you are using the standalone build of Vue.js in an ' +\n                        'environment with Content Security Policy that prohibits unsafe-eval. ' +\n                        'The template compiler cannot work in this environment. Consider ' +\n                        'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n                        'templates into render functions.');\n                }\n            }\n        }\n        // check cache\n        const key = options.delimiters\n            ? String(options.delimiters) + template\n            : template;\n        if (cache[key]) {\n            return cache[key];\n        }\n        // compile\n        const compiled = compile(template, options);\n        // check compilation errors/tips\n        {\n            if (compiled.errors && compiled.errors.length) {\n                if (options.outputSourceRange) {\n                    compiled.errors.forEach(e => {\n                        warn(`Error compiling template:\\n\\n${e.msg}\\n\\n` +\n                            generateCodeFrame(template, e.start, e.end), vm);\n                    });\n                }\n                else {\n                    warn(`Error compiling template:\\n\\n${template}\\n\\n` +\n                        compiled.errors.map(e => `- ${e}`).join('\\n') +\n                        '\\n', vm);\n                }\n            }\n            if (compiled.tips && compiled.tips.length) {\n                if (options.outputSourceRange) {\n                    compiled.tips.forEach(e => tip(e.msg, vm));\n                }\n                else {\n                    compiled.tips.forEach(msg => tip(msg, vm));\n                }\n            }\n        }\n        // turn code into functions\n        const res = {};\n        const fnGenErrors = [];\n        res.render = createFunction(compiled.render, fnGenErrors);\n        res.staticRenderFns = compiled.staticRenderFns.map(code => {\n            return createFunction(code, fnGenErrors);\n        });\n        // check function generation errors.\n        // this should only happen if there is a bug in the compiler itself.\n        // mostly for codegen development use\n        /* istanbul ignore if */\n        {\n            if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n                warn(`Failed to generate render function:\\n\\n` +\n                    fnGenErrors\n                        .map(({ err, code }) => `${err.toString()} in\\n\\n${code}\\n`)\n                        .join('\\n'), vm);\n            }\n        }\n        return (cache[key] = res);\n    };\n}\n\nfunction createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n        function compile(template, options) {\n            const finalOptions = Object.create(baseOptions);\n            const errors = [];\n            const tips = [];\n            let warn = (msg, range, tip) => {\n                (tip ? tips : errors).push(msg);\n            };\n            if (options) {\n                if (options.outputSourceRange) {\n                    // $flow-disable-line\n                    const leadingSpaceLength = template.match(/^\\s*/)[0].length;\n                    warn = (msg, range, tip) => {\n                        const data = typeof msg === 'string' ? { msg } : msg;\n                        if (range) {\n                            if (range.start != null) {\n                                data.start = range.start + leadingSpaceLength;\n                            }\n                            if (range.end != null) {\n                                data.end = range.end + leadingSpaceLength;\n                            }\n                        }\n                        (tip ? tips : errors).push(data);\n                    };\n                }\n                // merge custom modules\n                if (options.modules) {\n                    finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n                }\n                // merge custom directives\n                if (options.directives) {\n                    finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n                }\n                // copy other options\n                for (const key in options) {\n                    if (key !== 'modules' && key !== 'directives') {\n                        finalOptions[key] = options[key];\n                    }\n                }\n            }\n            finalOptions.warn = warn;\n            const compiled = baseCompile(template.trim(), finalOptions);\n            {\n                detectErrors(compiled.ast, warn);\n            }\n            compiled.errors = errors;\n            compiled.tips = tips;\n            return compiled;\n        }\n        return {\n            compile,\n            compileToFunctions: createCompileToFunctionFn(compile)\n        };\n    };\n}\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nconst createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    const ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n        optimize(ast, options);\n    }\n    const code = generate(ast, options);\n    return {\n        ast,\n        render: code.render,\n        staticRenderFns: code.staticRenderFns\n    };\n});\n\nconst { compile, compileToFunctions } = createCompiler(baseOptions);\n\n// check whether current browser encodes a char inside attribute values\nlet div;\nfunction getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? `<a href=\"\\n\"/>` : `<div a=\"\\n\"/>`;\n    return div.innerHTML.indexOf('&#10;') > 0;\n}\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nconst shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nconst shouldDecodeNewlinesForHref = inBrowser\n    ? getShouldDecode(true)\n    : false;\n\nconst idToTemplate = cached(id => {\n    const el = query(id);\n    return el && el.innerHTML;\n});\nconst mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n        warn$2(`Do not mount Vue to <html> or <body> - mount to normal elements instead.`);\n        return this;\n    }\n    const options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n        let template = options.template;\n        if (template) {\n            if (typeof template === 'string') {\n                if (template.charAt(0) === '#') {\n                    template = idToTemplate(template);\n                    /* istanbul ignore if */\n                    if (!template) {\n                        warn$2(`Template element not found or is empty: ${options.template}`, this);\n                    }\n                }\n            }\n            else if (template.nodeType) {\n                template = template.innerHTML;\n            }\n            else {\n                {\n                    warn$2('invalid template option:' + template, this);\n                }\n                return this;\n            }\n        }\n        else if (el) {\n            // @ts-expect-error\n            template = getOuterHTML(el);\n        }\n        if (template) {\n            /* istanbul ignore if */\n            if (config.performance && mark) {\n                mark('compile');\n            }\n            const { render, staticRenderFns } = compileToFunctions(template, {\n                outputSourceRange: true,\n                shouldDecodeNewlines,\n                shouldDecodeNewlinesForHref,\n                delimiters: options.delimiters,\n                comments: options.comments\n            }, this);\n            options.render = render;\n            options.staticRenderFns = staticRenderFns;\n            /* istanbul ignore if */\n            if (config.performance && mark) {\n                mark('compile end');\n                measure(`vue ${this._name} compile`, 'compile', 'compile end');\n            }\n        }\n    }\n    return mount.call(this, el, hydrating);\n};\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML(el) {\n    if (el.outerHTML) {\n        return el.outerHTML;\n    }\n    else {\n        const container = document.createElement('div');\n        container.appendChild(el.cloneNode(true));\n        return container.innerHTML;\n    }\n}\nVue.compile = compileToFunctions;\n\n// export type EffectScheduler = (...args: any[]) => any\n/**\n * @internal since we are not exposing this in Vue 2, it's used only for\n * internal testing.\n */\nfunction effect(fn, scheduler) {\n    const watcher = new Watcher(currentInstance, fn, noop, {\n        sync: true\n    });\n    if (scheduler) {\n        watcher.update = () => {\n            scheduler(() => watcher.run());\n        };\n    }\n}\n\nextend(Vue, vca);\nVue.effect = effect;\n\nmodule.exports = Vue;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"./node_modules/webpack/buildin/global.js\"), __webpack_require__(\"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5kZXYuanM/ZTg3YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLGlDQUFpQyxJQUFJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1EQUFtRDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtCQUFrQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xELDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFD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RSxhQUFhLGdCQUFnQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQXFEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxLQUFLLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxXQUFXO0FBQ1g7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixLQUFLO0FBQ3JGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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eEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQSx1QkFBdUIsMkNBQTJDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUJBQXFCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLEdBQUcsK0JBQStCLFlBQVk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTLEdBQUcsS0FBSztBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxLQUFLLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxLQUFLLElBQUksRUFBRSxpQ0FBaUM7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssSUFBSSxPQUFPLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssNkJBQTZCLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLLHlCQUF5QixLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxxQ0FBcUMsK0JBQStCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0MscUJBQXFCLG9CQUFvQjtBQUN6QyxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0EsK0JBQStCLG9CQUFvQixHQUFHLEVBQUUsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sR0FBRyxXQUFXO0FBQ3RDO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxJQUFJLFFBQVEsSUFBSSxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPLFlBQVksTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU8sWUFBWSxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xELGVBQWUsTUFBTSxHQUFHLGFBQWE7QUFDckM7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixxQkFBcUIsTUFBTSxHQUFHLGlCQUFpQjtBQUMvQyx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBLDZCQUE2QixpQkFBaUIsS0FBSyxrQkFBa0IsRUFBRTtBQUN2RSxnQ0FBZ0M7QUFDaEMsbUJBQW1CLG1EQUFtRDtBQUN0RSx5QkFBeUI7QUFDekIsMEJBQTBCLFVBQVUsOENBQThDLEVBQUU7QUFDcEYsY0FBYyxXQUFXLHNFQUFzRSxFQUFFO0FBQ2pHLFVBQVUsS0FBSyxFQUFFLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DLGlDQUFpQyxNQUFNLEdBQUcsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGtCQUFrQjtBQUNuRSwwQkFBMEIsNkNBQTZDO0FBQ3ZFLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRCxjQUFjLEtBQUssR0FBRyxxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRLElBQUksTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsS0FBSztBQUN6RDtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1Qix5QkFBeUIsS0FBSztBQUM5Qiw2QkFBNkIsS0FBSztBQUNsQyx1QkFBdUIsS0FBSztBQUM1Qix5QkFBeUIsS0FBSztBQUM5Qiw2QkFBNkIsS0FBSztBQUNsQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxTkFBcU47QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuY29tbW9uLmRldi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjcuMTRcbiAqIChjKSAyMDE0LTIwMjIgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4vLyBUaGVzZSBoZWxwZXJzIHByb2R1Y2UgYmV0dGVyIFZNIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG5mdW5jdGlvbiBpc1VuZGVmKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0RlZih2KSB7XG4gICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNUcnVlKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzRmFsc2Uodikge1xuICAgIHJldHVybiB2ID09PSBmYWxzZTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlLlxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIG9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gdG9SYXdUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59XG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuZnVuY3Rpb24gaXNSZWdFeHAodikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCh2YWwpIHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gICAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbCk7XG59XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gICAgcmV0dXJuIChpc0RlZih2YWwpICYmXG4gICAgICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbFxuICAgICAgICA/ICcnXG4gICAgICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XG59XG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbCkge1xuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn1cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiBtYXBbdmFsXTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbmNvbnN0IGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xuY29uc3QgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSQyKGFyciwgaXRlbSkge1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgaWYgKGxlbikge1xuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHRoZSBvbmx5IC8gbGFzdCBpdGVtXG4gICAgICAgIGlmIChpdGVtID09PSBhcnJbbGVuIC0gMV0pIHtcbiAgICAgICAgICAgIGFyci5sZW5ndGggPSBsZW4gLSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQoZm4pIHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZEZuKHN0cikge1xuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gICAgfTtcbn1cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVkKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcbn0pO1xuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVkKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn0pO1xuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQoZm4sIGN0eCkge1xuICAgIGZ1bmN0aW9uIGJvdW5kRm4oYSkge1xuICAgICAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxcbiAgICAgICAgICAgID8gbCA+IDFcbiAgICAgICAgICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICAgICAgICA6IGZuLmNhbGwoY3R4KTtcbiAgICB9XG4gICAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICAgIHJldHVybiBib3VuZEZuO1xufVxuZnVuY3Rpb24gbmF0aXZlQmluZChmbiwgY3R4KSB7XG4gICAgcmV0dXJuIGZuLmJpbmQoY3R4KTtcbn1cbi8vIEB0cy1leHBlY3QtZXJyb3IgYmluZCBjYW5ub3QgYmUgYHVuZGVmaW5lZGBcbmNvbnN0IGJpbmQkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID8gbmF0aXZlQmluZCA6IHBvbHlmaWxsQmluZDtcbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQodG8sIF9mcm9tKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gX2Zyb20pIHtcbiAgICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0bztcbn1cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QoYXJyKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSkge1xuICAgICAgICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKS5cbiAqL1xuZnVuY3Rpb24gbm9vcChhLCBiLCBjKSB7IH1cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xuY29uc3Qgbm8gPSAoYSwgYiwgYykgPT4gZmFsc2U7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xuY29uc3QgaWRlbnRpdHkgPSAoXykgPT4gXztcbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMShtb2R1bGVzKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgICAgLnJlZHVjZSgoa2V5cywgbSkgPT4ge1xuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKTtcbiAgICB9LCBbXSlcbiAgICAgICAgLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgICBjb25zdCBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgICAgICAgY29uc3QgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgYS5ldmVyeSgoZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlzQS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzI3BvbHlmaWxsXG5mdW5jdGlvbiBoYXNDaGFuZ2VkKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4geCA9PT0gMCAmJiAxIC8geCAhPT0gMSAvIHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geCA9PT0geCB8fCB5ID09PSB5O1xuICAgIH1cbn1cblxuY29uc3QgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuY29uc3QgQVNTRVRfVFlQRVMgPSBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZmlsdGVyJ107XG5jb25zdCBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJyxcbiAgICAnZXJyb3JDYXB0dXJlZCcsXG4gICAgJ3NlcnZlclByZWZldGNoJyxcbiAgICAncmVuZGVyVHJhY2tlZCcsXG4gICAgJ3JlbmRlclRyaWdnZXJlZCdcbl07XG5cbnZhciBjb25maWcgPSB7XG4gICAgLyoqXG4gICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAgICovXG4gICAgc2lsZW50OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgICAqL1xuICAgIHByb2R1Y3Rpb25UaXA6IHRydWUsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICAgKi9cbiAgICBkZXZ0b29sczogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAgICovXG4gICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAgICovXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxuICAgIC8qKlxuICAgICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgICAqL1xuICAgIHdhcm5IYW5kbGVyOiBudWxsLFxuICAgIC8qKlxuICAgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgICAqL1xuICAgIGlnbm9yZWRFbGVtZW50czogW10sXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZFRhZzogbm8sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIGlzUmVzZXJ2ZWRBdHRyOiBubyxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICAgKi9cbiAgICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgbXVzdFVzZVByb3A6IG5vLFxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgICAqIFRoaXMgd2lsbCBzaWduaWZpY2FudGx5IHJlZHVjZSBwZXJmb3JtYW5jZSBpZiBzZXQgdG8gZmFsc2UuXG4gICAgICovXG4gICAgYXN5bmM6IHRydWUsXG4gICAgLyoqXG4gICAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICAgKi9cbiAgICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufTtcblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG5jb25zdCB1bmljb2RlUmVnRXhwID0gL2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQvO1xuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgICBjb25zdCBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NWY7XG59XG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbmNvbnN0IGJhaWxSRSA9IG5ldyBSZWdFeHAoYFteJHt1bmljb2RlUmVnRXhwLnNvdXJjZX0uJF9cXFxcZF1gKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG59XG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuY29uc3QgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbmNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbmNvbnN0IGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG5jb25zdCBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcblVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG5jb25zdCBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG5VQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xuY29uc3QgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG4vLyBAdHMtZXhwZWN0LWVycm9yIGZpcmVib3ggc3VwcG9ydFxuY29uc3QgbmF0aXZlV2F0Y2ggPSB7fS53YXRjaDtcbmxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxufVxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxubGV0IF9pc1NlcnZlcjtcbmNvbnN0IGlzU2VydmVyUmVuZGVyaW5nID0gKCkgPT4ge1xuICAgIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICAgICAgX2lzU2VydmVyID1cbiAgICAgICAgICAgICAgICBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzU2VydmVyO1xufTtcbi8vIGRldGVjdCBkZXZ0b29sc1xuY29uc3QgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUoQ3Rvcikge1xuICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKTtcbn1cbmNvbnN0IGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmXG4gICAgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5sZXQgX1NldDsgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgICBfU2V0ID0gU2V0O1xufVxuZWxzZSB7XG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICAgIF9TZXQgPSBjbGFzcyBTZXQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBoYXMoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBhZGQoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuLyoqXG4gKiBUaGlzIGlzIGV4cG9zZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB2MyAoZS5nLiBzb21lIGZ1bmN0aW9ucyBpbiBWdWVVc2VcbiAqIHJlbGllcyBvbiBpdCkuIERvIG5vdCB1c2UgdGhpcyBpbnRlcm5hbGx5LCBqdXN0IHVzZSBgY3VycmVudEluc3RhbmNlYC5cbiAqXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgdHlwZSBkZWNsYXJhdGlvbiBiZWNhdXNlIGl0IHJlbGllc1xuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRJbnN0YW5jZSgpIHtcbiAgICByZXR1cm4gY3VycmVudEluc3RhbmNlICYmIHsgcHJveHk6IGN1cnJlbnRJbnN0YW5jZSB9O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudEluc3RhbmNlKHZtID0gbnVsbCkge1xuICAgIGlmICghdm0pXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2UuX3Njb3BlLm9mZigpO1xuICAgIGN1cnJlbnRJbnN0YW5jZSA9IHZtO1xuICAgIHZtICYmIHZtLl9zY29wZS5vbigpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBWTm9kZSB7XG4gICAgY29uc3RydWN0b3IodGFnLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgZWxtLCBjb250ZXh0LCBjb21wb25lbnRPcHRpb25zLCBhc3luY0ZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5lbG0gPSBlbG07XG4gICAgICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgICAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZ2V0IGNoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9XG59XG5jb25zdCBjcmVhdGVFbXB0eVZOb2RlID0gKHRleHQgPSAnJykgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgICBub2RlLnRleHQgPSB0ZXh0O1xuICAgIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbm9kZTtcbn07XG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSk7XG59XG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSkge1xuICAgIGNvbnN0IGNsb25lZCA9IG5ldyBWTm9kZSh2bm9kZS50YWcsIHZub2RlLmRhdGEsIFxuICAgIC8vICM3OTc1XG4gICAgLy8gY2xvbmUgY2hpbGRyZW4gYXJyYXkgdG8gYXZvaWQgbXV0YXRpbmcgb3JpZ2luYWwgaW4gY2FzZSBvZiBjbG9uaW5nXG4gICAgLy8gYSBjaGlsZC5cbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLCB2bm9kZS50ZXh0LCB2bm9kZS5lbG0sIHZub2RlLmNvbnRleHQsIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsIHZub2RlLmFzeW5jRmFjdG9yeSk7XG4gICAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gICAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gICAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICAgIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gICAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICAgIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gICAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xvbmVkO1xufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cbmxldCBpbml0UHJveHk7XG57XG4gICAgY29uc3QgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKCdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LCcgK1xuICAgICAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICAgICk7XG4gICAgY29uc3Qgd2Fybk5vblByZXNlbnQgPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgICAgd2FybiQyKGBQcm9wZXJ0eSBvciBtZXRob2QgXCIke2tleX1cIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IGAgK1xuICAgICAgICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsIHRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCB3YXJuUmVzZXJ2ZWRQcmVmaXggPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgICAgd2FybiQyKGBQcm9wZXJ0eSBcIiR7a2V5fVwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcIiRkYXRhLiR7a2V5fVwiIGJlY2F1c2UgYCArXG4gICAgICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscy4gJyArXG4gICAgICAgICAgICAnU2VlOiBodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLCB0YXJnZXQpO1xuICAgIH07XG4gICAgY29uc3QgaGFzUHJveHkgPSB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgY29uc3QgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgICAgIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoYEF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLiR7a2V5fWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoYXNIYW5kbGVyID0ge1xuICAgICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJlxuICAgICAgICAgICAgICAgICAgICAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgICAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0SGFuZGxlciA9IHtcbiAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKVxuICAgICAgICAgICAgICAgICAgICB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkodm0pIHtcbiAgICAgICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA/IGdldEhhbmRsZXIgOiBoYXNIYW5kbGVyO1xuICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmxldCB1aWQkMiA9IDA7XG5jb25zdCBwZW5kaW5nQ2xlYW51cERlcHMgPSBbXTtcbmNvbnN0IGNsZWFudXBEZXBzID0gKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZ0NsZWFudXBEZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlcCA9IHBlbmRpbmdDbGVhbnVwRGVwc1tpXTtcbiAgICAgICAgZGVwLnN1YnMgPSBkZXAuc3Vicy5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgZGVwLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHBlbmRpbmdDbGVhbnVwRGVwcy5sZW5ndGggPSAwO1xufTtcbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIERlcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIHBlbmRpbmcgc3VicyBjbGVhbnVwXG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZCA9IHVpZCQyKys7XG4gICAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgIH1cbiAgICBhZGRTdWIoc3ViKSB7XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gICAgfVxuICAgIHJlbW92ZVN1YihzdWIpIHtcbiAgICAgICAgLy8gIzEyNjk2IGRlcHMgd2l0aCBtYXNzaXZlIGFtb3VudCBvZiBzdWJzY3JpYmVycyBhcmUgZXh0cmVtZWx5IHNsb3cgdG9cbiAgICAgICAgLy8gY2xlYW4gdXAgaW4gQ2hyb21pdW1cbiAgICAgICAgLy8gdG8gd29ya2Fyb3VuZCB0aGlzLCB3ZSB1bnNldCB0aGUgc3ViIGZvciBub3csIGFuZCBjbGVhciB0aGVtIG9uXG4gICAgICAgIC8vIG5leHQgc2NoZWR1bGVyIGZsdXNoLlxuICAgICAgICB0aGlzLnN1YnNbdGhpcy5zdWJzLmluZGV4T2Yoc3ViKV0gPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcGVuZGluZ0NsZWFudXBEZXBzLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVwZW5kKGluZm8pIHtcbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGluZm8gJiYgRGVwLnRhcmdldC5vblRyYWNrKSB7XG4gICAgICAgICAgICAgICAgRGVwLnRhcmdldC5vblRyYWNrKE9iamVjdC5hc3NpZ24oeyBlZmZlY3Q6IERlcC50YXJnZXQgfSwgaW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeShpbmZvKSB7XG4gICAgICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN1YnMuZmlsdGVyKHMgPT4gcyk7XG4gICAgICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAgICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAgICAgICAvLyBvcmRlclxuICAgICAgICAgICAgc3Vicy5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gc3Vic1tpXTtcbiAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgc3ViLm9uVHJpZ2dlciAmJlxuICAgICAgICAgICAgICAgICAgICBzdWIub25UcmlnZ2VyKE9iamVjdC5hc3NpZ24oeyBlZmZlY3Q6IHN1YnNbaV0gfSwgaW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuY29uc3QgdGFyZ2V0U3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5mdW5jdGlvbiBwb3BUYXJnZXQoKSB7XG4gICAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrW3RhcmdldFN0YWNrLmxlbmd0aCAtIDFdO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmNvbnN0IGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5jb25zdCBtZXRob2RzVG9QYXRjaCA9IFtcbiAgICAncHVzaCcsXG4gICAgJ3BvcCcsXG4gICAgJ3NoaWZ0JyxcbiAgICAndW5zaGlmdCcsXG4gICAgJ3NwbGljZScsXG4gICAgJ3NvcnQnLFxuICAgICdyZXZlcnNlJ1xuXTtcbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICAgIGNvbnN0IG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBjb25zdCBvYiA9IHRoaXMuX19vYl9fO1xuICAgICAgICBsZXQgaW5zZXJ0ZWQ7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnRlZClcbiAgICAgICAgICAgIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XG4gICAgICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICAgICAge1xuICAgICAgICAgICAgb2IuZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheSBtdXRhdGlvblwiIC8qIFRyaWdnZXJPcFR5cGVzLkFSUkFZX01VVEFUSU9OICovLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICBrZXk6IG1ldGhvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn0pO1xuXG5jb25zdCBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuY29uc3QgTk9fSU5JSVRJQUxfVkFMVUUgPSB7fTtcbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbmxldCBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyh2YWx1ZSkge1xuICAgIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cbi8vIHNzciBtb2NrIGRlcFxuY29uc3QgbW9ja0RlcCA9IHtcbiAgICBub3RpZnk6IG5vb3AsXG4gICAgZGVwZW5kOiBub29wLFxuICAgIGFkZFN1Yjogbm9vcCxcbiAgICByZW1vdmVTdWI6IG5vb3Bcbn07XG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG5jbGFzcyBPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNoYWxsb3cgPSBmYWxzZSwgbW9jayA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zaGFsbG93ID0gc2hhbGxvdztcbiAgICAgICAgdGhpcy5tb2NrID0gbW9jaztcbiAgICAgICAgLy8gdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgICAgIHRoaXMuZGVwID0gbW9jayA/IG1vY2tEZXAgOiBuZXcgRGVwKCk7XG4gICAgICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgICAgIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghbW9jaykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQcm90bykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fX3Byb3RvX18gPSBhcnJheU1ldGhvZHM7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXlLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJyYXlLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmKHZhbHVlLCBrZXksIGFycmF5TWV0aG9kc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hhbGxvdykge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgICAgICAgICAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAgICAgICAgICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUodmFsdWUsIGtleSwgTk9fSU5JSVRJQUxfVkFMVUUsIHVuZGVmaW5lZCwgc2hhbGxvdywgbW9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAgICovXG4gICAgb2JzZXJ2ZUFycmF5KHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBvYnNlcnZlKHZhbHVlW2ldLCBmYWxzZSwgdGhpcy5tb2NrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGhlbHBlcnNcbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWUsIHNoYWxsb3csIHNzck1vY2tSZWFjdGl2aXR5KSB7XG4gICAgaWYgKHZhbHVlICYmIGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX29iX187XG4gICAgfVxuICAgIGlmIChzaG91bGRPYnNlcnZlICYmXG4gICAgICAgIChzc3JNb2NrUmVhY3Rpdml0eSB8fCAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkgJiZcbiAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuX192X3NraXAgLyogUmVhY3RpdmVGbGFncy5TS0lQICovICYmXG4gICAgICAgICFpc1JlZih2YWx1ZSkgJiZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmVyKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSk7XG4gICAgfVxufVxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwsIGN1c3RvbVNldHRlciwgc2hhbGxvdywgbW9jaykge1xuICAgIGNvbnN0IGRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gICAgY29uc3QgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICAgIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJlxuICAgICAgICAodmFsID09PSBOT19JTklJVElBTF9WQUxVRSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xuICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICB9XG4gICAgbGV0IGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCwgZmFsc2UsIG1vY2spO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwLmRlcGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG9iaixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzUmVmKHZhbHVlKSAmJiAhc2hhbGxvdyA/IHZhbHVlLnZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIobmV3VmFsKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgICAgICBpZiAoIWhhc0NoYW5nZWQodmFsdWUsIG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNoYWxsb3cgJiYgaXNSZWYodmFsdWUpICYmICFpc1JlZihuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudmFsdWUgPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsLCBmYWxzZSwgbW9jayk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG9iaixcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZXA7XG59XG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgIGlmICgoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpKSB7XG4gICAgICAgIHdhcm4kMihgQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogJHt0YXJnZXR9YCk7XG4gICAgfVxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgd2FybiQyKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7a2V5fVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9iID0gdGFyZ2V0Ll9fb2JfXztcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgICAgICAvLyB3aGVuIG1vY2tpbmcgZm9yIFNTUiwgYXJyYXkgbWV0aG9kcyBhcmUgbm90IGhpamFja2VkXG4gICAgICAgIGlmIChvYiAmJiAhb2Iuc2hhbGxvdyAmJiBvYi5tb2NrKSB7XG4gICAgICAgICAgICBvYnNlcnZlKHZhbCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgd2FybiQyKCdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgICAgICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJyk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmICghb2IpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGRlZmluZVJlYWN0aXZlKG9iLnZhbHVlLCBrZXksIHZhbCwgdW5kZWZpbmVkLCBvYi5zaGFsbG93LCBvYi5tb2NrKTtcbiAgICB7XG4gICAgICAgIG9iLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8sXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiB2YWwsXG4gICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZGVsKHRhcmdldCwga2V5KSB7XG4gICAgaWYgKChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSkpIHtcbiAgICAgICAgd2FybiQyKGBDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAke3RhcmdldH1gKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvYiA9IHRhcmdldC5fX29iX187XG4gICAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgICAgIHdhcm4kMignQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgd2FybiQyKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7a2V5fVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIW9iKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAge1xuICAgICAgICBvYi5kZXAubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6IFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5KHZhbHVlKSB7XG4gICAgZm9yIChsZXQgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZSA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoZSAmJiBlLl9fb2JfXykge1xuICAgICAgICAgICAgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KGUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gICAgbWFrZVJlYWN0aXZlKHRhcmdldCwgZmFsc2UpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcbiAqIGxldmVsIHByb3BlcnRpZXMgYXJlIHJlYWN0aXZlLiBJdCBhbHNvIGRvZXMgbm90IGF1dG8tdW53cmFwIHJlZnMgKGV2ZW4gYXQgdGhlXG4gKiByb290IGxldmVsKS5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd1JlYWN0aXZlKHRhcmdldCkge1xuICAgIG1ha2VSZWFjdGl2ZSh0YXJnZXQsIHRydWUpO1xuICAgIGRlZih0YXJnZXQsIFwiX192X2lzU2hhbGxvd1wiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfU0hBTExPVyAqLywgdHJ1ZSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG1ha2VSZWFjdGl2ZSh0YXJnZXQsIHNoYWxsb3cpIHtcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXG4gICAgaWYgKCFpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgQXZvaWQgdXNpbmcgQXJyYXkgYXMgcm9vdCB2YWx1ZSBmb3IgJHtzaGFsbG93ID8gYHNoYWxsb3dSZWFjdGl2ZSgpYCA6IGByZWFjdGl2ZSgpYH0gYXMgaXQgY2Fubm90IGJlIHRyYWNrZWQgaW4gd2F0Y2goKSBvciB3YXRjaEVmZmVjdCgpLiBVc2UgJHtzaGFsbG93ID8gYHNoYWxsb3dSZWYoKWAgOiBgcmVmKClgfSBpbnN0ZWFkLiBUaGlzIGlzIGEgVnVlLTItb25seSBsaW1pdGF0aW9uLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdPYiA9IHRhcmdldCAmJiB0YXJnZXQuX19vYl9fO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nT2IgJiYgZXhpc3RpbmdPYi5zaGFsbG93ICE9PSBzaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBUYXJnZXQgaXMgYWxyZWFkeSBhICR7ZXhpc3RpbmdPYi5zaGFsbG93ID8gYGAgOiBgbm9uLWB9c2hhbGxvdyByZWFjdGl2ZSBvYmplY3QsIGFuZCBjYW5ub3QgYmUgY29udmVydGVkIHRvICR7c2hhbGxvdyA/IGBgIDogYG5vbi1gfXNoYWxsb3cuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2IgPSBvYnNlcnZlKHRhcmdldCwgc2hhbGxvdywgaXNTZXJ2ZXJSZW5kZXJpbmcoKSAvKiBzc3IgbW9jayByZWFjdGl2aXR5ICovKTtcbiAgICAgICAgaWYgKCFvYikge1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvblR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFjdGl2ZSBjb2xsZWN0aW9uIHR5cGVzIHN1Y2ggYXMgTWFwIG9yIFNldC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcbiAgICBpZiAoaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dKTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fb2JfXyk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX192X2lzU2hhbGxvdyk7XG59XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fdl9pc1JlYWRvbmx5KTtcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICAgIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICAgIC8vIG5vbi1leHRlbnNpYmxlIG9iamVjdHMgd29uJ3QgYmUgb2JzZXJ2ZWQgYW55d2F5XG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqLywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGVjdGlvblR5cGUodmFsdWUpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdNYXAnIHx8IHR5cGUgPT09ICdXZWFrTWFwJyB8fCB0eXBlID09PSAnU2V0JyB8fCB0eXBlID09PSAnV2Vha1NldCcpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBSZWZGbGFnID0gYF9fdl9pc1JlZmA7XG5mdW5jdGlvbiBpc1JlZihyKSB7XG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gcmVmJDEodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVmID0ge307XG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XG4gICAgZGVmKHJlZiwgXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovLCBzaGFsbG93KTtcbiAgICBkZWYocmVmLCAnZGVwJywgZGVmaW5lUmVhY3RpdmUocmVmLCAndmFsdWUnLCByYXdWYWx1ZSwgbnVsbCwgc2hhbGxvdywgaXNTZXJ2ZXJSZW5kZXJpbmcoKSkpO1xuICAgIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xuICAgIGlmICghcmVmLmRlcCkge1xuICAgICAgICB3YXJuJDIoYHJlY2VpdmVkIG9iamVjdCBpcyBub3QgYSB0cmlnZ2VyYWJsZSByZWYuYCk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgcmVmLmRlcCAmJlxuICAgICAgICAgICAgcmVmLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLFxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XG59XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgICBpZiAoaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFdpdGhSZWZzO1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3RXaXRoUmVmcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgb2JqZWN0V2l0aFJlZnMsIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBwcm94eVdpdGhSZWZVbndyYXAodGFyZ2V0LCBzb3VyY2UsIGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAoaXNSZWYodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYiA9IHZhbCAmJiB2YWwuX19vYl9fO1xuICAgICAgICAgICAgICAgIGlmIChvYilcbiAgICAgICAgICAgICAgICAgICAgb2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICAgIGNvbnN0IGRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHtcbiAgICAgICAge1xuICAgICAgICAgICAgZGVwLmRlcGVuZCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCAoKSA9PiB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZWYgPSB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICAgICAgc2V0KG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xuICAgIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gICAgaWYgKCFpc1JlYWN0aXZlKG9iamVjdCkpIHtcbiAgICAgICAgd2FybiQyKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgIGlmIChpc1JlZih2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcbiAgICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCByYXdUb1JlYWRvbmx5RmxhZyA9IGBfX3ZfcmF3VG9SZWFkb25seWA7XG5jb25zdCByYXdUb1NoYWxsb3dSZWFkb25seUZsYWcgPSBgX192X3Jhd1RvU2hhbGxvd1JlYWRvbmx5YDtcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFkb25seSh0YXJnZXQsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgc2hhbGxvdykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYFZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhZG9ubHkgYXJyYXlzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWRvbmx5IGNvbGxlY3Rpb24gdHlwZXMgc3VjaCBhcyBNYXAgb3IgU2V0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFkb25seTogJHt0eXBlb2YgdGFyZ2V0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpKSB7XG4gICAgICAgIHdhcm4kMihgVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCBjcmVhdGluZyByZWFkb25seSBwcm94eSBmb3Igbm9uLWV4dGVuc2libGUgb2JqZWN0LmApO1xuICAgIH1cbiAgICAvLyBhbHJlYWR5IGEgcmVhZG9ubHkgb2JqZWN0XG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyBhbHJlYWR5IGhhcyBhIHJlYWRvbmx5IHByb3h5XG4gICAgY29uc3QgZXhpc3RpbmdGbGFnID0gc2hhbGxvdyA/IHJhd1RvU2hhbGxvd1JlYWRvbmx5RmxhZyA6IHJhd1RvUmVhZG9ubHlGbGFnO1xuICAgIGNvbnN0IGV4aXN0aW5nUHJveHkgPSB0YXJnZXRbZXhpc3RpbmdGbGFnXTtcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKTtcbiAgICBkZWYodGFyZ2V0LCBleGlzdGluZ0ZsYWcsIHByb3h5KTtcbiAgICBkZWYocHJveHksIFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovLCB0cnVlKTtcbiAgICBkZWYocHJveHksIFwiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovLCB0YXJnZXQpO1xuICAgIGlmIChpc1JlZih0YXJnZXQpKSB7XG4gICAgICAgIGRlZihwcm94eSwgUmVmRmxhZywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzaGFsbG93IHx8IGlzU2hhbGxvdyh0YXJnZXQpKSB7XG4gICAgICAgIGRlZihwcm94eSwgXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmluZVJlYWRvbmx5UHJvcGVydHkocHJveHksIHRhcmdldCwga2V5c1tpXSwgc2hhbGxvdyk7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGRlZmluZVJlYWRvbmx5UHJvcGVydHkocHJveHksIHRhcmdldCwga2V5LCBzaGFsbG93KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBzaGFsbG93IHx8ICFpc1BsYWluT2JqZWN0KHZhbCkgPyB2YWwgOiByZWFkb25seSh2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICB3YXJuJDIoYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtrZXl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxuICogcmV0dXJuZWQgcHJvcGVydGllcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd1JlYWRvbmx5KHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFkb25seSh0YXJnZXQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykge1xuICAgIGxldCBnZXR0ZXI7XG4gICAgbGV0IHNldHRlcjtcbiAgICBjb25zdCBvbmx5R2V0dGVyID0gaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpO1xuICAgIGlmIChvbmx5R2V0dGVyKSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcbiAgICAgICAgc2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdhcm4kMignV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gICAgfVxuICAgIGNvbnN0IHdhdGNoZXIgPSBpc1NlcnZlclJlbmRlcmluZygpXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IG5ldyBXYXRjaGVyKGN1cnJlbnRJbnN0YW5jZSwgZ2V0dGVyLCBub29wLCB7IGxhenk6IHRydWUgfSk7XG4gICAgaWYgKHdhdGNoZXIgJiYgZGVidWdPcHRpb25zKSB7XG4gICAgICAgIHdhdGNoZXIub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XG4gICAgfVxuICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgLy8gc29tZSBsaWJzIHJlbHkgb24gdGhlIHByZXNlbmNlIGVmZmVjdCBmb3IgY2hlY2tpbmcgY29tcHV0ZWQgcmVmc1xuICAgICAgICAvLyBmcm9tIG5vcm1hbCByZWZzLCBidXQgdGhlIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIGVmZmVjdDogd2F0Y2hlcixcbiAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0Lm9uVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiBEZXAudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgICAgICBzZXR0ZXIobmV3VmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XG4gICAgZGVmKHJlZiwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIG9ubHlHZXR0ZXIpO1xuICAgIHJldHVybiByZWY7XG59XG5cbmxldCBtYXJrO1xubGV0IG1lYXN1cmU7XG57XG4gICAgY29uc3QgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBlcmYgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwZXJmLm1hcmsgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBwZXJmLmNsZWFyTWVhc3VyZXMpIHtcbiAgICAgICAgbWFyayA9IHRhZyA9PiBwZXJmLm1hcmsodGFnKTtcbiAgICAgICAgbWVhc3VyZSA9IChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSA9PiB7XG4gICAgICAgICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAgICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNvbnN0IG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKChuYW1lKSA9PiB7XG4gICAgY29uc3QgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICBjb25zdCBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICAgIG5hbWUgPSBvbmNlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gICAgY29uc3QgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gICAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBvbmNlLFxuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBwYXNzaXZlXG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyKCkge1xuICAgICAgICBjb25zdCBmbnMgPSBpbnZva2VyLmZucztcbiAgICAgICAgaWYgKGlzQXJyYXkoZm5zKSkge1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzLCB2bSwgYHYtb24gaGFuZGxlcmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIGB2LW9uIGhhbmRsZXJgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pIHtcbiAgICBsZXQgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICAgIGZvciAobmFtZSBpbiBvbikge1xuICAgICAgICBjdXIgPSBvbltuYW1lXTtcbiAgICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgICAgICAgIHdhcm4kMihgSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcIiR7ZXZlbnQubmFtZX1cIjogZ290IGAgKyBTdHJpbmcoY3VyKSwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICAgICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgICAgICAgIHJlbW92ZShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rKGRlZiwgaG9va0tleSwgaG9vaykge1xuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICAgIH1cbiAgICBsZXQgaW52b2tlcjtcbiAgICBjb25zdCBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWRIb29rKCkge1xuICAgICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAgICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAgICAgcmVtb3ZlJDIoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgICAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gICAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpIHtcbiAgICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICAgIGNvbnN0IHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IHsgYXR0cnMsIHByb3BzIH0gPSBkYXRhO1xuICAgIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGtleUluTG93ZXJDYXNlICYmIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpcChgUHJvcCBcIiR7a2V5SW5Mb3dlckNhc2V9XCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRhZyBpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyB8fCBDdG9yKX0sIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgIFwiJHtrZXl9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgcHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHthbHRLZXl9XCIgaW5zdGVhZCBvZiBcIiR7a2V5fVwiLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tQcm9wKHJlcywgaGFzaCwga2V5LCBhbHRLZXksIHByZXNlcnZlKSB7XG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn1cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICAgIDogaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgICAgICAvLyAgbmVzdGVkXG4gICAgICAgIGlmIChpc0FycmF5KGMpKSB7XG4gICAgICAgICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgYCR7bmVzdGVkSW5kZXggfHwgJyd9XyR7aX1gKTtcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjWzBdLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGMua2V5ID0gYF9fdmxpc3Qke25lc3RlZEluZGV4fV8ke2l9X19gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBTSU1QTEVfTk9STUFMSVpFID0gMTtcbmNvbnN0IEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemUpIHtcbiAgICBpZiAoaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgICAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgICAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgICAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSk7XG59XG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSkge1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLl9fb2JfXykpIHtcbiAgICAgICAgd2FybiQyKGBBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfVxcbmAgKyAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgICAgIHRhZyA9IGRhdGEuaXM7XG4gICAgfVxuICAgIGlmICghdGFnKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpKSB7XG4gICAgICAgIHdhcm4kMignQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikgJiYgaXNGdW5jdGlvbihjaGlsZHJlblswXSkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgICAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgfVxuICAgIGxldCB2bm9kZSwgbnM7XG4gICAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBDdG9yO1xuICAgICAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgICAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgICAgICAgIGlmIChpc0RlZihkYXRhKSAmJlxuICAgICAgICAgICAgICAgIGlzRGVmKGRhdGEubmF0aXZlT24pICYmXG4gICAgICAgICAgICAgICAgZGF0YS50YWcgIT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBUaGUgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBpcyBvbmx5IHZhbGlkIG9uIGNvbXBvbmVudHMgYnV0IGl0IHdhcyB1c2VkIG9uIDwke3RhZ30+LmAsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiZcbiAgICAgICAgICAgIGlzRGVmKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpKSB7XG4gICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgICAgICAgIHZub2RlID0gbmV3IFZOb2RlKHRhZywgZGF0YSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZub2RlKSkge1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgICAgICBpZiAoaXNEZWYobnMpKVxuICAgICAgICAgICAgYXBwbHlOUyh2bm9kZSwgbnMpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpXG4gICAgICAgICAgICByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU5TKHZub2RlLCBucywgZm9yY2UpIHtcbiAgICB2bm9kZS5ucyA9IG5zO1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICAgICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmXG4gICAgICAgICAgICAgICAgKGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSkge1xuICAgIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0KHZhbCwgcmVuZGVyKSB7XG4gICAgbGV0IHJldCA9IG51bGwsIGksIGwsIGtleXMsIGtleTtcbiAgICBpZiAoaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEZWYocmV0KSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgcmV0Ll9pc1ZMaXN0ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QobmFtZSwgZmFsbGJhY2tSZW5kZXIsIHByb3BzLCBiaW5kT2JqZWN0KSB7XG4gICAgY29uc3Qgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gICAgbGV0IG5vZGVzO1xuICAgIGlmIChzY29wZWRTbG90Rm4pIHtcbiAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlcyA9XG4gICAgICAgICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZmFsbGJhY2tSZW5kZXIpID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGVzID1cbiAgICAgICAgICAgIHRoaXMuJHNsb3RzW25hbWVdIHx8XG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZmFsbGJhY2tSZW5kZXIpID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIoaWQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoKGV4cGVjdCwgYWN0dWFsKSB7XG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0KSkge1xuICAgICAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWw7XG4gICAgfVxufVxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzKGV2ZW50S2V5Q29kZSwga2V5LCBidWlsdEluS2V5Q29kZSwgZXZlbnRLZXlOYW1lLCBidWlsdEluS2V5TmFtZSkge1xuICAgIGNvbnN0IG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXk7XG4gICAgfVxuICAgIHJldHVybiBldmVudEtleUNvZGUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMoZGF0YSwgdGFnLCB2YWx1ZSwgYXNQcm9wLCBpc1N5bmMpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMigndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhhc2g7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbltgdXBkYXRlOiR7a2V5fWBdID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMoaW5kZXgsIGlzSW5Gb3IpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gICAgbGV0IHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAgIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAgIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICAgIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gICAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSwgdGhpcy5fYywgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICAgICk7XG4gICAgbWFya1N0YXRpYyQxKHRyZWUsIGBfX3N0YXRpY19fJHtpbmRleH1gLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UodHJlZSwgaW5kZXgsIGtleSkge1xuICAgIG1hcmtTdGF0aWMkMSh0cmVlLCBgX19vbmNlX18ke2luZGV4fSR7a2V5ID8gYF8ke2tleX1gIDogYGB9YCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBtYXJrU3RhdGljJDEodHJlZSwga2V5LCBpc09uY2UpIHtcbiAgICBpZiAoaXNBcnJheSh0cmVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIGAke2tleX1fJHtpfWAsIGlzT25jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZShub2RlLCBrZXksIGlzT25jZSkge1xuICAgIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICAgIG5vZGUua2V5ID0ga2V5O1xuICAgIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzKGRhdGEsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMigndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvbiA9IChkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzKGZucywgcmVzLCBcbi8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuaGFzRHluYW1pY0tleXMsIGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGZuc1tpXTtcbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzbG90KSB7XG4gICAgICAgICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgICAgIHJlcy4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIGhlbHBlciB0byBwcm9jZXNzIGR5bmFtaWMga2V5cyBmb3IgZHluYW1pYyBhcmd1bWVudHMgaW4gdi1iaW5kIGFuZCB2LW9uLlxuZnVuY3Rpb24gYmluZER5bmFtaWNLZXlzKGJhc2VPYmosIHZhbHVlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbnVsbCBpcyBhIHNwZWNpYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICAgICAgICB3YXJuJDIoYEludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6ICR7a2V5fWAsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlT2JqO1xufVxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyKHZhbHVlLCBzeW1ib2wpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzKHRhcmdldCkge1xuICAgIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICAgIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICAgIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICAgIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gICAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICAgIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gICAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICAgIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gICAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gICAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XG4gICAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCkge1xuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHNsb3RzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgICAgICAgIGRhdGEgJiZcbiAgICAgICAgICAgIGRhdGEuc2xvdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2xvdHMpIHtcbiAgICAgICAgaWYgKHNsb3RzW25hbWVdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzbG90c1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xvdHM7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2Uobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJztcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyKG5vZGUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG5vdCByZWFsbHkgYm9vbGVhbiB0eXBlXG4gICAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyhvd25lclZtLCBzY29wZWRTbG90cywgbm9ybWFsU2xvdHMsIHByZXZTY29wZWRTbG90cykge1xuICAgIGxldCByZXM7XG4gICAgY29uc3QgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgICBjb25zdCBpc1N0YWJsZSA9IHNjb3BlZFNsb3RzID8gISFzY29wZWRTbG90cy4kc3RhYmxlIDogIWhhc05vcm1hbFNsb3RzO1xuICAgIGNvbnN0IGtleSA9IHNjb3BlZFNsb3RzICYmIHNjb3BlZFNsb3RzLiRrZXk7XG4gICAgaWYgKCFzY29wZWRTbG90cykge1xuICAgICAgICByZXMgPSB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NvcGVkU2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgICAgIHJldHVybiBzY29wZWRTbG90cy5fbm9ybWFsaXplZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdGFibGUgJiZcbiAgICAgICAgcHJldlNjb3BlZFNsb3RzICYmXG4gICAgICAgIHByZXZTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICAgICAga2V5ID09PSBwcmV2U2NvcGVkU2xvdHMuJGtleSAmJlxuICAgICAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAgICAgIXByZXZTY29wZWRTbG90cy4kaGFzTm9ybWFsKSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAgICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgICAgIHJldHVybiBwcmV2U2NvcGVkU2xvdHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgIGlmIChzY29wZWRTbG90c1trZXldICYmIGtleVswXSAhPT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVTY29wZWRTbG90KG93bmVyVm0sIG5vcm1hbFNsb3RzLCBrZXksIHNjb3BlZFNsb3RzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxTbG90cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVzKSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAgIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxuICAgIGlmIChzY29wZWRTbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNjb3BlZFNsb3RzKSkge1xuICAgICAgICBzY29wZWRTbG90cy5fbm9ybWFsaXplZCA9IHJlcztcbiAgICB9XG4gICAgZGVmKHJlcywgJyRzdGFibGUnLCBpc1N0YWJsZSk7XG4gICAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICAgIGRlZihyZXMsICckaGFzTm9ybWFsJywgaGFzTm9ybWFsU2xvdHMpO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KHZtLCBub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcbiAgICAgICAgbGV0IHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgICByZXMgPVxuICAgICAgICAgICAgcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFpc0FycmF5KHJlcylcbiAgICAgICAgICAgICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSByZXMgJiYgcmVzWzBdO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcbiAgICAgICAgcmV0dXJuIHJlcyAmJlxuICAgICAgICAgICAgKCF2bm9kZSB8fFxuICAgICAgICAgICAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHZub2RlLmlzQ29tbWVudCAmJiAhaXNBc3luY1BsYWNlaG9sZGVyKHZub2RlKSkpIC8vICM5NjU4LCAjMTAzOTFcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHJlcztcbiAgICB9O1xuICAgIC8vIHRoaXMgaXMgYSBzbG90IHVzaW5nIHRoZSBuZXcgdi1zbG90IHN5bnRheCB3aXRob3V0IHNjb3BlLiBhbHRob3VnaCBpdCBpc1xuICAgIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAgIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICAgIGlmIChmbi5wcm94eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICAgIHJldHVybiAoKSA9PiBzbG90c1trZXldO1xufVxuXG5mdW5jdGlvbiBpbml0U2V0dXAodm0pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgY29uc3Qgc2V0dXAgPSBvcHRpb25zLnNldHVwO1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgICBjb25zdCBjdHggPSAodm0uX3NldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dCh2bSkpO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIG51bGwsIFt2bS5fcHJvcHMgfHwgc2hhbGxvd1JlYWN0aXZlKHt9KSwgY3R4XSwgdm0sIGBzZXR1cGApO1xuICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHNldHVwUmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBvcHRpb25zLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gYmluZGluZ3NcbiAgICAgICAgICAgIGlmIChzZXR1cFJlc3VsdCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xuICAgICAgICAgICAgICAgICAgICBgcmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bS5fc2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgICAgICAgICAgLy8gX19zZmMgaW5kaWNhdGVzIGNvbXBpbGVkIGJpbmRpbmdzIGZyb20gPHNjcmlwdCBzZXR1cD5cbiAgICAgICAgICAgIGlmICghc2V0dXBSZXN1bHQuX19zZmMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXR1cFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlXaXRoUmVmVW53cmFwKHZtLCBzZXR1cFJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMihgQXZvaWQgdXNpbmcgdmFyaWFibGVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgaW4gc2V0dXAoKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGV4cG9zZWQgZm9yIGNvbXBpbGVkIHJlbmRlciBmblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gKHZtLl9zZXR1cFByb3h5ID0ge30pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdfX3NmYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgc2V0dXBSZXN1bHQsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2FybiQyKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dCh2bSkge1xuICAgIGxldCBleHBvc2VDYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICBpZiAoIXZtLl9hdHRyc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSAodm0uX2F0dHJzUHJveHkgPSB7fSk7XG4gICAgICAgICAgICAgICAgZGVmKHByb3h5LCAnX3ZfYXR0cl9wcm94eScsIHRydWUpO1xuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFByb3h5KHByb3h5LCB2bS4kYXR0cnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRhdHRycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZtLl9hdHRyc1Byb3h5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgbGlzdGVuZXJzKCkge1xuICAgICAgICAgICAgaWYgKCF2bS5fbGlzdGVuZXJzUHJveHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eSA9ICh2bS5fbGlzdGVuZXJzUHJveHkgPSB7fSk7XG4gICAgICAgICAgICAgICAgc3luY1NldHVwUHJveHkocHJveHksIHZtLiRsaXN0ZW5lcnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRsaXN0ZW5lcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bS5fbGlzdGVuZXJzUHJveHk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzbG90cygpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0U2xvdHNQcm94eSh2bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQ6IGJpbmQkMSh2bS4kZW1pdCwgdm0pLFxuICAgICAgICBleHBvc2UoZXhwb3NlZCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChleHBvc2VDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gLCB2bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cG9zZUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwb3NlZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4cG9zZWQpLmZvckVhY2goa2V5ID0+IHByb3h5V2l0aFJlZlVud3JhcCh2bSwgZXhwb3NlZCwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gc3luY1NldHVwUHJveHkodG8sIGZyb20sIHByZXYsIGluc3RhbmNlLCB0eXBlKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICAgIGlmICghKGtleSBpbiB0bykpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVmaW5lUHJveHlBdHRyKHRvLCBrZXksIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tW2tleV0gIT09IHByZXZba2V5XSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG8pIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZGVmaW5lUHJveHlBdHRyKHByb3h5LCBrZXksIGluc3RhbmNlLCB0eXBlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbdHlwZV1ba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNsb3RzUHJveHkodm0pIHtcbiAgICBpZiAoIXZtLl9zbG90c1Byb3h5KSB7XG4gICAgICAgIHN5bmNTZXR1cFNsb3RzKCh2bS5fc2xvdHNQcm94eSA9IHt9KSwgdm0uJHNjb3BlZFNsb3RzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLl9zbG90c1Byb3h5O1xufVxuZnVuY3Rpb24gc3luY1NldHVwU2xvdHModG8sIGZyb20pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHRvKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRvW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xuICovXG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuLyoqXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXG4gKiBsZWdhY3kgVk5vZGUgdHlwZXNcbiAqL1xuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbi8qKlxuICogVnVlIDIgb25seVxuICogQGludGVybmFsIHVzZSBtYW51YWwgdHlwZSBkZWYgYmVjYXVzZSBwdWJsaWMgc2V0dXAgY29udGV4dCB0eXBlIHJlbGllcyBvblxuICogbGVnYWN5IFZOb2RlIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3RlbmVycygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmxpc3RlbmVycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybiQyKGB1c2VDb250ZXh0KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIH1cbiAgICBjb25zdCB2bSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICByZXR1cm4gdm0uX3NldHVwQ29udGV4dCB8fCAodm0uX3NldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dCh2bSkpO1xufVxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyBkZWZhdWx0IGRlY2xhcmF0aW9ucy4gSW1wb3J0ZWQgYnkgY29tcGlsZWQgY29kZVxuICogb25seS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGlzQXJyYXkocmF3KVxuICAgICAgICA/IHJhdy5yZWR1Y2UoKG5vcm1hbGl6ZWQsIHApID0+ICgobm9ybWFsaXplZFtwXSA9IHt9KSwgbm9ybWFsaXplZCksIHt9KVxuICAgICAgICA6IHJhdztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSkge1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybiQyKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFJlbmRlcih2bSkge1xuICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gICAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICBjb25zdCBwYXJlbnRWbm9kZSA9ICh2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZSk7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgY29uc3QgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgICB2bS4kc2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZVxuICAgICAgICA/IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHZtLiRwYXJlbnQsIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsIHZtLiRzbG90cylcbiAgICAgICAgOiBlbXB0eU9iamVjdDtcbiAgICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAgIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB2bS5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50JDEodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTtcbiAgICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdm0uJGNyZWF0ZUVsZW1lbnQgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCQxKHZtLCBhLCBiLCBjLCBkLCB0cnVlKTtcbiAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAgIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgICBjb25zdCBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCAocGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgKCkgPT4ge1xuICAgICAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuJDIoYCRhdHRycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsICgpID0+IHtcbiAgICAgICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybiQyKGAkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LmAsIHZtKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxufVxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5mdW5jdGlvbiByZW5kZXJNaXhpbihWdWUpIHtcbiAgICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICAgIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuICAgIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcyk7XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAgY29uc3QgeyByZW5kZXIsIF9wYXJlbnRWbm9kZSB9ID0gdm0uJG9wdGlvbnM7XG4gICAgICAgIGlmIChfcGFyZW50Vm5vZGUgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHModm0uJHBhcmVudCwgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsIHZtLiRzbG90cywgdm0uJHNjb3BlZFNsb3RzKTtcbiAgICAgICAgICAgIGlmICh2bS5fc2xvdHNQcm94eSkge1xuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFNsb3RzKHZtLl9zbG90c1Byb3h5LCB2bS4kc2NvcGVkU2xvdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAgICAgLy8gcmVuZGVyIHNlbGZcbiAgICAgICAgbGV0IHZub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVzZSBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgICAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGByZW5kZXJgKTtcbiAgICAgICAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyRXJyb3JgKTtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICAgICAgaWYgKGlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBwYXJlbnRcbiAgICAgICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlQ3Rvcihjb21wLCBiYXNlKSB7XG4gICAgaWYgKGNvbXAuX19lc01vZHVsZSB8fCAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XG4gICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBpc09iamVjdChjb21wKSA/IGJhc2UuZXh0ZW5kKGNvbXApIDogY29tcDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoZmFjdG9yeSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZykge1xuICAgIGNvbnN0IG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnIH07XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQoZmFjdG9yeSwgYmFzZUN0b3IpIHtcbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXA7XG4gICAgfVxuICAgIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZDtcbiAgICB9XG4gICAgY29uc3Qgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgaWYgKG93bmVyICYmIGlzRGVmKGZhY3Rvcnkub3duZXJzKSAmJiBmYWN0b3J5Lm93bmVycy5pbmRleE9mKG93bmVyKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICAgIH1cbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXA7XG4gICAgfVxuICAgIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgICAgIGNvbnN0IG93bmVycyA9IChmYWN0b3J5Lm93bmVycyA9IFtvd25lcl0pO1xuICAgICAgICBsZXQgc3luYyA9IHRydWU7XG4gICAgICAgIGxldCB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICBsZXQgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgb3duZXIuJG9uKCdob29rOmRlc3Ryb3llZCcsICgpID0+IHJlbW92ZSQyKG93bmVycywgb3duZXIpKTtcbiAgICAgICAgY29uc3QgZm9yY2VSZW5kZXIgPSAocmVuZGVyQ29tcGxldGVkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvd25lcnNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyTG9hZGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSBvbmNlKChyZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgICAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgICAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlamVjdCA9IG9uY2UocmVhc29uID0+IHtcbiAgICAgICAgICAgIHdhcm4kMihgRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAke1N0cmluZyhmYWN0b3J5KX1gICtcbiAgICAgICAgICAgICAgICAgICAgKHJlYXNvbiA/IGBcXG5SZWFzb246ICR7cmVhc29ufWAgOiAnJykpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYHRpbWVvdXQgKCR7cmVzLnRpbWVvdXR9bXMpYCApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nID8gZmFjdG9yeS5sb2FkaW5nQ29tcCA6IGZhY3RvcnkucmVzb2x2ZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkKGNoaWxkcmVuKSB7XG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudHModm0pIHtcbiAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gICAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gICAgY29uc3QgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgICB9XG59XG5sZXQgdGFyZ2V0JDE7XG5mdW5jdGlvbiBhZGQkMShldmVudCwgZm4pIHtcbiAgICB0YXJnZXQkMS4kb24oZXZlbnQsIGZuKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZSQxKGV2ZW50LCBmbikge1xuICAgIHRhcmdldCQxLiRvZmYoZXZlbnQsIGZuKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEoZXZlbnQsIGZuKSB7XG4gICAgY29uc3QgX3RhcmdldCA9IHRhcmdldCQxO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcbiAgICAgICAgY29uc3QgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycykge1xuICAgIHRhcmdldCQxID0gdm07XG4gICAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQkMSwgcmVtb3ZlJDEsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZtKTtcbiAgICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGV2ZW50c01peGluKFZ1ZSkge1xuICAgIGNvbnN0IGhvb2tSRSA9IC9eaG9vazovO1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGlmIChpc0FycmF5KGV2ZW50KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bTtcbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gb24oKSB7XG4gICAgICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICAgICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBvbi5mbiA9IGZuO1xuICAgICAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIC8vIGFsbFxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHZtO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdm0uJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZtO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgICAgIGNvbnN0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgICBpZiAoIWNicykge1xuICAgICAgICAgICAgcmV0dXJuIHZtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICAgIGxldCBjYjtcbiAgICAgICAgbGV0IGkgPSBjYnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjYiA9IGNic1tpXTtcbiAgICAgICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICAgICAgICAgIHRpcChgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNicykge1xuICAgICAgICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGBldmVudCBoYW5kbGVyIGZvciBcIiR7ZXZlbnR9XCJgO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bTtcbiAgICB9O1xufVxuXG5sZXQgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xubGV0IGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgICBjb25zdCBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlKHZtKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gICAgbGV0IHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgICB9XG4gICAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuICAgIHZtLiRjaGlsZHJlbiA9IFtdO1xuICAgIHZtLiRyZWZzID0ge307XG4gICAgdm0uX3Byb3ZpZGVkID0gcGFyZW50ID8gcGFyZW50Ll9wcm92aWRlZCA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICAgIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbihWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHByZXZFbCA9IHZtLiRlbDtcbiAgICAgICAgY29uc3QgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgICAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGVzXG4gICAgICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgICBpZiAocHJldkVsKSB7XG4gICAgICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgICAgIGxldCB3cmFwcGVyID0gdm07XG4gICAgICAgIHdoaWxlICh3cmFwcGVyICYmXG4gICAgICAgICAgICB3cmFwcGVyLiR2bm9kZSAmJlxuICAgICAgICAgICAgd3JhcHBlci4kcGFyZW50ICYmXG4gICAgICAgICAgICB3cmFwcGVyLiR2bm9kZSA9PT0gd3JhcHBlci4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgICAgICAgd3JhcHBlci4kcGFyZW50LiRlbCA9IHdyYXBwZXIuJGVsO1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXIuJHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgICAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgICAgICAgcmVtb3ZlJDIocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlYXJkb3duIHNjb3BlLiB0aGlzIGluY2x1ZGVzIGJvdGggdGhlIHJlbmRlciB3YXRjaGVyIGFuZCBvdGhlclxuICAgICAgICAvLyB3YXRjaGVycyBjcmVhdGVkXG4gICAgICAgIHZtLl9zY29wZS5zdG9wKCk7XG4gICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgICAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICAgICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgICAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgICAgICB2bS4kb2ZmKCk7XG4gICAgICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgICAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICAgICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCh2bSwgZWwsIGh5ZHJhdGluZykge1xuICAgIHZtLiRlbCA9IGVsO1xuICAgIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaW52YWxpZCB0eXBlXG4gICAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fFxuICAgICAgICAgICAgICAgIGVsKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKCdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4kMignRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlTW91bnQnKTtcbiAgICBsZXQgdXBkYXRlQ29tcG9uZW50O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdm0uX25hbWU7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHZtLl91aWQ7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtcGVyZi1zdGFydDoke2lkfWA7XG4gICAgICAgICAgICBjb25zdCBlbmRUYWcgPSBgdnVlLXBlcmYtZW5kOiR7aWR9YDtcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSByZW5kZXJgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgIG1lYXN1cmUoYHZ1ZSAke25hbWV9IHBhdGNoYCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgd2F0Y2hlck9wdGlvbnMgPSB7XG4gICAgICAgIGJlZm9yZSgpIHtcbiAgICAgICAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsSG9vayQxKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHtcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmFjayA9IGUgPT4gY2FsbEhvb2skMSh2bSwgJ3JlbmRlclRyYWNrZWQnLCBbZV0pO1xuICAgICAgICB3YXRjaGVyT3B0aW9ucy5vblRyaWdnZXIgPSBlID0+IGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmlnZ2VyZWQnLCBbZV0pO1xuICAgIH1cbiAgICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAgIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gICAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICAgIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHdhdGNoZXJPcHRpb25zLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XG4gICAgLy8gZmx1c2ggYnVmZmVyIGZvciBmbHVzaDogXCJwcmVcIiB3YXRjaGVycyBxdWV1ZWQgaW4gc2V0dXAoKVxuICAgIGNvbnN0IHByZVdhdGNoZXJzID0gdm0uX3ByZVdhdGNoZXJzO1xuICAgIGlmIChwcmVXYXRjaGVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZVdhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVXYXRjaGVyc1tpXS5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gICAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBjYWxsSG9vayQxKHZtLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm07XG59XG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCh2bSwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHBhcmVudFZub2RlLCByZW5kZXJDaGlsZHJlbikge1xuICAgIHtcbiAgICAgICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gICAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gICAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICAgIGNvbnN0IG5ld1Njb3BlZFNsb3RzID0gcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cztcbiAgICBjb25zdCBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgICBjb25zdCBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KSB8fFxuICAgICAgICAoIW5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5KSk7XG4gICAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAgIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICAgIGxldCBuZWVkc0ZvcmNlVXBkYXRlID0gISEocmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgICAgIGhhc0R5bmFtaWNTY29wZWRTbG90KTtcbiAgICBjb25zdCBwcmV2Vk5vZGUgPSB2bS4kdm5vZGU7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgICBpZiAodm0uX3Zub2RlKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgICB9XG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG4gICAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gICAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gICAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgICBjb25zdCBhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgaWYgKHZtLl9hdHRyc1Byb3h5KSB7XG4gICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBpZiBhdHRycyBhcmUgYWNjZXNzZWQgYW5kIGhhcyBjaGFuZ2VkIHNpbmNlIGl0IG1heSBiZVxuICAgICAgICAvLyBwYXNzZWQgdG8gYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAgIGlmIChzeW5jU2V0dXBQcm94eSh2bS5fYXR0cnNQcm94eSwgYXR0cnMsIChwcmV2Vk5vZGUuZGF0YSAmJiBwcmV2Vk5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3QsIHZtLCAnJGF0dHJzJykpIHtcbiAgICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZtLiRhdHRycyA9IGF0dHJzO1xuICAgIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgY29uc3QgcHJldkxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgaWYgKHZtLl9saXN0ZW5lcnNQcm94eSkge1xuICAgICAgICBzeW5jU2V0dXBQcm94eSh2bS5fbGlzdGVuZXJzUHJveHksIGxpc3RlbmVycywgcHJldkxpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgdm0sICckbGlzdGVuZXJzJyk7XG4gICAgfVxuICAgIHZtLiRsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBwcmV2TGlzdGVuZXJzKTtcbiAgICAvLyB1cGRhdGUgcHJvcHNcbiAgICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzO1xuICAgICAgICBjb25zdCBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICAgICAgICBjb25zdCBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgICB9XG4gICAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgICAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gICAge1xuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlKHZtKSB7XG4gICAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgICAgIGlmICh2bS5faW5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2FjdGl2YXRlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2skMSh2bSwgaG9vaywgYXJncywgc2V0Q29udGV4dCA9IHRydWUpIHtcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gICAgcHVzaFRhcmdldCgpO1xuICAgIGNvbnN0IHByZXYgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgc2V0Q29udGV4dCAmJiBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gICAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBhcmdzIHx8IG51bGwsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgICAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gICAgfVxuICAgIHNldENvbnRleHQgJiYgc2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICAgIHBvcFRhcmdldCgpO1xufVxuXG5jb25zdCBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5sZXQgaGFzID0ge307XG5sZXQgY2lyY3VsYXIgPSB7fTtcbmxldCB3YWl0aW5nID0gZmFsc2U7XG5sZXQgZmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpbmRleCQxID0gMDtcbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlKCkge1xuICAgIGluZGV4JDEgPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIGhhcyA9IHt9O1xuICAgIHtcbiAgICAgICAgY2lyY3VsYXIgPSB7fTtcbiAgICB9XG4gICAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG4vLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbi8vIGlmIHRoZSBwYWdlIGhhcyB0aG91c2FuZHMgb2YgZXZlbnQgbGlzdGVuZXJzLiBJbnN0ZWFkLCB3ZSB0YWtlIGEgdGltZXN0YW1wXG4vLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxubGV0IGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IDA7XG4vLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxubGV0IGdldE5vdyA9IERhdGUubm93O1xuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgICBjb25zdCBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICBpZiAocGVyZm9ybWFuY2UgJiZcbiAgICAgICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xuICAgICAgICAvLyBpZiB0aGUgZXZlbnQgdGltZXN0YW1wLCBhbHRob3VnaCBldmFsdWF0ZWQgQUZURVIgdGhlIERhdGUubm93KCksIGlzXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXIgdGltZXN0YW1wcyBhc1xuICAgICAgICAvLyB3ZWxsLlxuICAgICAgICBnZXROb3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG59XG5jb25zdCBzb3J0Q29tcGFyZUZuID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5wb3N0KSB7XG4gICAgICAgIGlmICghYi5wb3N0KVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGIucG9zdCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBhLmlkIC0gYi5pZDtcbn07XG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlKCkge1xuICAgIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICBsZXQgd2F0Y2hlciwgaWQ7XG4gICAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAgIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gICAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAgIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gICAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICAgIHF1ZXVlLnNvcnQoc29ydENvbXBhcmVGbik7XG4gICAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gICAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gICAgZm9yIChpbmRleCQxID0gMDsgaW5kZXgkMSA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgkMSsrKSB7XG4gICAgICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleCQxXTtcbiAgICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICAgICAgaGFzW2lkXSA9IG51bGw7XG4gICAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICAgICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgICAgICAgIHdhcm4kMignWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgK1xuICAgICAgICAgICAgICAgICAgICAod2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcIiR7d2F0Y2hlci5leHByZXNzaW9ufVwiYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLmApLCB3YXRjaGVyLnZtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gICAgY29uc3QgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgIGNvbnN0IHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuICAgIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICAgIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gICAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuICAgIGNsZWFudXBEZXBzKCk7XG4gICAgLy8gZGV2dG9vbCBob29rXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MocXVldWUpIHtcbiAgICBsZXQgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICAgICAgY29uc3Qgdm0gPSB3YXRjaGVyLnZtO1xuICAgICAgICBpZiAodm0gJiYgdm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICBjYWxsSG9vayQxKHZtLCAndXBkYXRlZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KHZtKSB7XG4gICAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAgIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MocXVldWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gICAgfVxufVxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICBjb25zdCBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3YXRjaGVyID09PSBEZXAudGFyZ2V0ICYmIHdhdGNoZXIubm9SZWN1cnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgICBsZXQgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID4gaW5kZXgkMSAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxufVxuXG5jb25zdCBXQVRDSEVSID0gYHdhdGNoZXJgO1xuY29uc3QgV0FUQ0hFUl9DQiA9IGAke1dBVENIRVJ9IGNhbGxiYWNrYDtcbmNvbnN0IFdBVENIRVJfR0VUVEVSID0gYCR7V0FUQ0hFUn0gZ2V0dGVyYDtcbmNvbnN0IFdBVENIRVJfQ0xFQU5VUCA9IGAke1dBVENIRVJ9IGNsZWFudXBgO1xuLy8gU2ltcGxlIGVmZmVjdC5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3Bvc3QnIH0pICkpO1xufVxuZnVuY3Rpb24gd2F0Y2hTeW5jRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSApKTtcbn1cbi8vIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzIHRvIHRyaWdnZXIgb24gdW5kZWZpbmVkIGluaXRpYWwgdmFsdWVzXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuJDIoYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgIH1cbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoID0gJ3ByZScsIG9uVHJhY2ssIG9uVHJpZ2dlciB9ID0gZW1wdHlPYmplY3QpIHtcbiAgICBpZiAoIWNiKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2FybiQyKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdhcm4kMihgd2F0Y2goKSBcImRlZXBcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xuICAgICAgICB3YXJuJDIoYEludmFsaWQgd2F0Y2ggc291cmNlOiAke3N9LiBBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgYCArXG4gICAgICAgICAgICBgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYCk7XG4gICAgfTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBjb25zdCBjYWxsID0gKGZuLCB0eXBlLCBhcmdzID0gbnVsbCkgPT4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm4sIG51bGwsIGFyZ3MsIGluc3RhbmNlLCB0eXBlKTtcbiAgICBsZXQgZ2V0dGVyO1xuICAgIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2UuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH07XG4gICAgICAgIGRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKHMgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocykpO1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHMsIFdBVENIRVJfR0VUVEVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm5JbnZhbGlkU291cmNlKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgLy8gZ2V0dGVyIHdpdGggY2JcbiAgICAgICAgICAgIGdldHRlciA9ICgpID0+IGNhbGwoc291cmNlLCBXQVRDSEVSX0dFVFRFUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGwoc291cmNlLCBXQVRDSEVSLCBbb25DbGVhbnVwXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoY2IgJiYgZGVlcCkge1xuICAgICAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xuICAgIH1cbiAgICBsZXQgY2xlYW51cDtcbiAgICBsZXQgb25DbGVhbnVwID0gKGZuKSA9PiB7XG4gICAgICAgIGNsZWFudXAgPSB3YXRjaGVyLm9uU3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbGwoZm4sIFdBVENIRVJfQ0xFQU5VUCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBpbiBTU1IgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXR1cCBhbiBhY3R1YWwgZWZmZWN0LCBhbmQgaXQgc2hvdWxkIGJlIG5vb3BcbiAgICAvLyB1bmxlc3MgaXQncyBlYWdlclxuICAgIGlmIChpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgYWxzbyBub3QgY2FsbCB0aGUgaW52YWxpZGF0ZSBjYWxsYmFjayAoKyBydW5uZXIgaXMgbm90IHNldCB1cClcbiAgICAgICAgb25DbGVhbnVwID0gbm9vcDtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgZ2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICBjYWxsKGNiLCBXQVRDSEVSX0NCLCBbXG4gICAgICAgICAgICAgICAgZ2V0dGVyKCksXG4gICAgICAgICAgICAgICAgaXNNdWx0aVNvdXJjZSA/IFtdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjdXJyZW50SW5zdGFuY2UsIGdldHRlciwgbm9vcCwge1xuICAgICAgICBsYXp5OiB0cnVlXG4gICAgfSk7XG4gICAgd2F0Y2hlci5ub1JlY3Vyc2UgPSAhY2I7XG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICAgIC8vIG92ZXJ3cml0ZSBkZWZhdWx0IHJ1blxuICAgIHdhdGNoZXIucnVuID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXdhdGNoZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB3YXRjaGVyLmdldCgpO1xuICAgICAgICAgICAgaWYgKGRlZXAgfHxcbiAgICAgICAgICAgICAgICBmb3JjZVRyaWdnZXIgfHxcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxuICAgICAgICAgICAgICAgICAgICA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsKGNiLCBXQVRDSEVSX0NCLCBbXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFID8gdW5kZWZpbmVkIDogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxuICAgICAgICAgICAgd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSB3YXRjaGVyLnJ1bjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xuICAgICAgICB3YXRjaGVyLnBvc3QgPSB0cnVlO1xuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9ICgpID0+IHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByZVxuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZSA9PT0gY3VycmVudEluc3RhbmNlICYmICFpbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlLXdhdGNoZXIgdHJpZ2dlcmVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGluc3RhbmNlLl9wcmVXYXRjaGVycyB8fCAoaW5zdGFuY2UuX3ByZVdhdGNoZXJzID0gW10pO1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIuaW5kZXhPZih3YXRjaGVyKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHdhdGNoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVXYXRjaGVyKHdhdGNoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB7XG4gICAgICAgIHdhdGNoZXIub25UcmFjayA9IG9uVHJhY2s7XG4gICAgICAgIHdhdGNoZXIub25UcmlnZ2VyID0gb25UcmlnZ2VyO1xuICAgIH1cbiAgICAvLyBpbml0aWFsIHJ1blxuICAgIGlmIChjYikge1xuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICB3YXRjaGVyLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSB3YXRjaGVyLmdldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcgJiYgaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuJG9uY2UoJ2hvb2s6bW91bnRlZCcsICgpID0+IHdhdGNoZXIuZ2V0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2F0Y2hlci5nZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH07XG59XG5cbmxldCBhY3RpdmVFZmZlY3RTY29wZTtcbmNsYXNzIEVmZmVjdFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID1cbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bihmbikge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4kMihgY2Fubm90IHJ1biBhbiBpbmFjdGl2ZSBlZmZlY3Qgc2NvcGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uKCkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBvZmYoKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIHN0b3AoZnJvbVBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCBpLCBsO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0udGVhcmRvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZXNbaV0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZXN0ZWQgc2NvcGUsIGRlcmVmZXJlbmNlIGZyb20gcGFyZW50IHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRldGFjaGVkICYmIHRoaXMucGFyZW50ICYmICFmcm9tUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICAgIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcmVjb3JkRWZmZWN0U2NvcGUoZWZmZWN0LCBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgICAgICBzY29wZS5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuJDIoYG9uU2NvcGVEaXNwb3NlKCkgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGVmZmVjdCBzY29wZWAgK1xuICAgICAgICAgICAgYCB0byBiZSBhc3NvY2lhdGVkIHdpdGguYCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICB7XG4gICAgICAgICAgICB3YXJuJDIoYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgIHJlc29sdmVQcm92aWRlZChjdXJyZW50SW5zdGFuY2UpW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlUHJvdmlkZWQodm0pIHtcbiAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcbiAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xuICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXG4gICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcbiAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxuICAgIGNvbnN0IGV4aXN0aW5nID0gdm0uX3Byb3ZpZGVkO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gdm0uJHBhcmVudCAmJiB2bS4kcGFyZW50Ll9wcm92aWRlZDtcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IGV4aXN0aW5nKSB7XG4gICAgICAgIHJldHVybiAodm0uX3Byb3ZpZGVkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxuICAgIC8vIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gIzI0MDBcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS4kcGFyZW50ICYmIGluc3RhbmNlLiRwYXJlbnQuX3Byb3ZpZGVkO1xuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XG4gICAgICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlKVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybiQyKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2FybiQyKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGludGVybmFsIHRoaXMgZnVuY3Rpb24gbmVlZHMgbWFudWFsIHB1YmxpYyB0eXBlIGRlY2xhcmF0aW9uIGJlY2F1c2UgaXQgcmVsaWVzXG4gKiBvbiBwcmV2aW91c2x5IG1hbnVhbGx5IGF1dGhvcmVkIHR5cGVzIGZyb20gVnVlIDJcbiAqL1xuZnVuY3Rpb24gaCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICB3YXJuJDIoYGdsb2JhbGx5IGltcG9ydGVkIGgoKSBjYW4gb25seSBiZSBpbnZva2VkIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlIGAgK1xuICAgICAgICAgICAgICAgIGBjb21wb25lbnQgaW5zdGFuY2UsIGUuZy4gc3luY2hyb25vdXNseSBpbiBhIGNvbXBvbmVudCdzIHJlbmRlciBvciBzZXR1cCBmdW5jdGlvbi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjdXJyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgMiwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pIHtcbiAgICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gICAgcHVzaFRhcmdldCgpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh2bSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZtO1xuICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICAgICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlciwgY29udGV4dCwgYXJncywgdm0sIGluZm8pIHtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgICAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgICAgICAgIHJlcy5jYXRjaChlID0+IGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgYCAoUHJvbWlzZS9hc3luYylgKSk7XG4gICAgICAgICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pIHtcbiAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKSB7XG4gICAge1xuICAgICAgICB3YXJuJDIoYEVycm9yIGluICR7aW5mb306IFwiJHtlcnIudG9TdHJpbmcoKX1cImAsIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5jb25zdCBjYWxsYmFja3MgPSBbXTtcbmxldCBwZW5kaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcygpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgY29uc3QgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbn1cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxubGV0IHRpbWVyRnVuYztcbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICBjb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgICAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgICAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgICAgaWYgKGlzSU9TKVxuICAgICAgICAgICAgc2V0VGltZW91dChub29wKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufVxuZWxzZSBpZiAoIWlzSUUgJiZcbiAgICB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXScpKSB7XG4gICAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufVxuZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgICB9O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbmV4dFRpY2soY2IsIGN0eCkge1xuICAgIGxldCBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgd2FybiQyKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2QgPSBjdXJyZW50SW5zdGFuY2VbbmFtZV07XG4gICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICB3YXJuJDIoYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICAgIGlmICghaW5Ccm93c2VyICYmICFmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgd2FybiQyKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXRjaFBvc3RFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGluc3RhbmNlLiRlbDtcbiAgICAgICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZSwgaW5zdGFuY2UuX3NldHVwUHJveHkpO1xuICAgICAgICBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIHYzLWNvbXBhdGlibGUgYXN5bmMgY29tcG9uZW50IEFQSS5cbiAqIEBpbnRlcm5hbCB0aGUgdHlwZSBpcyBtYW51YWxseSBkZWNsYXJlZCBpbiA8cm9vdD4vdHlwZXMvdjMtZGVmaW5lLWFzeW5jLWNvbXBvbmVudC5kLnRzXG4gKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBleGlzdGluZyBtYW51YWwgdHlwZXNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gZmFsc2UsIC8vIGluIFZ1ZSAzIGRlZmF1bHQgaXMgdHJ1ZVxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XG4gICAgaWYgKHN1c3BlbnNpYmxlKSB7XG4gICAgICAgIHdhcm4kMihgVGhlIHN1c3BlbnNpYmxiZSBvcHRpb24gZm9yIGFzeW5jIGNvbXBvbmVudHMgaXMgbm90IHN1cHBvcnRlZCBpbiBWdWUyLiBJdCBpcyBpZ25vcmVkLmApO1xuICAgIH1cbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIGxldCByZXRyaWVzID0gMDtcbiAgICBjb25zdCByZXRyeSA9ICgpID0+IHtcbiAgICAgICAgcmV0cmllcysrO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBsb2FkKCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgICAgICBsZXQgdGhpc1JlcXVlc3Q7XG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID1cbiAgICAgICAgICAgICAgICBsb2FkZXIoKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyRmFpbCA9ICgpID0+IHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1JlcXVlc3QgIT09IHBlbmRpbmdSZXF1ZXN0ICYmIHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJvcCBtb2R1bGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAmJiAhaXNPYmplY3QoY29tcCkgJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gbG9hZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZ0NvbXBvbmVudFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpZmVDeWNsZShob29rTmFtZSkge1xuICAgIHJldHVybiAoZm4sIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKGAke2Zvcm1hdE5hbWUoaG9va05hbWUpfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgYXNzb2NpYXRlZCB3aXRoLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5qZWN0SG9vayh0YXJnZXQsIGhvb2tOYW1lLCBmbik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE5hbWUobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnYmVmb3JlRGVzdHJveScpIHtcbiAgICAgICAgbmFtZSA9ICdiZWZvcmVVbm1vdW50JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgbmFtZSA9ICd1bm1vdW50ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gYG9uJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpfWA7XG59XG5mdW5jdGlvbiBpbmplY3RIb29rKGluc3RhbmNlLCBob29rTmFtZSwgZm4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UuJG9wdGlvbnM7XG4gICAgb3B0aW9uc1tob29rTmFtZV0gPSBtZXJnZUxpZmVjeWNsZUhvb2sob3B0aW9uc1tob29rTmFtZV0sIGZuKTtcbn1cbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZU1vdW50Jyk7XG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ21vdW50ZWQnKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlTGlmZUN5Y2xlKCdiZWZvcmVVcGRhdGUnKTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgndXBkYXRlZCcpO1xuY29uc3Qgb25CZWZvcmVVbm1vdW50ID0gY3JlYXRlTGlmZUN5Y2xlKCdiZWZvcmVEZXN0cm95Jyk7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZGVzdHJveWVkJyk7XG5jb25zdCBvbkFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnYWN0aXZhdGVkJyk7XG5jb25zdCBvbkRlYWN0aXZhdGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdkZWFjdGl2YXRlZCcpO1xuY29uc3Qgb25TZXJ2ZXJQcmVmZXRjaCA9IGNyZWF0ZUxpZmVDeWNsZSgnc2VydmVyUHJlZmV0Y2gnKTtcbmNvbnN0IG9uUmVuZGVyVHJhY2tlZCA9IGNyZWF0ZUxpZmVDeWNsZSgncmVuZGVyVHJhY2tlZCcpO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3JlbmRlclRyaWdnZXJlZCcpO1xuY29uc3QgaW5qZWN0RXJyb3JDYXB0dXJlZEhvb2sgPSBjcmVhdGVMaWZlQ3ljbGUoJ2Vycm9yQ2FwdHVyZWQnKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpbmplY3RFcnJvckNhcHR1cmVkSG9vayhob29rLCB0YXJnZXQpO1xufVxuXG4vKipcbiAqIE5vdGU6IGFsc28gdXBkYXRlIGRpc3QvdnVlLnJ1bnRpbWUubWpzIHdoZW4gYWRkaW5nIG5ldyBleHBvcnRzIHRvIHRoaXMgZmlsZS5cbiAqL1xuY29uc3QgdmVyc2lvbiA9ICcyLjcuMTQnO1xuLyoqXG4gKiBAaW50ZXJuYWwgdHlwZSBpcyBtYW51YWxseSBkZWNsYXJlZCBpbiA8cm9vdD4vdHlwZXMvdjMtZGVmaW5lLWNvbXBvbmVudC5kLnRzXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbnZhciB2Y2EgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgZGVmaW5lQ29tcG9uZW50OiBkZWZpbmVDb21wb25lbnQsXG4gIHJlZjogcmVmJDEsXG4gIHNoYWxsb3dSZWY6IHNoYWxsb3dSZWYsXG4gIGlzUmVmOiBpc1JlZixcbiAgdG9SZWY6IHRvUmVmLFxuICB0b1JlZnM6IHRvUmVmcyxcbiAgdW5yZWY6IHVucmVmLFxuICBwcm94eVJlZnM6IHByb3h5UmVmcyxcbiAgY3VzdG9tUmVmOiBjdXN0b21SZWYsXG4gIHRyaWdnZXJSZWY6IHRyaWdnZXJSZWYsXG4gIHJlYWN0aXZlOiByZWFjdGl2ZSxcbiAgaXNSZWFjdGl2ZTogaXNSZWFjdGl2ZSxcbiAgaXNSZWFkb25seTogaXNSZWFkb25seSxcbiAgaXNTaGFsbG93OiBpc1NoYWxsb3csXG4gIGlzUHJveHk6IGlzUHJveHksXG4gIHNoYWxsb3dSZWFjdGl2ZTogc2hhbGxvd1JlYWN0aXZlLFxuICBtYXJrUmF3OiBtYXJrUmF3LFxuICB0b1JhdzogdG9SYXcsXG4gIHJlYWRvbmx5OiByZWFkb25seSxcbiAgc2hhbGxvd1JlYWRvbmx5OiBzaGFsbG93UmVhZG9ubHksXG4gIGNvbXB1dGVkOiBjb21wdXRlZCxcbiAgd2F0Y2g6IHdhdGNoLFxuICB3YXRjaEVmZmVjdDogd2F0Y2hFZmZlY3QsXG4gIHdhdGNoUG9zdEVmZmVjdDogd2F0Y2hQb3N0RWZmZWN0LFxuICB3YXRjaFN5bmNFZmZlY3Q6IHdhdGNoU3luY0VmZmVjdCxcbiAgRWZmZWN0U2NvcGU6IEVmZmVjdFNjb3BlLFxuICBlZmZlY3RTY29wZTogZWZmZWN0U2NvcGUsXG4gIG9uU2NvcGVEaXNwb3NlOiBvblNjb3BlRGlzcG9zZSxcbiAgZ2V0Q3VycmVudFNjb3BlOiBnZXRDdXJyZW50U2NvcGUsXG4gIHByb3ZpZGU6IHByb3ZpZGUsXG4gIGluamVjdDogaW5qZWN0LFxuICBoOiBoLFxuICBnZXRDdXJyZW50SW5zdGFuY2U6IGdldEN1cnJlbnRJbnN0YW5jZSxcbiAgdXNlU2xvdHM6IHVzZVNsb3RzLFxuICB1c2VBdHRyczogdXNlQXR0cnMsXG4gIHVzZUxpc3RlbmVyczogdXNlTGlzdGVuZXJzLFxuICBtZXJnZURlZmF1bHRzOiBtZXJnZURlZmF1bHRzLFxuICBuZXh0VGljazogbmV4dFRpY2ssXG4gIHNldDogc2V0LFxuICBkZWw6IGRlbCxcbiAgdXNlQ3NzTW9kdWxlOiB1c2VDc3NNb2R1bGUsXG4gIHVzZUNzc1ZhcnM6IHVzZUNzc1ZhcnMsXG4gIGRlZmluZUFzeW5jQ29tcG9uZW50OiBkZWZpbmVBc3luY0NvbXBvbmVudCxcbiAgb25CZWZvcmVNb3VudDogb25CZWZvcmVNb3VudCxcbiAgb25Nb3VudGVkOiBvbk1vdW50ZWQsXG4gIG9uQmVmb3JlVXBkYXRlOiBvbkJlZm9yZVVwZGF0ZSxcbiAgb25VcGRhdGVkOiBvblVwZGF0ZWQsXG4gIG9uQmVmb3JlVW5tb3VudDogb25CZWZvcmVVbm1vdW50LFxuICBvblVubW91bnRlZDogb25Vbm1vdW50ZWQsXG4gIG9uQWN0aXZhdGVkOiBvbkFjdGl2YXRlZCxcbiAgb25EZWFjdGl2YXRlZDogb25EZWFjdGl2YXRlZCxcbiAgb25TZXJ2ZXJQcmVmZXRjaDogb25TZXJ2ZXJQcmVmZXRjaCxcbiAgb25SZW5kZXJUcmFja2VkOiBvblJlbmRlclRyYWNrZWQsXG4gIG9uUmVuZGVyVHJpZ2dlcmVkOiBvblJlbmRlclRyaWdnZXJlZCxcbiAgb25FcnJvckNhcHR1cmVkOiBvbkVycm9yQ2FwdHVyZWRcbn0pO1xuXG5jb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIF90cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgICBsZXQgaSwga2V5cztcbiAgICBjb25zdCBpc0EgPSBpc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fFxuICAgICAgICB2YWwuX192X3NraXAgLyogUmVhY3RpdmVGbGFncy5TS0lQICovIHx8XG4gICAgICAgIE9iamVjdC5pc0Zyb3plbih2YWwpIHx8XG4gICAgICAgIHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbC5fX29iX18pIHtcbiAgICAgICAgY29uc3QgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgICB9XG4gICAgaWYgKGlzQSkge1xuICAgICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZih2YWwpKSB7XG4gICAgICAgIF90cmF2ZXJzZSh2YWwudmFsdWUsIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSlcbiAgICAgICAgICAgIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICAgIH1cbn1cblxubGV0IHVpZCQxID0gMDtcbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgV2F0Y2hlciB7XG4gICAgY29uc3RydWN0b3Iodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zLCBpc1JlbmRlcldhdGNoZXIpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUodGhpcywgXG4gICAgICAgIC8vIGlmIHRoZSBhY3RpdmUgZWZmZWN0IHNjb3BlIGlzIG1hbnVhbGx5IGNyZWF0ZWQgKG5vdCBhIGNvbXBvbmVudCBzY29wZSksXG4gICAgICAgIC8vIHByaW9yaXRpemUgaXRcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgJiYgIWFjdGl2ZUVmZmVjdFNjb3BlLl92bVxuICAgICAgICAgICAgPyBhY3RpdmVFZmZlY3RTY29wZVxuICAgICAgICAgICAgOiB2bVxuICAgICAgICAgICAgICAgID8gdm0uX3Njb3BlXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKHRoaXMudm0gPSB2bSkgJiYgaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICAgICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICAgICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgICAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICAgICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYiA9IGNiO1xuICAgICAgICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucG9zdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCkgO1xuICAgICAgICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZXhwT3JGbikpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0dGVyID0gbm9vcDtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYEZhaWxlZCB3YXRjaGluZyBwYXRoOiBcIiR7ZXhwT3JGbn1cIiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIHB1c2hUYXJnZXQodGhpcyk7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzLnZtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYGdldHRlciBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgYWRkRGVwKGRlcCkge1xuICAgICAgICBjb25zdCBpZCA9IGRlcC5pZDtcbiAgICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhbnVwRGVwcygpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgICAgICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG1wID0gdGhpcy5kZXBJZHM7XG4gICAgICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gICAgICAgIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICAgICAgICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICAgICAgICB0bXAgPSB0aGlzLmRlcHM7XG4gICAgICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgICAgICAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICAgICAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0aGlzLmxhenkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgICAgICAgICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZGVlcCkge1xuICAgICAgICAgICAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGBjYWxsYmFjayBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcodGhpcy5jYiwgdGhpcy52bSwgW3ZhbHVlLCBvbGRWYWx1ZV0sIHRoaXMudm0sIGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAgICovXG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgICAqL1xuICAgIGRlcGVuZCgpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAgICovXG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZtICYmICF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZW1vdmUkMih0aGlzLnZtLl9zY29wZS5lZmZlY3RzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IG5vb3AsXG4gICAgc2V0OiBub29wXG59O1xuZnVuY3Rpb24gcHJveHkodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldO1xuICAgIH07XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgICAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cbmZ1bmN0aW9uIGluaXRTdGF0ZSh2bSkge1xuICAgIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgICBpZiAob3B0cy5wcm9wcylcbiAgICAgICAgaW5pdFByb3BzJDEodm0sIG9wdHMucHJvcHMpO1xuICAgIC8vIENvbXBvc2l0aW9uIEFQSVxuICAgIGluaXRTZXR1cCh2bSk7XG4gICAgaWYgKG9wdHMubWV0aG9kcylcbiAgICAgICAgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgICBpbml0RGF0YSh2bSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvYiA9IG9ic2VydmUoKHZtLl9kYXRhID0ge30pKTtcbiAgICAgICAgb2IgJiYgb2Iudm1Db3VudCsrO1xuICAgIH1cbiAgICBpZiAob3B0cy5jb21wdXRlZClcbiAgICAgICAgaW5pdENvbXB1dGVkJDEodm0sIG9wdHMuY29tcHV0ZWQpO1xuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdFByb3BzJDEodm0sIHByb3BzT3B0aW9ucykge1xuICAgIGNvbnN0IHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgICBjb25zdCBwcm9wcyA9ICh2bS5fcHJvcHMgPSBzaGFsbG93UmVhY3RpdmUoe30pKTtcbiAgICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAgIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICAgIGNvbnN0IGtleXMgPSAodm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW10pO1xuICAgIGNvbnN0IGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAgIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICAgIGlmICghaXNSb290KSB7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgXCIke2h5cGhlbmF0ZWRLZXl9XCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoYEF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgdmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXCIke2tleX1cImAsIHZtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgICAgICAgcHJveHkodm0sIGBfcHJvcHNgLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cbmZ1bmN0aW9uIGluaXREYXRhKHZtKSB7XG4gICAgbGV0IGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICAgIGRhdGEgPSB2bS5fZGF0YSA9IGlzRnVuY3Rpb24oZGF0YSkgPyBnZXREYXRhKGRhdGEsIHZtKSA6IGRhdGEgfHwge307XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgd2FybiQyKCdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly92Mi52dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJywgdm0pO1xuICAgIH1cbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGNvbnN0IHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gICAgY29uc3QgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICB3YXJuJDIoYFRoZSBkYXRhIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLmAsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICBwcm94eSh2bSwgYF9kYXRhYCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvYnNlcnZlIGRhdGFcbiAgICBjb25zdCBvYiA9IG9ic2VydmUoZGF0YSk7XG4gICAgb2IgJiYgb2Iudm1Db3VudCsrO1xufVxuZnVuY3Rpb24gZ2V0RGF0YShkYXRhLCB2bSkge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYGRhdGEoKWApO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBwb3BUYXJnZXQoKTtcbiAgICB9XG59XG5jb25zdCBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSh2bSwgY29tcHV0ZWQpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb25zdCB3YXRjaGVycyA9ICh2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gICAgY29uc3QgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIGNvbnN0IHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgICAgICBjb25zdCBnZXR0ZXIgPSBpc0Z1bmN0aW9uKHVzZXJEZWYpID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHdhcm4kMihgR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIuYCwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTU1IpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICAgICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciB8fCBub29wLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYFRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuYCwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodm0uJG9wdGlvbnMubWV0aG9kcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMubWV0aG9kcykge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgVGhlIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgbWV0aG9kLmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gICAgY29uc3Qgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBpZiAoaXNGdW5jdGlvbih1c2VyRGVmKSkge1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gc2hvdWxkQ2FjaGVcbiAgICAgICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgICAgICAgIDogbm9vcDtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gICAgfVxuICAgIGlmIChzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID09PSBub29wKSB7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuJDIoYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLmAsIHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGVwLnRhcmdldC5vblRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdE1ldGhvZHModm0sIG1ldGhvZHMpIHtcbiAgICBjb25zdCBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kc1trZXldfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2AsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuYCwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSBpbiB2bSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYE1ldGhvZCBcIiR7a2V5fVwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kJDEobWV0aG9kc1trZXldLCB2bSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdFdhdGNoKHZtLCB3YXRjaCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgICAgICBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICAgICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3RhdGVNaXhpbihWdWUpIHtcbiAgICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gICAgY29uc3QgZGF0YURlZiA9IHt9O1xuICAgIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuICAgIGNvbnN0IHByb3BzRGVmID0ge307XG4gICAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gICAgfTtcbiAgICB7XG4gICAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FybiQyKCdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJywgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4kMihgJHByb3BzIGlzIHJlYWRvbmx5LmAsIHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG4gICAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGBjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXCIke3dhdGNoZXIuZXhwcmVzc2lvbn1cImA7XG4gICAgICAgICAgICBwdXNoVGFyZ2V0KCk7XG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xuICAgICAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSh2bSkge1xuICAgIGNvbnN0IHByb3ZpZGVPcHRpb24gPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICAgIGlmIChwcm92aWRlT3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVkID0gaXNGdW5jdGlvbihwcm92aWRlT3B0aW9uKVxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9uLmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVPcHRpb247XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdmlkZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlID0gcmVzb2x2ZVByb3ZpZGVkKHZtKTtcbiAgICAgICAgLy8gSUU5IGRvZXNuJ3Qgc3VwcG9ydCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyBzbyB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIGtleXMgb3Vyc2VsdmVzLlxuICAgICAgICBjb25zdCBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVkKSA6IE9iamVjdC5rZXlzKHByb3ZpZGVkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3ZpZGVkLCBrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zKHZtKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoYEF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXCIke2tleX1cImAsIHZtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0KGluamVjdCwgdm0pIHtcbiAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBoYXNTeW1ib2wgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KSA6IE9iamVjdC5rZXlzKGluamVjdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgICAgICBpZiAocHJvdmlkZUtleSBpbiB2bS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZtLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGlzRnVuY3Rpb24ocHJvdmlkZURlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgSW5qZWN0aW9uIFwiJHtrZXl9XCIgbm90IGZvdW5kYCwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGluaXRNaXhpbiQxKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIC8vIGEgdWlkXG4gICAgICAgIHZtLl91aWQgPSB1aWQrKztcbiAgICAgICAgbGV0IHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgIHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7dm0uX3VpZH1gO1xuICAgICAgICAgICAgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke3ZtLl91aWR9YDtcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgZmxhZyB0byBtYXJrIHRoaXMgYXMgYSBWdWUgaW5zdGFuY2Ugd2l0aG91dCBoYXZpbmcgdG8gZG8gaW5zdGFuY2VvZlxuICAgICAgICAvLyBjaGVja1xuICAgICAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgICAgICAvLyBhdm9pZCBpbnN0YW5jZXMgZnJvbSBiZWluZyBvYnNlcnZlZFxuICAgICAgICB2bS5fX3Zfc2tpcCA9IHRydWU7XG4gICAgICAgIC8vIGVmZmVjdCBzY29wZVxuICAgICAgICB2bS5fc2NvcGUgPSBuZXcgRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyk7XG4gICAgICAgIHZtLl9zY29wZS5fdm0gPSB0cnVlO1xuICAgICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMocmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksIG9wdGlvbnMgfHwge30sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgICAgIGluaXRFdmVudHModm0pO1xuICAgICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZUNyZWF0ZScsIHVuZGVmaW5lZCwgZmFsc2UgLyogc2V0Q29udGV4dCAqLyk7XG4gICAgICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2NyZWF0ZWQnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICBtZWFzdXJlKGB2dWUgJHt2bS5fbmFtZX0gaW5pdGAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0gKHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKSk7XG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICBjb25zdCB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICAgICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICAgICAgY29uc3QgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpIHtcbiAgICBsZXQgbW9kaWZpZWQ7XG4gICAgY29uc3QgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICAgIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3QpIHtcbiAgICAgICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgICAgICAgaWYgKCFtb2RpZmllZClcbiAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHt9O1xuICAgICAgICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZDtcbn1cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoZGF0YSwgcHJvcHMsIGNoaWxkcmVuLCBwYXJlbnQsIEN0b3IpIHtcbiAgICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gICAgbGV0IGNvbnRleHRWbTtcbiAgICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gICAgfVxuICAgIGNvbnN0IGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICAgIGNvbnN0IG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgIHRoaXMuc2xvdHMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4kc2xvdHMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgKHRoaXMuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICBpZiAoaXNDb21waWxlZCkge1xuICAgICAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICAgICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMocGFyZW50LCBkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgICAgIHRoaXMuX2MgPSAoYSwgYiwgYywgZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVFbGVtZW50JDEoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgICAgICBpZiAodm5vZGUgJiYgIWlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICB9XG59XG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHRWbSwgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgY29uc3QgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKVxuICAgICAgICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSlcbiAgICAgICAgICAgIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KGRhdGEsIHByb3BzLCBjaGlsZHJlbiwgY29udGV4dFZtLCBDdG9yKTtcbiAgICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgY29uc3Qgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gICAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgICBjb25zdCBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHtcbiAgICAgICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9XG4gICAgICAgICAgICByZW5kZXJDb250ZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKHRvLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fX25hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xufVxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbmNvbnN0IGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gICAgaW5pdCh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgICAgICAgY29uc3QgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCBhY3RpdmVJbnN0YW5jZSkpO1xuICAgICAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGF0Y2gob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjb25zdCBjaGlsZCA9ICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoY2hpbGQsIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICAgICApO1xuICAgIH0sXG4gICAgaW5zZXJ0KHZub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbEhvb2skMShjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgICAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3kodm5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBjb21wb25lbnRJbnN0YW5jZSB9ID0gdm5vZGU7XG4gICAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcbiAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgICB9XG4gICAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAgIC8vIHJlamVjdC5cbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgd2FybiQyKGBJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiAke1N0cmluZyhDdG9yKX1gLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzeW5jIGNvbXBvbmVudFxuICAgIGxldCBhc3luY0ZhY3Rvcnk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgICAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgICAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgICAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGFzeW5jRmFjdG9yeSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAgIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG4gICAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gICAgfVxuICAgIC8vIGV4dHJhY3QgcHJvcHNcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gICAgY29uc3QgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAgIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgICAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuICAgICAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICAgIGNvbnN0IHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKEN0b3Iub3B0aW9ucykgfHwgdGFnO1xuICAgIGNvbnN0IHZub2RlID0gbmV3IFZOb2RlKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBgdnVlLWNvbXBvbmVudC0ke0N0b3IuY2lkfSR7bmFtZSA/IGAtJHtuYW1lfWAgOiAnJ31gLCBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgeyBDdG9yLCBwcm9wc0RhdGEsIGxpc3RlbmVycywgdGFnLCBjaGlsZHJlbiB9LCBhc3luY0ZhY3RvcnkpO1xuICAgIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4vLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbnZub2RlLCBcbi8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxucGFyZW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgICAgICBwYXJlbnRcbiAgICB9O1xuICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gICAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKSB7XG4gICAgY29uc3QgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgICAgY29uc3QgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUhvb2soZjEsIGYyKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gKGEsIGIpID0+IHtcbiAgICAgICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgICAgICBmMShhLCBiKTtcbiAgICAgICAgZjIoYSwgYik7XG4gICAgfTtcbiAgICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwob3B0aW9ucywgZGF0YSkge1xuICAgIGNvbnN0IHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gICAgY29uc3QgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnO1xuICAgIChkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gICAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgIH1cbn1cblxubGV0IHdhcm4kMiA9IG5vb3A7XG5sZXQgdGlwID0gbm9vcDtcbmxldCBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5sZXQgZm9ybWF0Q29tcG9uZW50TmFtZTtcbntcbiAgICBjb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gICAgY29uc3QgY2xhc3NpZnkgPSBzdHIgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xuICAgIHdhcm4kMiA9IChtc2csIHZtID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuICAgICAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW1Z1ZSB3YXJuXTogJHttc2d9JHt0cmFjZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGlwID0gKG1zZywgdm0pID0+IHtcbiAgICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1Z1ZSB0aXBdOiAke21zZ31gICsgKHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gKHZtLCBpbmNsdWRlRmlsZSkgPT4ge1xuICAgICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxSb290Pic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGlzRnVuY3Rpb24odm0pICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICAgICAgICA/IHZtLm9wdGlvbnNcbiAgICAgICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgICAgICAgICAgOiB2bTtcbiAgICAgICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgaWYgKG4gJSAyID09PSAxKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHI7XG4gICAgICAgICAgICBpZiAobiA+IDEpXG4gICAgICAgICAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAodm0pID0+IHtcbiAgICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0cmVlID0gW107XG4gICAgICAgICAgICBsZXQgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgdHJlZVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7aSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpfSR7aXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKX0uLi4gKCR7dm1bMV19IHJlY3Vyc2l2ZSBjYWxscylgXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9YClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXFxuXFxuKGZvdW5kIGluICR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9KWA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xuY29uc3Qgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgICAgIGlmICghdm0pIHtcbiAgICAgICAgICAgIHdhcm4kMihgb3B0aW9uIFwiJHtrZXl9XCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgYCArXG4gICAgICAgICAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKTtcbiAgICB9O1xufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhKHRvLCBmcm9tLCByZWN1cnNpdmUgPSB0cnVlKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gdG87XG4gICAgbGV0IGtleSwgdG9WYWwsIGZyb21WYWw7XG4gICAgY29uc3Qga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgICAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgICAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufVxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCwgaXNGdW5jdGlvbihwYXJlbnRWYWwpID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlRGF0YSA9IGlzRnVuY3Rpb24oY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdERhdGEgPSBpc0Z1bmN0aW9uKHBhcmVudFZhbClcbiAgICAgICAgICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuJDIoJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAnZGVmaW5pdGlvbnMuJywgdm0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xufTtcbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUxpZmVjeWNsZUhvb2socGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIGNvbnN0IHJlcyA9IGNoaWxkVmFsXG4gICAgICAgID8gcGFyZW50VmFsXG4gICAgICAgICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICAgICAgICA6IGlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICAgICAgICAgIDogW2NoaWxkVmFsXVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICByZXR1cm4gcmVzID8gZGVkdXBlSG9va3MocmVzKSA6IHJlcztcbn1cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzKGhvb2tzKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChob29rID0+IHtcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUxpZmVjeWNsZUhvb2s7XG59KTtcbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgICBpZiAoY2hpbGRWYWwpIHtcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcbiAgICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICAgIC8vQHRzLWV4cGVjdC1lcnJvciB3b3JrIGFyb3VuZFxuICAgIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKVxuICAgICAgICBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7XG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXG4gICAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaClcbiAgICAgICAgY2hpbGRWYWwgPSB1bmRlZmluZWQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZFZhbClcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICAgIHtcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKVxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZFZhbCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gcmV0W2tleV07XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICAgICAgfVxuICAgICAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuICAgIHN0cmF0cy5tZXRob2RzID1cbiAgICAgICAgc3RyYXRzLmluamVjdCA9XG4gICAgICAgICAgICBzdHJhdHMuY29tcHV0ZWQgPVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZhbCAmJiB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5zdHJhdHMucHJvdmlkZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgaWYgKCFwYXJlbnRWYWwpXG4gICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBtZXJnZURhdGEocmV0LCBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbCk7XG4gICAgICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgICAgICAgbWVyZ2VEYXRhKHJldCwgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsIGZhbHNlIC8vIG5vbi1yZWN1cnNpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuY29uc3QgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xufTtcbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyhvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKSB7XG4gICAgaWYgKCFuZXcgUmVnRXhwKGBeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV8ke3VuaWNvZGVSZWdFeHAuc291cmNlfV0qJGApLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybiQyKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgK1xuICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJyk7XG4gICAgfVxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgICAgd2FybiQyKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgJ2lkOiAnICtcbiAgICAgICAgICAgIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zLCB2bSkge1xuICAgIGNvbnN0IHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgbGV0IGksIHZhbCwgbmFtZTtcbiAgICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4kMigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbCkgPyB2YWwgOiB7IHR5cGU6IHZhbCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuJDIoYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcInByb3BzXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShwcm9wcyl9LmAsIHZtKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3Qob3B0aW9ucywgdm0pIHtcbiAgICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgICBpZiAoIWluamVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAob3B0aW9ucy5pbmplY3QgPSB7fSk7XG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICAgICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4kMihgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiaW5qZWN0XCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShpbmplY3QpfS5gLCB2bSk7XG4gICAgfVxufVxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEob3B0aW9ucykge1xuICAgIGNvbnN0IGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGlycykge1xuICAgICAgICAgICAgY29uc3QgZGVmID0gZGlyc1trZXldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGVmKSkge1xuICAgICAgICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZShuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4kMihgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiJHtuYW1lfVwiOiBleHBlY3RlZCBhbiBPYmplY3QsIGAgK1xuICAgICAgICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUodmFsdWUpfS5gLCB2bSk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcbiAgICB7XG4gICAgICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG4gICAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xuICAgIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAgIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICAgICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICAgICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcbiAgICAgICAgY29uc3Qgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsIHR5cGUsIGlkLCB3YXJuTWlzc2luZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbaWRdO1xuICAgIGNvbnN0IGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdO1xuICAgIGNvbnN0IFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKVxuICAgICAgICByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gICAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gICAgY29uc3QgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICAgIHdhcm4kMignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICBjb25zdCBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgICAvLyBib29sZWFuIGNhc3RpbmdcbiAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICAgICAgY29uc3QgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAgIG9ic2VydmUodmFsdWUpO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgICAgICB3YXJuJDIoJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgK1xuICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICdcIjogJyArXG4gICAgICAgICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcbiAgICB9XG4gICAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgICBpZiAodm0gJiZcbiAgICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdm0uX3Byb3BzW2tleV07XG4gICAgfVxuICAgIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gICAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICAgIHJldHVybiBpc0Z1bmN0aW9uKGRlZikgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgICAgID8gZGVmLmNhbGwodm0pXG4gICAgICAgIDogZGVmO1xufVxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AocHJvcCwgbmFtZSwgdmFsdWUsIHZtLCBhYnNlbnQpIHtcbiAgICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICAgICAgd2FybiQyKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLCB2bSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IHByb3AudHlwZTtcbiAgICBsZXQgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGF2ZUV4cGVjdGVkVHlwZXMgPSBleHBlY3RlZFR5cGVzLnNvbWUodCA9PiB0KTtcbiAgICBpZiAoIXZhbGlkICYmIGhhdmVFeHBlY3RlZFR5cGVzKSB7XG4gICAgICAgIHdhcm4kMihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLCB2bSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsIHZtKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIHZtKSB7XG4gICAgbGV0IHZhbGlkO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHdhcm4kMignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQsXG4gICAgICAgIGV4cGVjdGVkVHlwZVxuICAgIH07XG59XG5jb25zdCBmdW5jdGlvblR5cGVDaGVja1JFID0gL15cXHMqZnVuY3Rpb24gKFxcdyspLztcbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUoZm4pIHtcbiAgICBjb25zdCBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goZnVuY3Rpb25UeXBlQ2hlY2tSRSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBpZiAoIWlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xuICAgICAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKX1gO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpfWA7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7c3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKX0uYDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIH1cbn1cbmNvbnN0IEVYUExJQ0FCTEVfVFlQRVMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEVYUExJQ0FCTEVfVFlQRVMuc29tZShlbGVtID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xufVxuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpKSB7XG4gICAgICAgIHdhcm4kMignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxuaW5pdE1peGluJDEoVnVlKTtcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcbnN0YXRlTWl4aW4oVnVlKTtcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcbmV2ZW50c01peGluKFZ1ZSk7XG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXG5saWZlY3ljbGVNaXhpbihWdWUpO1xuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxucmVuZGVyTWl4aW4oVnVlKTtcblxuZnVuY3Rpb24gaW5pdFVzZShWdWUpIHtcbiAgICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gdGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKTtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdE1peGluKFZ1ZSkge1xuICAgIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQoVnVlKSB7XG4gICAgLyoqXG4gICAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgICAqL1xuICAgIFZ1ZS5jaWQgPSAwO1xuICAgIGxldCBjaWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICovXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBTdXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgICAgIGNvbnN0IGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICAgICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZXh0ZW5kT3B0aW9ucykgfHwgZ2V0Q29tcG9uZW50TmFtZShTdXBlci5vcHRpb25zKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICAgICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICBpbml0UHJvcHMoU3ViKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGluaXRDb21wdXRlZChTdWIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICAgICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcbiAgICAgICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgICAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG4gICAgICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgICAgICByZXR1cm4gU3ViO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbml0UHJvcHMoQ29tcCkge1xuICAgIGNvbnN0IHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBgX3Byb3BzYCwga2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQoQ29tcCkge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIG5vdCBleGFjdCBzYW1lIHR5cGVcbiAgICAgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiBpc0Z1bmN0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldENvbXBvbmVudE5hbWUob3B0cykge1xuICAgIHJldHVybiBvcHRzICYmIChnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyk7XG59XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcnVuZUNhY2hlKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCB7IGNhY2hlLCBrZXlzLCBfdm5vZGUgfSA9IGtlZXBBbGl2ZUluc3RhbmNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZW50cnkubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBjdXJyZW50KSB7XG4gICAgY29uc3QgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgIGlmIChlbnRyeSAmJiAoIWN1cnJlbnQgfHwgZW50cnkudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICAgIGVudHJ5LmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgfVxuICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgIHJlbW92ZSQyKGtleXMsIGtleSk7XG59XG5jb25zdCBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcbi8vIFRPRE8gZGVmaW5lQ29tcG9uZW50XG52YXIgS2VlcEFsaXZlID0ge1xuICAgIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICBwcm9wczoge1xuICAgICAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGNhY2hlVk5vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlLCBrZXlzLCB2bm9kZVRvQ2FjaGUsIGtleVRvQ2FjaGUgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodm5vZGVUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0YWcsIGNvbXBvbmVudEluc3RhbmNlLCBjb21wb25lbnRPcHRpb25zIH0gPSB2bm9kZVRvQ2FjaGU7XG4gICAgICAgICAgICAgICAgY2FjaGVba2V5VG9DYWNoZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IF9nZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5VG9DYWNoZSk7XG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgICAgIHRoaXMuJHdhdGNoKCdpbmNsdWRlJywgdmFsID0+IHtcbiAgICAgICAgICAgIHBydW5lQ2FjaGUodGhpcywgbmFtZSA9PiBtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+ICFtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xuICAgIH0sXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlLCBrZXlzIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgICAgICAgICA/IC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50T3B0aW9ucy50YWcgPyBgOjoke2NvbXBvbmVudE9wdGlvbnMudGFnfWAgOiAnJylcbiAgICAgICAgICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICAgICAgICByZW1vdmUkMihrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsYXkgc2V0dGluZyB0aGUgY2FjaGUgdW50aWwgdXBkYXRlXG4gICAgICAgICAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleVRvQ2FjaGUgPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbiB2bm9kZS5kYXRhIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSk7XG4gICAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgIEtlZXBBbGl2ZVxufTtcblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSShWdWUpIHtcbiAgICAvLyBjb25maWdcbiAgICBjb25zdCBjb25maWdEZWYgPSB7fTtcbiAgICBjb25maWdEZWYuZ2V0ID0gKCkgPT4gY29uZmlnO1xuICAgIHtcbiAgICAgICAgY29uZmlnRGVmLnNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIHdhcm4kMignRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG4gICAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gICAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gICAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgICBWdWUudXRpbCA9IHtcbiAgICAgICAgd2Fybjogd2FybiQyLFxuICAgICAgICBleHRlbmQsXG4gICAgICAgIG1lcmdlT3B0aW9ucyxcbiAgICAgICAgZGVmaW5lUmVhY3RpdmVcbiAgICB9O1xuICAgIFZ1ZS5zZXQgPSBzZXQ7XG4gICAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcbiAgICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgICBWdWUub2JzZXJ2YWJsZSA9IChvYmopID0+IHtcbiAgICAgICAgb2JzZXJ2ZShvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9KTtcbiAgICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gICAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gICAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG4gICAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcbiAgICBpbml0VXNlKFZ1ZSk7XG4gICAgaW5pdE1peGluKFZ1ZSk7XG4gICAgaW5pdEV4dGVuZChWdWUpO1xuICAgIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dDtcbiAgICB9XG59KTtcbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICAgIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5WdWUudmVyc2lvbiA9IHZlcnNpb247XG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG5jb25zdCBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG5jb25zdCBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbmNvbnN0IG11c3RVc2VQcm9wID0gKHRhZywgdHlwZSwgYXR0cikgPT4ge1xuICAgIHJldHVybiAoKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSAmJiB0eXBlICE9PSAnYnV0dG9uJykgfHxcbiAgICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAgICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJykpO1xufTtcbmNvbnN0IGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcbmNvbnN0IGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcbmNvbnN0IGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgICA/ICdmYWxzZSdcbiAgICAgICAgOiAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICAgICAgICAgIGtleSA9PT0gJ2NvbnRlbnRlZGl0YWJsZScgJiYgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICA6ICd0cnVlJztcbn07XG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcCgnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAgICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAgICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsJyArXG4gICAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnKTtcbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5jb25zdCBpc1hsaW5rID0gKG5hbWUpID0+IHtcbiAgICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnO1xufTtcbmNvbnN0IGdldFhsaW5rUHJvcCA9IChuYW1lKSA9PiB7XG4gICAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnO1xufTtcbmNvbnN0IGlzRmFsc3lBdHRyVmFsdWUgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlKHZub2RlKSB7XG4gICAgbGV0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwYXJlbnROb2RlLnBhcmVudCBub3QgVk5vZGVXaXRoRGF0YVxuICAgIHdoaWxlIChpc0RlZigocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkpIHtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcyk7XG59XG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YShjaGlsZCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICAgICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKSA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXSA6IHBhcmVudC5jbGFzc1xuICAgIH07XG59XG5mdW5jdGlvbiByZW5kZXJDbGFzcyhzdGF0aWNDbGFzcywgZHluYW1pY0NsYXNzKSB7XG4gICAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPyAoYiA/IGEgKyAnICcgKyBiIDogYSkgOiBiIHx8ICcnO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3ModmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGxldCBzdHJpbmdpZmllZDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaXNEZWYoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAocmVzKVxuICAgICAgICAgICAgICAgIHJlcyArPSAnICc7XG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xuICAgICAgICAgICAgcmVzICs9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBuYW1lc3BhY2VNYXAgPSB7XG4gICAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcbmNvbnN0IGlzSFRNTFRhZyA9IG1ha2VNYXAoJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAgICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAgICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAgICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCcpO1xuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuY29uc3QgaXNTVkcgPSBtYWtlTWFwKCdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICAgJ2ZvcmVpZ25vYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JywgdHJ1ZSk7XG5jb25zdCBpc1ByZVRhZyA9ICh0YWcpID0+IHRhZyA9PT0gJ3ByZSc7XG5jb25zdCBpc1Jlc2VydmVkVGFnID0gKHRhZykgPT4ge1xuICAgIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpO1xufTtcbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSh0YWcpIHtcbiAgICBpZiAoaXNTVkcodGFnKSkge1xuICAgICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgfVxuICAgIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAgIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICAgICAgcmV0dXJuICdtYXRoJztcbiAgICB9XG59XG5jb25zdCB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQodGFnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXTtcbiAgICB9XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID1cbiAgICAgICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpO1xuICAgIH1cbn1cbmNvbnN0IGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgd2FybiQyKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgdm5vZGUpIHtcbiAgICBjb25zdCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgICAgICByZXR1cm4gZWxtO1xuICAgIH1cbiAgICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICAgIGlmICh2bm9kZS5kYXRhICYmXG4gICAgICAgIHZub2RlLmRhdGEuYXR0cnMgJiZcbiAgICAgICAgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgfVxuICAgIHJldHVybiBlbG07XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xufVxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuZnVuY3Rpb24gdGFnTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZTtcbn1cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUobm9kZSwgc2NvcGVJZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbnZhciByZWYgPSB7XG4gICAgY3JlYXRlKF8sIHZub2RlKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95KHZub2RlKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcmVnaXN0ZXJSZWYodm5vZGUsIGlzUmVtb3ZhbCkge1xuICAgIGNvbnN0IHJlZiA9IHZub2RlLmRhdGEucmVmO1xuICAgIGlmICghaXNEZWYocmVmKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZtID0gdm5vZGUuY29udGV4dDtcbiAgICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzUmVtb3ZhbCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgICBjb25zdCAkcmVmc1ZhbHVlID0gaXNSZW1vdmFsID8gdW5kZWZpbmVkIDogcmVmVmFsdWU7XG4gICAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhyZWYsIHZtLCBbdmFsdWVdLCB2bSwgYHRlbXBsYXRlIHJlZiBmdW5jdGlvbmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzRm9yID0gdm5vZGUuZGF0YS5yZWZJbkZvcjtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSB0eXBlb2YgcmVmID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmVmID09PSAnbnVtYmVyJztcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGNvbnN0IHJlZnMgPSB2bS4kcmVmcztcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgICBpZiAoaXNGb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCkge1xuICAgICAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZSQyKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZXR1cFJlZih2bSwgcmVmLCByZWZzW3JlZl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwgJiYgcmVmc1tyZWZdICE9PSByZWZWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZnNbcmVmXSA9ICRyZWZzVmFsdWU7XG4gICAgICAgICAgICBzZXRTZXR1cFJlZih2bSwgcmVmLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsICYmIHJlZi52YWx1ZSAhPT0gcmVmVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4kMihgSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTogJHt0eXBlb2YgcmVmfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2V0dXBSZWYoeyBfc2V0dXBTdGF0ZSB9LCBrZXksIHZhbCkge1xuICAgIGlmIChfc2V0dXBTdGF0ZSAmJiBoYXNPd24oX3NldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgaWYgKGlzUmVmKF9zZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgICAgICBfc2V0dXBTdGF0ZVtrZXldLnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3NldHVwU3RhdGVba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcbmNvbnN0IGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5mdW5jdGlvbiBzYW1lVm5vZGUoYSwgYikge1xuICAgIHJldHVybiAoYS5rZXkgPT09IGIua2V5ICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICAoKGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpKSB8fFxuICAgICAgICAgICAgKGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiYgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcikpKSk7XG59XG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlKGEsIGIpIHtcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHR5cGVBID0gaXNEZWYoKGkgPSBhLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkuYXR0cnMpKSAmJiBpLnR5cGU7XG4gICAgY29uc3QgdHlwZUIgPSBpc0RlZigoaSA9IGIuZGF0YSkpICYmIGlzRGVmKChpID0gaS5hdHRycykpICYmIGkudHlwZTtcbiAgICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IChpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQikpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICBsZXQgaSwga2V5O1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICAgICAgaWYgKGlzRGVmKGtleSkpXG4gICAgICAgICAgICBtYXBba2V5XSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uKGJhY2tlbmQpIHtcbiAgICBsZXQgaSwgajtcbiAgICBjb25zdCBjYnMgPSB7fTtcbiAgICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoZWwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkge1xuICAgICAgICByZXR1cm4gKCFpblZQcmUgJiZcbiAgICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnO1xuICAgICAgICAgICAgICAgIH0pKSAmJlxuICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKSk7XG4gICAgfVxuICAgIGxldCBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQsIG93bmVyQXJyYXksIGluZGV4KSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgdGFnID0gdm5vZGUudGFnO1xuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50KHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgICAgbGV0IGkgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKSB7XG4gICAgICAgICAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgICAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgICAgIGxldCBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGlubmVyTm9kZS5kYXRhKSkgJiYgaXNEZWYoKGkgPSBpLnRyYW5zaXRpb24pKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnQocGFyZW50LCBlbG0sIHJlZikge1xuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZikgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQYXRjaGFibGUodm5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKVxuICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSlcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICBmdW5jdGlvbiBzZXRTY29wZSh2bm9kZSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuZm5TY29wZUlkKSkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBhbmNlc3Rvci5jb250ZXh0KSkgJiYgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICAgICAgaWYgKGlzRGVmKChpID0gYWN0aXZlSW5zdGFuY2UpKSAmJlxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICAgICAgICBpc0RlZigoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSkge1xuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgICAgIGxldCBpLCBqO1xuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuZGVzdHJveSkpKVxuICAgICAgICAgICAgICAgIGkodm5vZGUpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5jaGlsZHJlbikpKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sodm5vZGUsIHJtKSB7XG4gICAgICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkgJiZcbiAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuX3Zub2RlKSkgJiZcbiAgICAgICAgICAgICAgICBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5yZW1vdmUpKSkge1xuICAgICAgICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4ocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgICAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgICAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICAgICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICAgIGxldCBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG4gICAgICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgICAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICAgIGNvbnN0IGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcbiAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJyR7a2V5fScuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5gLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBvbGRDaFtpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgb3duZXJBcnJheSwgaW5kZXgsIHJlbW92ZU9ubHkpIHtcbiAgICAgICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbG0gPSAodm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAgICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnByZXBhdGNoKSkpIHtcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkudXBkYXRlKSkpXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5wb3N0cGF0Y2gpKSlcbiAgICAgICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gICAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gICAgY29uc3QgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gICAgZnVuY3Rpb24gaHlkcmF0ZShlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgeyB0YWcsIGRhdGEsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKVxuICAgICAgICAgICAgICAgIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmKChpID0gaS5kb21Qcm9wcykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuaW5uZXJIVE1MKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAoIWlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSlcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIFxuICAgICAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSkpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgICAgIHJldHVybiB2bm9kZS5lbG07XG4gICAgfTtcbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXModm5vZGUpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaXMgbm90IFZOb2RlV2l0aERhdGFcbiAgICAgICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgY29uc3QgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgICBjb25zdCBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyhvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICAgIGNvbnN0IG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG4gICAgY29uc3QgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgICBjb25zdCBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuICAgIGxldCBrZXksIG9sZERpciwgZGlyO1xuICAgIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgICAgICBjYWxsSG9vayhkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgICAgICBjYWxsSG9vayhkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2FsbEluc2VydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbEluc2VydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbEhvb2soZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgICAgICAgY2FsbEhvb2sob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyhkaXJzLCB2bSkge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCFkaXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBsZXQgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgICAgIGlmICh2bS5fc2V0dXBTdGF0ZSAmJiB2bS5fc2V0dXBTdGF0ZS5fX3NmYykge1xuICAgICAgICAgICAgY29uc3Qgc2V0dXBEZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bSwgJ19zZXR1cFN0YXRlJywgJ3YtJyArIGRpci5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dXBEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkaXIuZGVmID0ge1xuICAgICAgICAgICAgICAgICAgICBiaW5kOiBzZXR1cERlZixcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBzZXR1cERlZixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyLmRlZiA9IHNldHVwRGVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpci5kZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lKGRpcikge1xuICAgIHJldHVybiAoZGlyLnJhd05hbWUgfHwgYCR7ZGlyLm5hbWV9LiR7T2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpfWApO1xufVxuZnVuY3Rpb24gY2FsbEhvb2soZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIGNvbnN0IGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICAgIGlmIChmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgYGRpcmVjdGl2ZSAke2Rpci5uYW1lfSAke2hvb2t9IGhvb2tgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW3JlZiwgZGlyZWN0aXZlcyQxXTtcblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleSwgY3VyLCBvbGQ7XG4gICAgY29uc3QgZWxtID0gdm5vZGUuZWxtO1xuICAgIGNvbnN0IG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICBsZXQgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pIHx8IGlzVHJ1ZShhdHRycy5fdl9hdHRyX3Byb3h5KSkge1xuICAgICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICAgICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICAgICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAgIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzSW5QcmUpIHtcbiAgICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCcgPyAndHJ1ZScgOiBrZXk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmXG4gICAgICAgICAgICAhaXNJRTkgJiZcbiAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJlxuICAgICAgICAgICAgdmFsdWUgIT09ICcnICYmXG4gICAgICAgICAgICAhZWwuX19pZXBoKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja2VyID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgICAgfVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxudmFyIGF0dHJzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gICAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJlxuICAgICAgICAoaXNVbmRlZihvbGREYXRhKSB8fFxuICAgICAgICAgICAgKGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiYgaXNVbmRlZihvbGREYXRhLmNsYXNzKSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gICAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuICAgIC8vIHNldCB0aGUgY2xhc3NcbiAgICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICAgIH1cbn1cbnZhciBrbGFzcyQxID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gICAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyhleHApIHtcbiAgICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBpblJlZ2V4ID0gZmFsc2U7XG4gICAgbGV0IGN1cmx5ID0gMDtcbiAgICBsZXQgc3F1YXJlID0gMDtcbiAgICBsZXQgcGFyZW4gPSAwO1xuICAgIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJldiA9IGM7XG4gICAgICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluU2luZ2xlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluUmVnZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSAweDdjICYmIC8vIHBpcGVcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3YyAmJlxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdjICYmXG4gICAgICAgICAgICAhY3VybHkgJiZcbiAgICAgICAgICAgICFzcXVhcmUgJiZcbiAgICAgICAgICAgICFwYXJlbikge1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyMjpcbiAgICAgICAgICAgICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXCJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjc6XG4gICAgICAgICAgICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vICdcbiAgICAgICAgICAgICAgICBjYXNlIDB4NjA6XG4gICAgICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYFxuICAgICAgICAgICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4rKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIChcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgICAgICAgICAgIHBhcmVuLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyApXG4gICAgICAgICAgICAgICAgY2FzZSAweDViOlxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFtcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWQ6XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXVxuICAgICAgICAgICAgICAgIGNhc2UgMHg3YjpcbiAgICAgICAgICAgICAgICAgICAgY3VybHkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4N2Q6XG4gICAgICAgICAgICAgICAgICAgIGN1cmx5LS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZikge1xuICAgICAgICAgICAgICAgIC8vIC9cbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xuICAgICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uO1xufVxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlcikge1xuICAgIGNvbnN0IGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgICAgICByZXR1cm4gYF9mKFwiJHtmaWx0ZXJ9XCIpKCR7ZXhwfSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgICAgIHJldHVybiBgX2YoXCIke25hbWV9XCIpKCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YDtcbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2Fybihtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcihgW1Z1ZSBjb21waWxlcl06ICR7bXNnfWApO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbihtb2R1bGVzLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlcyA/IG1vZHVsZXMubWFwKG0gPT4gbVtrZXldKS5maWx0ZXIoXyA9PiBfKSA6IFtdO1xufVxuZnVuY3Rpb24gYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gICAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSwgZHluYW1pYyB9LCByYW5nZSkpO1xuICAgIGVsLnBsYWluID0gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICBjb25zdCBhdHRycyA9IGR5bmFtaWNcbiAgICAgICAgPyBlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKVxuICAgICAgICA6IGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKTtcbiAgICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbn1cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0cihlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gICAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSB9LCByYW5nZSkpO1xufVxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWNBcmcsIG1vZGlmaWVycywgcmFuZ2UpIHtcbiAgICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgICAgICBuYW1lLFxuICAgICAgICByYXdOYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYXJnLFxuICAgICAgICBpc0R5bmFtaWNBcmcsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlcihzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pYyA/IGBfcCgke25hbWV9LFwiJHtzeW1ib2x9XCIpYCA6IHN5bWJvbCArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG59XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpbXBvcnRhbnQsIHdhcm4sIHJhbmdlLCBkeW5hbWljKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh3YXJuICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICAgIHdhcm4oXCJwYXNzaXZlIGFuZCBwcmV2ZW50IGNhbid0IGJlIHVzZWQgdG9nZXRoZXIuIFwiICtcbiAgICAgICAgICAgIFwiUGFzc2l2ZSBoYW5kbGVyIGNhbid0IHByZXZlbnQgZGVmYXVsdCBldmVudC5cIiwgcmFuZ2UpO1xuICAgIH1cbiAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAgIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOigke25hbWV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nbW91c2V1cCc6KCR7bmFtZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgICAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBsZXQgZXZlbnRzO1xuICAgIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICAgIH1cbiAgICBjb25zdCBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYyB9LCByYW5nZSk7XG4gICAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICAgIH1cbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIoZWwsIG5hbWUpIHtcbiAgICByZXR1cm4gKGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyKGVsLCBuYW1lLCBnZXRTdGF0aWMpIHtcbiAgICBjb25zdCBkeW5hbWljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSwgcmVtb3ZlRnJvbU1hcCkge1xuICAgIGxldCB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICAgICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIG5hbWUpIHtcbiAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGxpc3RbaV07XG4gICAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlU2V0SXRlbShpdGVtLCByYW5nZSkge1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xuICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBtb2RpZmllcnMgfHwge307XG4gICAgY29uc3QgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIGxldCB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICAgICAgICBgKHR5cGVvZiAke2Jhc2VWYWx1ZUV4cHJlc3Npb259ID09PSAnc3RyaW5nJ2AgK1xuICAgICAgICAgICAgICAgIGA/ICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0udHJpbSgpYCArXG4gICAgICAgICAgICAgICAgYDogJHtiYXNlVmFsdWVFeHByZXNzaW9ufSlgO1xuICAgIH1cbiAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgICB9XG4gICAgY29uc3QgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICAgIGVsLm1vZGVsID0ge1xuICAgICAgICB2YWx1ZTogYCgke3ZhbHVlfSlgLFxuICAgICAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgICAgIGNhbGxiYWNrOiBgZnVuY3Rpb24gKCR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pIHske2Fzc2lnbm1lbnR9fWBcbiAgICB9O1xufVxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpIHtcbiAgICBjb25zdCByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9PSR7YXNzaWdubWVudH1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAkc2V0KCR7cmVzLmV4cH0sICR7cmVzLmtleX0sICR7YXNzaWdubWVudH0pYDtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cbmxldCBsZW4sIHN0ciwgY2hyLCBpbmRleCwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcbmZ1bmN0aW9uIHBhcnNlTW9kZWwodmFsKSB7XG4gICAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gICAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gICAgdmFsID0gdmFsLnRyaW0oKTtcbiAgICBsZW4gPSB2YWwubGVuZ3RoO1xuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgICAgaW5kZXggPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCArIDEpICsgJ1wiJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgICAgICAgICAga2V5OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0ciA9IHZhbDtcbiAgICBpbmRleCA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICAgIGNociA9IG5leHQoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hyID09PSAweDViKSB7XG4gICAgICAgICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5leHQoKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xufVxuZnVuY3Rpb24gZW9mKCkge1xuICAgIHJldHVybiBpbmRleCA+PSBsZW47XG59XG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0KGNocikge1xuICAgIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3O1xufVxuZnVuY3Rpb24gcGFyc2VCcmFja2V0KGNocikge1xuICAgIGxldCBpbkJyYWNrZXQgPSAxO1xuICAgIGV4cHJlc3Npb25Qb3MgPSBpbmRleDtcbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICAgIGNociA9IG5leHQoKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHIgPT09IDB4NWIpXG4gICAgICAgICAgICBpbkJyYWNrZXQrKztcbiAgICAgICAgaWYgKGNociA9PT0gMHg1ZClcbiAgICAgICAgICAgIGluQnJhY2tldC0tO1xuICAgICAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKGNocikge1xuICAgIGNvbnN0IHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCB3YXJuJDE7XG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxuY29uc3QgUkFOR0VfVE9LRU4gPSAnX19yJztcbmNvbnN0IENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5mdW5jdGlvbiBtb2RlbCQxKGVsLCBkaXIsIF93YXJuKSB7XG4gICAgd2FybiQxID0gX3dhcm47XG4gICAgY29uc3QgdmFsdWUgPSBkaXIudmFsdWU7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICBjb25zdCB0YWcgPSBlbC50YWc7XG4gICAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gICAge1xuICAgICAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHdhcm4kMShgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIiB0eXBlPVwiZmlsZVwiPjpcXG5gICtcbiAgICAgICAgICAgICAgICBgRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLCBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4kMShgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIj46IGAgK1xuICAgICAgICAgICAgYHYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gYCArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXQncyByZWNvbW1lbmRlZCB0byBcIiArXG4gICAgICAgICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLCBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddKTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgY29uc3QgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgICBjb25zdCB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICAgIGNvbnN0IGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCBgQXJyYXkuaXNBcnJheSgke3ZhbHVlfSlgICtcbiAgICAgICAgYD9faSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pPi0xYCArXG4gICAgICAgICh0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICAgID8gYDooJHt2YWx1ZX0pYFxuICAgICAgICAgICAgOiBgOl9xKCR7dmFsdWV9LCR7dHJ1ZVZhbHVlQmluZGluZ30pYCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBgdmFyICQkYT0ke3ZhbHVlfSxgICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgYCQkYz0kJGVsLmNoZWNrZWQ/KCR7dHJ1ZVZhbHVlQmluZGluZ30pOigke2ZhbHNlVmFsdWVCaW5kaW5nfSk7YCArXG4gICAgICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgICBgdmFyICQkdj0ke251bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nfSxgICtcbiAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgICAgYGlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKX0pfWAgK1xuICAgICAgICBgZWxzZXskJGk+LTEmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKX0pfWAgK1xuICAgICAgICBgfWVsc2V7JHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpfX1gLCBudWxsLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcbiAgICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICBsZXQgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyBgX24oJHt2YWx1ZUJpbmRpbmd9KWAgOiB2YWx1ZUJpbmRpbmc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCBgX3EoJHt2YWx1ZX0sJHt2YWx1ZUJpbmRpbmd9KWApO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcbiAgICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICBjb25zdCBzZWxlY3RlZFZhbCA9IGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCArXG4gICAgICAgIGAuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KWAgK1xuICAgICAgICBgLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO2AgK1xuICAgICAgICBgcmV0dXJuICR7bnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCd9fSlgO1xuICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICBsZXQgY29kZSA9IGB2YXIgJCRzZWxlY3RlZFZhbCA9ICR7c2VsZWN0ZWRWYWx9O2A7XG4gICAgY29kZSA9IGAke2NvZGV9ICR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpfWA7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gICAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAgIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgICB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICAgICAgY29uc3QgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0eXBlQmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICAgICAgICB3YXJuJDEoYCR7YmluZGluZ309XCIke3ZhbHVlfVwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBgICtcbiAgICAgICAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGxhenksIG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIGNvbnN0IG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgICBjb25zdCBldmVudCA9IGxhenkgPyAnY2hhbmdlJyA6IHR5cGUgPT09ICdyYW5nZScgPyBSQU5HRV9UT0tFTiA6ICdpbnB1dCc7XG4gICAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgICBpZiAodHJpbSkge1xuICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPSBgJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClgO1xuICAgIH1cbiAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgICB9XG4gICAgbGV0IGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICAgICAgY29kZSA9IGBpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47JHtjb2RlfWA7XG4gICAgfVxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIGAoJHt2YWx1ZX0pYCk7XG4gICAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICAgIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbn1cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyhvbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICAgICAgY29uc3QgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgICAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgICAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICAgIH1cbn1cbmxldCB0YXJnZXQ7XG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZShldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG5jb25zdCB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuZnVuY3Rpb24gYWRkKG5hbWUsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUpIHtcbiAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAgIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAgICAgICAgIC8vIGJhaWwgZm9yIGVudmlyb25tZW50cyB0aGF0IGhhdmUgYnVnZ3kgZXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgICAgICAgICBlLnRpbWVTdGFtcCA8PSAwIHx8XG4gICAgICAgICAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IGNhcHR1cmUsIHBhc3NpdmUgfSA6IGNhcHR1cmUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpIHtcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIGNvbnN0IG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgICAvLyB2bm9kZSBpcyBlbXB0eSB3aGVuIHJlbW92aW5nIGFsbCBsaXN0ZW5lcnMsXG4gICAgLy8gYW5kIHVzZSBvbGQgdm5vZGUgZG9tIGVsZW1lbnRcbiAgICB0YXJnZXQgPSB2bm9kZS5lbG0gfHwgb2xkVm5vZGUuZWxtO1xuICAgIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gICAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bm9kZS5jb250ZXh0KTtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG52YXIgZXZlbnRzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZW1wdHlOb2RlIGhhcyBhY3R1YWxseSBkYXRhXG4gICAgZGVzdHJveTogKHZub2RlKSA9PiB1cGRhdGVET01MaXN0ZW5lcnModm5vZGUsIGVtcHR5Tm9kZSlcbn07XG5cbmxldCBzdmdDb250YWluZXI7XG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleSwgY3VyO1xuICAgIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgbGV0IHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSB8fCBpc1RydWUocHJvcHMuX3ZfYXR0cl9wcm94eSkpIHtcbiAgICAgICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICBjb25zdCBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmXG4gICAgICAgICAgICBpc1NWRyhlbG0udGFnTmFtZSkgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IGA8c3ZnPiR7Y3VyfTwvc3ZnPmA7XG4gICAgICAgICAgICBjb25zdCBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldKSB7XG4gICAgICAgICAgICAvLyBzb21lIHByb3BlcnR5IHVwZGF0ZXMgY2FuIHRocm93XG4gICAgICAgICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBjaGVja1ZhbCkge1xuICAgIHJldHVybiAoXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgIWVsbS5jb21wb3NpbmcgJiZcbiAgICAgICAgKGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgICAgICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICAgICAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpKSk7XG59XG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgIGxldCBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgICAvLyAjNjE1N1xuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgIHRyeSB7XG4gICAgICAgIG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsO1xufVxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBuZXdWYWwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbDtcbn1cbnZhciBkb21Qcm9wcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbmNvbnN0IHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgY29uc3QgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gICAgY29uc3QgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufSk7XG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICAgIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xufVxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGJpbmRpbmdTdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZTtcbn1cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBsZXQgc3R5bGVEYXRhO1xuICAgIGlmIChjaGVja0NoaWxkKSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiZcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwYXJlbnROb2RlLnBhcmVudCBub3QgVk5vZGVXaXRoRGF0YVxuICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgICAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgY3NzVmFyUkUgPSAvXi0tLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5jb25zdCBzZXRQcm9wID0gKGVsLCBuYW1lLCB2YWwpID0+IHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbmxldCBlbXB0eVN0eWxlO1xuY29uc3Qgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiBwcm9wIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICAgIGNvbnN0IGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJlxuICAgICAgICBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0eWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXIsIG5hbWU7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgY29uc3Qgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgIGNvbnN0IG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICBjb25zdCBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcbiAgICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgIC8vIHRvIG11dGF0ZSBpdC5cbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXykgPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuICAgIGNvbnN0IG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuICAgIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgICAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgICAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgc3R5bGUkMSA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICAgIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbmNvbnN0IHdoaXRlc3BhY2VSRSQxID0gL1xccysvO1xuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFJDEpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY3VyID0gYCAke2VsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJ30gYDtcbiAgICAgICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSQxKS5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjdXIgPSBgICR7ZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnfSBgO1xuICAgICAgICBjb25zdCB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24oZGVmKSB7XG4gICAgaWYgKCFkZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKTtcbiAgICB9XG59XG5jb25zdCBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChuYW1lID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRlckNsYXNzOiBgJHtuYW1lfS1lbnRlcmAsXG4gICAgICAgIGVudGVyVG9DbGFzczogYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgICAgICBlbnRlckFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgICAgICBsZWF2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZWAsXG4gICAgICAgIGxlYXZlVG9DbGFzczogYCR7bmFtZX0tbGVhdmUtdG9gLFxuICAgICAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgXG4gICAgfTtcbn0pO1xuY29uc3QgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5sZXQgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG5sZXQgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xubGV0IGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbmxldCBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbn1cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuY29uc3QgcmFmID0gaW5Ccm93c2VyXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICAgICAgOiBzZXRUaW1lb3V0XG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmbiA9PiBmbigpO1xuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByYWYoZm4pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIHJlbW92ZSQyKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgY2IpIHtcbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICBjb25zdCBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICBsZXQgZW5kZWQgPSAwO1xuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgICAgICBjYigpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmQgPSBlID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cbmNvbnN0IHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICAgIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgICBjb25zdCBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgdGltZW91dCA9IDA7XG4gICAgbGV0IHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICAgICAgdHlwZSA9XG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICAgIHByb3BDb3VudCxcbiAgICAgICAgaGFzVHJhbnNmb3JtXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKChkLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pO1xuICAgIH0pKTtcbn1cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDA7XG59XG5cbmZ1bmN0aW9uIGVudGVyKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGVsLl9sZWF2ZUNiKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3NzLCB0eXBlLCBlbnRlckNsYXNzLCBlbnRlclRvQ2xhc3MsIGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhckNsYXNzLCBhcHBlYXJUb0NsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcywgYmVmb3JlRW50ZXIsIGVudGVyLCBhZnRlckVudGVyLCBlbnRlckNhbmNlbGxlZCwgYmVmb3JlQXBwZWFyLCBhcHBlYXIsIGFmdGVyQXBwZWFyLCBhcHBlYXJDYW5jZWxsZWQsIGR1cmF0aW9uIH0gPSBkYXRhO1xuICAgIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAgIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICAgIGxldCBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgbGV0IHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICAgIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICAgICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gICAgICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIH1cbiAgICBjb25zdCBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xuICAgIGNvbnN0IGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3MgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gICAgY29uc3QgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3MgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzO1xuICAgIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XG4gICAgY29uc3QgZW50ZXJIb29rID0gaXNBcHBlYXIgPyAoaXNGdW5jdGlvbihhcHBlYXIpID8gYXBwZWFyIDogZW50ZXIpIDogZW50ZXI7XG4gICAgY29uc3QgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhciA/IGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIgOiBhZnRlckVudGVyO1xuICAgIGNvbnN0IGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgICAgID8gYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkXG4gICAgICAgIDogZW50ZXJDYW5jZWxsZWQ7XG4gICAgY29uc3QgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoaXNPYmplY3QoZHVyYXRpb24pID8gZHVyYXRpb24uZW50ZXIgOiBkdXJhdGlvbik7XG4gICAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuICAgIGNvbnN0IGNiID0gKGVsLl9lbnRlckNiID0gb25jZSgoKSA9PiB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gICAgfSkpO1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGVhdmUodm5vZGUsIHJtKSB7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBybSgpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjc3MsIHR5cGUsIGxlYXZlQ2xhc3MsIGxlYXZlVG9DbGFzcywgbGVhdmVBY3RpdmVDbGFzcywgYmVmb3JlTGVhdmUsIGxlYXZlLCBhZnRlckxlYXZlLCBsZWF2ZUNhbmNlbGxlZCwgZGVsYXlMZWF2ZSwgZHVyYXRpb24gfSA9IGRhdGE7XG4gICAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgIGNvbnN0IHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcbiAgICBjb25zdCBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihpc09iamVjdChkdXJhdGlvbikgPyBkdXJhdGlvbi5sZWF2ZSA6IGR1cmF0aW9uKTtcbiAgICBpZiAoaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBjYiA9IChlbC5fbGVhdmVDYiA9IG9uY2UoKCkgPT4ge1xuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICAgIH0pKTtcbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlKCkge1xuICAgICAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICAgICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPVxuICAgICAgICAgICAgICAgIHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2FybiQyKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgJHtuYW1lfSBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gLCB2bm9kZS5jb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICB3YXJuJDIoYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xuICAgICAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLCB2bm9kZS5jb250ZXh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24odmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZm4pIHtcbiAgICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgaW52b2tlckZucyA9IGZuLmZucztcbiAgICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAgICAgLy8gaW52b2tlclxuICAgICAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChBcnJheS5pc0FycmF5KGludm9rZXJGbnMpID8gaW52b2tlckZuc1swXSA6IGludm9rZXJGbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDE7XG4gICAgfVxufVxuZnVuY3Rpb24gX2VudGVyKF8sIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSk7XG4gICAgfVxufVxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXJcbiAgICA/IHtcbiAgICAgICAgY3JlYXRlOiBfZW50ZXIsXG4gICAgICAgIGFjdGl2YXRlOiBfZW50ZXIsXG4gICAgICAgIHJlbW92ZSh2bm9kZSwgcm0pIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbYXR0cnMsIGtsYXNzJDEsIGV2ZW50cywgZG9tUHJvcHMsIHN0eWxlJDEsIHRyYW5zaXRpb25dO1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5jb25zdCBtb2R1bGVzJDEgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcbmNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMkMSB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgICBpbnNlcnRlZChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICAvLyAjNjkwM1xuICAgICAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICAgICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAgICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgICAgICAgIGNvbnN0IHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgY3VyT3B0aW9ucyA9IChlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSkpO1xuICAgICAgICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZSgobywgaSkgPT4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pKSkge1xuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZSh2ID0+IGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcbiAgICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB3YXJuJDIoYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cIiR7YmluZGluZy5leHByZXNzaW9ufVwiPiBgICtcbiAgICAgICAgICAgICAgICBgZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoOCwgLTEpfWAsIHZtKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmV2ZXJ5KG8gPT4gIWxvb3NlRXF1YWwobywgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKG9wdGlvbikge1xuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb24gPyBvcHRpb24uX3ZhbHVlIDogb3B0aW9uLnZhbHVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gICAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZylcbiAgICAgICAgcmV0dXJuO1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuZnVuY3Rpb24gdHJpZ2dlcihlbCwgdHlwZSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICAgIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUodm5vZGUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgICAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgICAgICA6IHZub2RlO1xufVxudmFyIHNob3cgPSB7XG4gICAgYmluZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGlzcGxheSA9IChlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICBlbnRlcih2bm9kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlYXZlKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVuYmluZChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgICAgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICAgIG1vZGVsOiBkaXJlY3RpdmUsXG4gICAgc2hvd1xufTtcblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbmNvbnN0IHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgYXBwZWFyOiBCb29sZWFuLFxuICAgIGNzczogQm9vbGVhbixcbiAgICBtb2RlOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICAgIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQodm5vZGUpIHtcbiAgICBjb25zdCBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEoY29tcCkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBjb25zdCBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgICAvLyBwcm9wc1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgICB9XG4gICAgLy8gZXZlbnRzLlxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgZGF0YVtjYW1lbGl6ZShrZXkpXSA9IGxpc3RlbmVyc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICAgICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICAgICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbih2bm9kZSkge1xuICAgIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSB7XG4gICAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnO1xufVxuY29uc3QgaXNOb3RUZXh0Tm9kZSA9IChjKSA9PiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7XG5jb25zdCBpc1ZTaG93RGlyZWN0aXZlID0gZCA9PiBkLm5hbWUgPT09ICdzaG93JztcbnZhciBUcmFuc2l0aW9uID0ge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIHJlbmRlcihoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgd2FybiQyKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJywgdGhpcy4kcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgICAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xuICAgICAgICAgICAgd2FybiQyKCdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSwgdGhpcy4kcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgICAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgICBjb25zdCBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgICAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgICAgIGNvbnN0IGlkID0gYF9fdHJhbnNpdGlvbi0ke3RoaXMuX3VpZH0tYDtcbiAgICAgICAgY2hpbGQua2V5ID1cbiAgICAgICAgICAgIGNoaWxkLmtleSA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICAgICAgICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICAgICAgICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlkICsgY2hpbGQua2V5XG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGQua2V5O1xuICAgICAgICBjb25zdCBkYXRhID0gKChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID1cbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKSk7XG4gICAgICAgIGNvbnN0IG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICAgIGNvbnN0IG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcbiAgICAgICAgLy8gbWFyayB2LXNob3dcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgICAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZENoaWxkICYmXG4gICAgICAgICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgICAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGxlYXZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlID0gbGVhdmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkO1xuICAgIH1cbn07XG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbmNvbnN0IHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcbmRlbGV0ZSBwcm9wcy5tb2RlO1xudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgICBwcm9wcyxcbiAgICBiZWZvcmVNb3VudCgpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgICB0aGlzLl91cGRhdGUgPSAodm5vZGUsIGh5ZHJhdGluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgICAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgICAgICAgICB0aGlzLl9fcGF0Y2hfXyh0aGlzLl92bm9kZSwgdGhpcy5rZXB0LCBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgICAgICAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdXBkYXRlLmNhbGwodGhpcywgdm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZW5kZXIoaCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9ICh0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gKHRoaXMuY2hpbGRyZW4gPSBbXSk7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICBtYXBbYy5rZXldID0gYztcbiAgICAgICAgICAgICAgICAgICAgKGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gb3B0c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyB8fCAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBjLnRhZztcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKGA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPCR7bmFtZX0+YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGtlcHQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHByZXZDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLmdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBub3QgdHlwZWQgaW4gTm9kZVxuICAgICAgICAgICAgICAgIGMuZGF0YS5wb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwW2Mua2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBrZXB0LnB1c2goYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9LFxuICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZSc7XG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgICAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWxtO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBlbC5zdHlsZTtcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIChlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBoYXNNb3ZlKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgICAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goKGNscykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xuICAgIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xuICAgIGNvbnN0IG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgY29uc3QgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gICAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcyA9IGMuZWxtLnN0eWxlO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgICBUcmFuc2l0aW9uLFxuICAgIFRyYW5zaXRpb25Hcm91cFxufTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwsIGh5ZHJhdGluZykge1xuICAgIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKTtcbn07XG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oYFlvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5gICtcbiAgICAgICAgICAgICAgICBgTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcbmAgK1xuICAgICAgICAgICAgICAgIGBTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbGApO1xuICAgICAgICB9XG4gICAgfSwgMCk7XG59XG5cbmNvbnN0IGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuY29uc3QgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5jb25zdCBidWlsZFJlZ2V4ID0gY2FjaGVkKGRlbGltaXRlcnMgPT4ge1xuICAgIGNvbnN0IG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICAgIGNvbnN0IGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKTtcbn0pO1xuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpIHtcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICAgIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IHJhd1Rva2VucyA9IFtdO1xuICAgIGxldCBsYXN0SW5kZXggPSAodGFnUkUubGFzdEluZGV4ID0gMCk7XG4gICAgbGV0IG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgcmF3VG9rZW5zLnB1c2goKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGFnIHRva2VuXG4gICAgICAgIGNvbnN0IGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgICAgICB0b2tlbnMucHVzaChgX3MoJHtleHB9KWApO1xuICAgICAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICByYXdUb2tlbnMucHVzaCgodG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICAgICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgICAgIHRva2VuczogcmF3VG9rZW5zXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxKGVsLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICBjb25zdCBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHdhcm4oYGNsYXNzPVwiJHtzdGF0aWNDbGFzc31cIjogYCArXG4gICAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcy5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpKTtcbiAgICB9XG4gICAgY29uc3QgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gICAgaWYgKGNsYXNzQmluZGluZykge1xuICAgICAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuRGF0YSQyKGVsKSB7XG4gICAgbGV0IGRhdGEgPSAnJztcbiAgICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICAgICAgZGF0YSArPSBgc3RhdGljQ2xhc3M6JHtlbC5zdGF0aWNDbGFzc30sYDtcbiAgICB9XG4gICAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgICAgICBkYXRhICs9IGBjbGFzczoke2VsLmNsYXNzQmluZGluZ30sYDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG52YXIga2xhc3MgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgICBnZW5EYXRhOiBnZW5EYXRhJDJcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUoZWwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIGNvbnN0IHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gICAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgd2Fybihgc3R5bGU9XCIke3N0YXRpY1N0eWxlfVwiOiBgICtcbiAgICAgICAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJywgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gICAgaWYgKHN0eWxlQmluZGluZykge1xuICAgICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuRGF0YSQxKGVsKSB7XG4gICAgbGV0IGRhdGEgPSAnJztcbiAgICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICAgICAgZGF0YSArPSBgc3RhdGljU3R5bGU6JHtlbC5zdGF0aWNTdHlsZX0sYDtcbiAgICB9XG4gICAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgICAgICBkYXRhICs9IGBzdHlsZTooJHtlbC5zdHlsZUJpbmRpbmd9KSxgO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbnZhciBzdHlsZSA9IHtcbiAgICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gICAgdHJhbnNmb3JtTm9kZSxcbiAgICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbmxldCBkZWNvZGVyO1xudmFyIGhlID0ge1xuICAgIGRlY29kZShodG1sKSB7XG4gICAgICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50O1xuICAgIH1cbn07XG5cbmNvbnN0IGlzVW5hcnlUYWcgPSBtYWtlTWFwKCdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInKTtcbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuY29uc3QgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnKTtcbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuY29uc3QgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAgICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAgICd0aXRsZSx0cix0cmFjaycpO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbmNvbnN0IGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuY29uc3QgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rP1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBuY25hbWUgPSBgW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aJHt1bmljb2RlUmVnRXhwLnNvdXJjZX1dKmA7XG5jb25zdCBxbmFtZUNhcHR1cmUgPSBgKCg/OiR7bmNuYW1lfVxcXFw6KT8ke25jbmFtZX0pYDtcbmNvbnN0IHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoYF48JHtxbmFtZUNhcHR1cmV9YCk7XG5jb25zdCBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG5jb25zdCBlbmRUYWcgPSBuZXcgUmVnRXhwKGBePFxcXFwvJHtxbmFtZUNhcHR1cmV9W14+XSo+YCk7XG5jb25zdCBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuY29uc3QgY29tbWVudCA9IC9ePCFcXC0tLztcbmNvbnN0IGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG5jb25zdCBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbmNvbnN0IHJlQ2FjaGUgPSB7fTtcbmNvbnN0IGRlY29kaW5nTWFwID0ge1xuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAnJiM5Oyc6ICdcXHQnLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG59O1xuY29uc3QgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG5jb25zdCBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG4vLyAjNTk5MlxuY29uc3QgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSAodGFnLCBodG1sKSA9PiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7XG5mdW5jdGlvbiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICAgIGNvbnN0IHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBtYXRjaCA9PiBkZWNvZGluZ01hcFttYXRjaF0pO1xufVxuZnVuY3Rpb24gcGFyc2VIVE1MKGh0bWwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGNvbnN0IGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gICAgY29uc3QgaXNVbmFyeVRhZyA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgICBjb25zdCBjYW5CZUxlZnRPcGVuVGFnID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGxhc3QsIGxhc3RUYWc7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgICAgbGFzdCA9IGh0bWw7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50ICYmIG9wdGlvbnMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRleHQsIHJlc3QsIG5leHQ7XG4gICAgICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fFxuICAgICAgICAgICAgICAgIChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICAgICAgICBodG1sID0gcmVzdDtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMud2FybihgTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcIiR7aHRtbH1cImAsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICAgIHBhcnNlRW5kVGFnKCk7XG4gICAgZnVuY3Rpb24gYWR2YW5jZShuKSB7XG4gICAgICAgIGluZGV4ICs9IG47XG4gICAgICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZygpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgICAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBlbmQsIGF0dHI7XG4gICAgICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJlxuICAgICAgICAgICAgICAgIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgICBjb25zdCB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcbiAgICAgICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWcodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuYXJ5ID0gaXNVbmFyeVRhZyh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG4gICAgICAgIGNvbnN0IGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhZzogdGFnTmFtZSxcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBtYXRjaC5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICAgICAgZW5kID0gaW5kZXg7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLndhcm4oYHRhZyA8JHtzdGFja1tpXS50YWd9PiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhY2tbaV0uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHN0YWNrW2ldLmVuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICAgICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBvblJFID0gL15AfF52LW9uOi87XG5jb25zdCBkaXJSRSA9IC9edi18XkB8Xjp8XiMvO1xuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuY29uc3QgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuY29uc3QgYXJnUkUgPSAvOiguKikkLztcbmNvbnN0IGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbmNvbnN0IG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcbmNvbnN0IHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuY29uc3QgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1sgXFxmXFx0XFxyXFxuXSsvZztcbmNvbnN0IGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5jb25zdCBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5jb25zdCBlbXB0eVNsb3RTY29wZVRva2VuID0gYF9lbXB0eV9gO1xuLy8gY29uZmlndXJhYmxlIHN0YXRlXG5sZXQgd2FybjtcbmxldCBkZWxpbWl0ZXJzO1xubGV0IHRyYW5zZm9ybXM7XG5sZXQgcHJlVHJhbnNmb3JtcztcbmxldCBwb3N0VHJhbnNmb3JtcztcbmxldCBwbGF0Zm9ybUlzUHJlVGFnO1xubGV0IHBsYXRmb3JtTXVzdFVzZVByb3A7XG5sZXQgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5sZXQgbWF5YmVDb21wb25lbnQ7XG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIHBhcmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICAgIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICAgIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gICAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICBtYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISEoZWwuY29tcG9uZW50IHx8XG4gICAgICAgIGVsLmF0dHJzTWFwWyc6aXMnXSB8fFxuICAgICAgICBlbC5hdHRyc01hcFsndi1iaW5kOmlzJ10gfHxcbiAgICAgICAgIShlbC5hdHRyc01hcC5pcyA/IGlzUmVzZXJ2ZWRUYWcoZWwuYXR0cnNNYXAuaXMpIDogaXNSZXNlcnZlZFRhZyhlbC50YWcpKSk7XG4gICAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgY29uc3QgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICAgIGNvbnN0IHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gICAgbGV0IHJvb3Q7XG4gICAgbGV0IGN1cnJlbnRQYXJlbnQ7XG4gICAgbGV0IGluVlByZSA9IGZhbHNlO1xuICAgIGxldCBpblByZSA9IGZhbHNlO1xuICAgIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiB3YXJuT25jZShtc2csIHJhbmdlKSB7XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgd2Fybihtc2csIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShgQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuYCwgeyBzdGFydDogZWxlbWVudC5zdGFydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJztcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihjID0+ICFjLnNsb3RTY29wZSk7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UoZWwpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICAgICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsKSB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGBDYW5ub3QgdXNlIDwke2VsLnRhZ30+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgYCArXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJywgeyBzdGFydDogZWwuc3RhcnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZSgnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJywgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgICAgICB3YXJuLFxuICAgICAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICAgICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgICAgICBzdGFydCh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICBjb25zdCBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoKGN1bXVsYXRlZCwgYXR0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5gLCBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoYFtgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3YXJuKCdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYDwke3RhZ30+YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLCB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgICAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKHRhZywgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJzKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuT25jZSgnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJywgeyBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Fybk9uY2UoYHRleHQgXCIke3RleHR9XCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLmAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpc0lFICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgICAgICAgICA/IHRleHRcbiAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fFxuICAgICAgICAgICAgICAgICAgICAhY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnQodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1ByZShlbCkge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgICAgIGVsLnByZSA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzKGVsKSB7XG4gICAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gKGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICAgICAgZWwucGxhaW4gPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgZWxlbWVudC5wbGFpbiA9XG4gICAgICAgICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5zY29wZWRTbG90cyAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NLZXkoZWwpIHtcbiAgICBjb25zdCBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICAgIGlmIChleHApIHtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICAgIHdhcm4oYDx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5gLCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9PT0gZXhwICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLmAsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksIHRydWUgLyogdGlwICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWwua2V5ID0gZXhwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZWYoZWwpIHtcbiAgICBjb25zdCByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICAgIGlmIChyZWYpIHtcbiAgICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NGb3IoZWwpIHtcbiAgICBsZXQgZXhwO1xuICAgIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogJHtleHB9YCwgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VGb3IoZXhwKSB7XG4gICAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgY29uc3QgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgICBjb25zdCBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0lmKGVsKSB7XG4gICAgY29uc3QgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICAgIGVsLmlmID0gZXhwO1xuICAgICAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgICAgICAgZXhwOiBleHAsXG4gICAgICAgICAgICBibG9jazogZWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICAgICAgaWYgKGVsc2VpZikge1xuICAgICAgICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbCwgcGFyZW50KSB7XG4gICAgY29uc3QgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICAgIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICAgICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuKGB2LSR7ZWwuZWxzZWlmID8gJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJyA6ICdlbHNlJ30gYCArXG4gICAgICAgICAgICBgdXNlZCBvbiBlbGVtZW50IDwke2VsLnRhZ30+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLmAsIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQoY2hpbGRyZW4pIHtcbiAgICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgd2FybihgdGV4dCBcIiR7Y2hpbGRyZW5baV0udGV4dC50cmltKCl9XCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdpbGwgYmUgaWdub3JlZC5gLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uKGVsLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlKGVsKSB7XG4gICAgY29uc3Qgb25jZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgICBpZiAob25jZSAhPSBudWxsKSB7XG4gICAgICAgIGVsLm9uY2UgPSB0cnVlO1xuICAgIH1cbn1cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQoZWwpIHtcbiAgICBsZXQgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuKGB0aGUgXCJzY29wZVwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBgICtcbiAgICAgICAgICAgICAgICBgcmVwbGFjZWQgYnkgXCJzbG90LXNjb3BlXCIgc2luY2UgMi41LiBUaGUgbmV3IFwic2xvdC1zY29wZVwiIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICAgICAgICBgY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIGAgK1xuICAgICAgICAgICAgICAgIGBkZW5vdGUgc2NvcGVkIHNsb3RzLmAsIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgICAgICAgIHdhcm4oYEFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8JHtlbC50YWd9PiBgICtcbiAgICAgICAgICAgICAgICBgKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIGAgK1xuICAgICAgICAgICAgICAgIGBzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuYCwgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cbiAgICAvLyBzbG90PVwieHh4XCJcbiAgICBjb25zdCBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gICAge1xuICAgICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGA8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgcmVjZWl2aW5nIGNvbXBvbmVudGAsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgICAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5gLCBzbG90QmluZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLmAsIHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Q29udGFpbmVyID0gKHNsb3RzW25hbWVdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpKTtcbiAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNsb3ROYW1lKGJpbmRpbmcpIHtcbiAgICBsZXQgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgICAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXJuKGB2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5gLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAgICAgPyAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgICAgICAgeyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgICAgIDogLy8gc3RhdGljIG5hbWVcbiAgICAgICAgICAgIHsgbmFtZTogYFwiJHtuYW1lfVwiYCwgZHluYW1pYzogZmFsc2UgfTtcbn1cbi8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICAgIGlmIChlbC5rZXkpIHtcbiAgICAgICAgICAgIHdhcm4oYFxcYGtleVxcYCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIGAgK1xuICAgICAgICAgICAgICAgIGBhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBgICtcbiAgICAgICAgICAgICAgICBgVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuYCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50KGVsKSB7XG4gICAgbGV0IGJpbmRpbmc7XG4gICAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgICAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICAgIH1cbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICAgICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyhlbCkge1xuICAgIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgbGV0IGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgICAgICAvLyBtb2RpZmllcnNcbiAgICAgICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIHYtYmluZFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcInYtYmluZDoke25hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnaW5uZXJIVE1MJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYCRldmVudGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBgdXBkYXRlOiR7Y2FtZWxpemUobmFtZSl9YCwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIGB1cGRhdGU6JHtoeXBoZW5hdGUobmFtZSl9YCwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSGFuZGxlcihlbCwgYFwidXBkYXRlOlwiKygke25hbWV9KWAsIHN5bmNHZW4sIG51bGwsIGZhbHNlLCB3YXJuLCBsaXN0W2ldLCB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gdi1vblxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgJHtuYW1lfT1cIiR7dmFsdWV9XCI6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLCBsaXN0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICAgICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbkZvcihlbCkge1xuICAgIGxldCBwYXJlbnQgPSBlbDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICBtYXRjaC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwKGF0dHJzKSB7XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlKSB7XG4gICAgICAgICAgICB3YXJuKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcoZWwpIHtcbiAgICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSc7XG59XG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyhlbCkge1xuICAgIHJldHVybiAoZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmXG4gICAgICAgICAgICAoIWVsLmF0dHJzTWFwLnR5cGUgfHwgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpKSk7XG59XG5jb25zdCBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuY29uc3QgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyhhdHRycykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSkge1xuICAgIGxldCBfZWwgPSBlbDtcbiAgICB3aGlsZSAoX2VsKSB7XG4gICAgICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm4oYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgICAgICAgICAgICBgWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBgICtcbiAgICAgICAgICAgICAgICBgd3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gYCArXG4gICAgICAgICAgICAgICAgYENvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLmAsIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ10pO1xuICAgICAgICB9XG4gICAgICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5bmFtaWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlKGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgICBjb25zdCBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICAgICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlQmluZGluZztcbiAgICAgICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgICAgICAgdHlwZUJpbmRpbmcgPSBgKCR7bWFwWyd2LWJpbmQnXX0pLnR5cGVgO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gYCYmKCR7aWZDb25kaXRpb259KWAgOiBgYDtcbiAgICAgICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICAgICAgICBjb25zdCBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgICAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgICAgICAgIGJyYW5jaDAuaWYgPSBgKCR7dHlwZUJpbmRpbmd9KT09PSdjaGVja2JveCdgICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICAgICAgICBjb25zdCBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICAgICAgICBleHA6IGAoJHt0eXBlQmluZGluZ30pPT09J3JhZGlvJ2AgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIDMuIG90aGVyXG4gICAgICAgICAgICBjb25zdCBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudChlbCkge1xuICAgIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudCk7XG59XG52YXIgbW9kZWwgPSB7XG4gICAgcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMgPSBba2xhc3MsIHN0eWxlLCBtb2RlbF07XG5cbmZ1bmN0aW9uIHRleHQoZWwsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWUpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaHRtbChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICAgIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgbW9kZWw6IG1vZGVsJDEsXG4gICAgdGV4dCxcbiAgICBodG1sXG59O1xuXG5jb25zdCBiYXNlT3B0aW9ucyA9IHtcbiAgICBleHBlY3RIVE1MOiB0cnVlLFxuICAgIG1vZHVsZXMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBpc1ByZVRhZyxcbiAgICBpc1VuYXJ5VGFnLFxuICAgIG11c3RVc2VQcm9wLFxuICAgIGNhbkJlTGVmdE9wZW5UYWcsXG4gICAgaXNSZXNlcnZlZFRhZyxcbiAgICBnZXRUYWdOYW1lc3BhY2UsXG4gICAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyQxKG1vZHVsZXMpXG59O1xuXG5sZXQgaXNTdGF0aWNLZXk7XG5sZXQgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuY29uc3QgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzKTtcbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJldHVybjtcbiAgICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgICBtYXJrU3RhdGljKHJvb3QpO1xuICAgIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyhrZXlzKSB7XG4gICAgcmV0dXJuIG1ha2VNYXAoJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKSk7XG59XG5mdW5jdGlvbiBtYXJrU3RhdGljKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgICAgICBpZiAoIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgICAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBtYXJrU3RhdGljKGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaztcbiAgICAgICAgICAgICAgICBtYXJrU3RhdGljKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyhub2RlLCBpc0luRm9yKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICAgICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgICAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgICAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgICAgIGlmIChub2RlLnN0YXRpYyAmJlxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgICAgICEobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzKSkge1xuICAgICAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbCA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpYyhub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgICAgICAvLyBleHByZXNzaW9uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAvLyB0ZXh0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHxcbiAgICAgICAgKCFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAgICAgICAgICFub2RlLmlmICYmXG4gICAgICAgICAgICAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgICAgICAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgICAgICAgICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAgICAgICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpKSk7XG59XG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbmNvbnN0IGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbmNvbnN0IHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xuY29uc3Qga2V5Q29kZXMgPSB7XG4gICAgZXNjOiAyNyxcbiAgICB0YWI6IDksXG4gICAgZW50ZXI6IDEzLFxuICAgIHNwYWNlOiAzMixcbiAgICB1cDogMzgsXG4gICAgbGVmdDogMzcsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgIGRlbGV0ZTogWzgsIDQ2XVxufTtcbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbmNvbnN0IGtleU5hbWVzID0ge1xuICAgIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICAgIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gICAgdGFiOiAnVGFiJyxcbiAgICBlbnRlcjogJ0VudGVyJyxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICAgIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICAgIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gICAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICAgIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICAgZGVsZXRlOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuY29uc3QgZ2VuR3VhcmQgPSBjb25kaXRpb24gPT4gYGlmKCR7Y29uZGl0aW9ufSlyZXR1cm4gbnVsbDtgO1xuY29uc3QgbW9kaWZpZXJDb2RlID0ge1xuICAgIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgICBzZWxmOiBnZW5HdWFyZChgJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRgKSxcbiAgICBjdHJsOiBnZW5HdWFyZChgISRldmVudC5jdHJsS2V5YCksXG4gICAgc2hpZnQ6IGdlbkd1YXJkKGAhJGV2ZW50LnNoaWZ0S2V5YCksXG4gICAgYWx0OiBnZW5HdWFyZChgISRldmVudC5hbHRLZXlgKSxcbiAgICBtZXRhOiBnZW5HdWFyZChgISRldmVudC5tZXRhS2V5YCksXG4gICAgbGVmdDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwYCksXG4gICAgbWlkZGxlOiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFgKSxcbiAgICByaWdodDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyYClcbn07XG5mdW5jdGlvbiBnZW5IYW5kbGVycyhldmVudHMsIGlzTmF0aXZlKSB7XG4gICAgY29uc3QgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICAgIGxldCBzdGF0aWNIYW5kbGVycyA9IGBgO1xuICAgIGxldCBkeW5hbWljSGFuZGxlcnMgPSBgYDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgICAgICAgZHluYW1pY0hhbmRsZXJzICs9IGAke25hbWV9LCR7aGFuZGxlckNvZGV9LGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBgXCIke25hbWV9XCI6JHtoYW5kbGVyQ29kZX0sYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNIYW5kbGVycyA9IGB7JHtzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSl9fWA7XG4gICAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgYF9kKCR7c3RhdGljSGFuZGxlcnN9LFske2R5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSl9XSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgIHJldHVybiBgWyR7aGFuZGxlci5tYXAoaGFuZGxlciA9PiBnZW5IYW5kbGVyKGhhbmRsZXIpKS5qb2luKCcsJyl9XWA7XG4gICAgfVxuICAgIGNvbnN0IGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG4gICAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfWAgOiBoYW5kbGVyLnZhbHVlfX1gOyAvLyBpbmxpbmUgc3RhdGVtZW50XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY29kZSA9ICcnO1xuICAgICAgICBsZXQgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gaGFuZGxlci5tb2RpZmllcnM7XG4gICAgICAgICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5TW9kaWZpZXIgPT4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoa2V5TW9kaWZpZXIgPT4gYCRldmVudC4ke2tleU1vZGlmaWVyfUtleWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCd8fCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICAgICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgICAgICAgID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9LmFwcGx5KG51bGwsIGFyZ3VtZW50cylgXG4gICAgICAgICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgPyBgcmV0dXJuICgke2hhbmRsZXIudmFsdWV9KS5hcHBseShudWxsLCBhcmd1bWVudHMpYFxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gXG4gICAgICAgICAgICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGBmdW5jdGlvbigkZXZlbnQpeyR7Y29kZX0ke2hhbmRsZXJDb2RlfX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbktleUZpbHRlcihrZXlzKSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgYGlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmYCArXG4gICAgICAgIGAke2tleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJyl9KXJldHVybiBudWxsO2ApO1xufVxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZShrZXkpIHtcbiAgICBjb25zdCBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoa2V5VmFsKSB7XG4gICAgICAgIHJldHVybiBgJGV2ZW50LmtleUNvZGUhPT0ke2tleVZhbH1gO1xuICAgIH1cbiAgICBjb25zdCBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgICBjb25zdCBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgICByZXR1cm4gKGBfaygkZXZlbnQua2V5Q29kZSxgICtcbiAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5KX0sYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGtleUNvZGUpfSxgICtcbiAgICAgICAgYCRldmVudC5rZXksYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGtleU5hbWUpfWAgK1xuICAgICAgICBgKWApO1xufVxuXG5mdW5jdGlvbiBvbihlbCwgZGlyKSB7XG4gICAgaWYgKGRpci5tb2RpZmllcnMpIHtcbiAgICAgICAgd2FybiQyKGB2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuYCk7XG4gICAgfVxuICAgIGVsLndyYXBMaXN0ZW5lcnMgPSAoY29kZSkgPT4gYF9nKCR7Y29kZX0sJHtkaXIudmFsdWV9KWA7XG59XG5cbmZ1bmN0aW9uIGJpbmQoZWwsIGRpcikge1xuICAgIGVsLndyYXBEYXRhID0gKGNvZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGBfYigke2NvZGV9LCcke2VsLnRhZ30nLCR7ZGlyLnZhbHVlfSwke2Rpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJ30ke2Rpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnfSlgO1xuICAgIH07XG59XG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgICBvbixcbiAgICBiaW5kLFxuICAgIGNsb2FrOiBub29wXG59O1xuXG5jbGFzcyBDb2RlZ2VuU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICAgICAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICAgICAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAgICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcbiAgICAgICAgdGhpcy5vbmNlSWQgPSAwO1xuICAgICAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICAgICAgICB0aGlzLnByZSA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgICBjb25zdCBjb2RlID0gYXN0XG4gICAgICAgID8gYXN0LnRhZyA9PT0gJ3NjcmlwdCdcbiAgICAgICAgICAgID8gJ251bGwnXG4gICAgICAgICAgICA6IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSlcbiAgICAgICAgOiAnX2MoXCJkaXZcIiknO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogYHdpdGgodGhpcyl7cmV0dXJuICR7Y29kZX19YCxcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuRWxlbWVudChlbCwgc3RhdGUpIHtcbiAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICAgIH1cbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgICAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICAgICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlQ29tcG9uZW50ID0gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpO1xuICAgICAgICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIG1heWJlQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZW5EYXRhKGVsLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFnO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBpbiA8c2NyaXB0IHNldHVwPlxuICAgICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBzdGF0ZS5vcHRpb25zLmJpbmRpbmdzO1xuICAgICAgICAgICAgaWYgKG1heWJlQ29tcG9uZW50ICYmIGJpbmRpbmdzICYmIGJpbmRpbmdzLl9faXNTY3JpcHRTZXR1cCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YWcgPSBjaGVja0JpbmRpbmdUeXBlKGJpbmRpbmdzLCBlbC50YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YWcpXG4gICAgICAgICAgICAgICAgdGFnID0gYCcke2VsLnRhZ30nYDtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgICAgICAgIGNvZGUgPSBgX2MoJHt0YWd9JHtkYXRhID8gYCwke2RhdGF9YCA6ICcnIC8vIGRhdGFcbiAgICAgICAgICAgIH0ke2NoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJyAvLyBjaGlsZHJlblxuICAgICAgICAgICAgfSlgO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQmluZGluZ1R5cGUoYmluZGluZ3MsIGtleSkge1xuICAgIGNvbnN0IGNhbWVsTmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgY29uc3QgUGFzY2FsTmFtZSA9IGNhcGl0YWxpemUoY2FtZWxOYW1lKTtcbiAgICBjb25zdCBjaGVja1R5cGUgPSAodHlwZSkgPT4ge1xuICAgICAgICBpZiAoYmluZGluZ3Nba2V5XSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZGluZ3NbY2FtZWxOYW1lXSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbWVsTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZGluZ3NbUGFzY2FsTmFtZV0gPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXNjYWxOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmcm9tQ29uc3QgPSBjaGVja1R5cGUoXCJzZXR1cC1jb25zdFwiIC8qIEJpbmRpbmdUeXBlcy5TRVRVUF9DT05TVCAqLykgfHxcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtcmVhY3RpdmUtY29uc3RcIiAvKiBCaW5kaW5nVHlwZXMuU0VUVVBfUkVBQ1RJVkVfQ09OU1QgKi8pO1xuICAgIGlmIChmcm9tQ29uc3QpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Db25zdDtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heWJlUmVmID0gY2hlY2tUeXBlKFwic2V0dXAtbGV0XCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX0xFVCAqLykgfHxcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtcmVmXCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX1JFRiAqLykgfHxcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtbWF5YmUtcmVmXCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX01BWUJFX1JFRiAqLyk7XG4gICAgaWYgKGZyb21NYXliZVJlZikge1xuICAgICAgICByZXR1cm4gZnJvbU1heWJlUmVmO1xuICAgIH1cbn1cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMoZWwsIHN0YXRlKSB7XG4gICAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gICAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICAgIGNvbnN0IG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gICAgfVxuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKGB3aXRoKHRoaXMpe3JldHVybiAke2dlbkVsZW1lbnQoZWwsIHN0YXRlKX19YCk7XG4gICAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgICByZXR1cm4gYF9tKCR7c3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDF9JHtlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJ30pYDtcbn1cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZShlbCwgc3RhdGUpIHtcbiAgICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgICAgICBsZXQga2V5ID0gJyc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHN0YXRlLndhcm4oYHYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBgLCBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ10pO1xuICAgICAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYF9vKCR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfSwke3N0YXRlLm9uY2VJZCsrfSwke2tleX0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5JZihlbCwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpIHtcbiAgICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KTtcbn1cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkge1xuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJztcbiAgICB9XG4gICAgY29uc3QgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmV4cH0pPyR7Z2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spfToke2dlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jayl9YDtcbiAgICB9XG4gICAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGFsdEdlblxuICAgICAgICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgICAgICAgOiBlbC5vbmNlXG4gICAgICAgICAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5Gb3IoZWwsIHN0YXRlLCBhbHRHZW4sIGFsdEhlbHBlcikge1xuICAgIGNvbnN0IGV4cCA9IGVsLmZvcjtcbiAgICBjb25zdCBhbGlhcyA9IGVsLmFsaWFzO1xuICAgIGNvbnN0IGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IGAsJHtlbC5pdGVyYXRvcjF9YCA6ICcnO1xuICAgIGNvbnN0IGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IGAsJHtlbC5pdGVyYXRvcjJ9YCA6ICcnO1xuICAgIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICAgICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgICFlbC5rZXkpIHtcbiAgICAgICAgc3RhdGUud2FybihgPCR7ZWwudGFnfSB2LWZvcj1cIiR7YWxpYXN9IGluICR7ZXhwfVwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggYCArXG4gICAgICAgICAgICBgdi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gYCArXG4gICAgICAgICAgICBgU2VlIGh0dHBzOi8vdjIudnVlanMub3JnL3YyL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5gLCBlbC5yYXdBdHRyc01hcFsndi1mb3InXSwgdHJ1ZSAvKiB0aXAgKi8pO1xuICAgIH1cbiAgICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgICByZXR1cm4gKGAke2FsdEhlbHBlciB8fCAnX2wnfSgoJHtleHB9KSxgICtcbiAgICAgICAgYGZ1bmN0aW9uKCR7YWxpYXN9JHtpdGVyYXRvcjF9JHtpdGVyYXRvcjJ9KXtgICtcbiAgICAgICAgYHJldHVybiAkeyhhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKX1gICtcbiAgICAgICAgJ30pJyk7XG59XG5mdW5jdGlvbiBnZW5EYXRhKGVsLCBzdGF0ZSkge1xuICAgIGxldCBkYXRhID0gJ3snO1xuICAgIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gICAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgICBjb25zdCBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICAgIGlmIChkaXJzKVxuICAgICAgICBkYXRhICs9IGRpcnMgKyAnLCc7XG4gICAgLy8ga2V5XG4gICAgaWYgKGVsLmtleSkge1xuICAgICAgICBkYXRhICs9IGBrZXk6JHtlbC5rZXl9LGA7XG4gICAgfVxuICAgIC8vIHJlZlxuICAgIGlmIChlbC5yZWYpIHtcbiAgICAgICAgZGF0YSArPSBgcmVmOiR7ZWwucmVmfSxgO1xuICAgIH1cbiAgICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICAgICAgZGF0YSArPSBgcmVmSW5Gb3I6dHJ1ZSxgO1xuICAgIH1cbiAgICAvLyBwcmVcbiAgICBpZiAoZWwucHJlKSB7XG4gICAgICAgIGRhdGEgKz0gYHByZTp0cnVlLGA7XG4gICAgfVxuICAgIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICBkYXRhICs9IGB0YWc6XCIke2VsLnRhZ31cIixgO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICAgIH1cbiAgICAvLyBhdHRyaWJ1dGVzXG4gICAgaWYgKGVsLmF0dHJzKSB7XG4gICAgICAgIGRhdGEgKz0gYGF0dHJzOiR7Z2VuUHJvcHMoZWwuYXR0cnMpfSxgO1xuICAgIH1cbiAgICAvLyBET00gcHJvcHNcbiAgICBpZiAoZWwucHJvcHMpIHtcbiAgICAgICAgZGF0YSArPSBgZG9tUHJvcHM6JHtnZW5Qcm9wcyhlbC5wcm9wcyl9LGA7XG4gICAgfVxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKGVsLmV2ZW50cykge1xuICAgICAgICBkYXRhICs9IGAke2dlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpfSxgO1xuICAgIH1cbiAgICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKX0sYDtcbiAgICB9XG4gICAgLy8gc2xvdCB0YXJnZXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gICAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBkYXRhICs9IGBzbG90OiR7ZWwuc2xvdFRhcmdldH0sYDtcbiAgICB9XG4gICAgLy8gc2NvcGVkIHNsb3RzXG4gICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgIGRhdGEgKz0gYCR7Z2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSl9LGA7XG4gICAgfVxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gICAgaWYgKGVsLm1vZGVsKSB7XG4gICAgICAgIGRhdGEgKz0gYG1vZGVsOnt2YWx1ZToke2VsLm1vZGVsLnZhbHVlfSxjYWxsYmFjazoke2VsLm1vZGVsLmNhbGxiYWNrfSxleHByZXNzaW9uOiR7ZWwubW9kZWwuZXhwcmVzc2lvbn19LGA7XG4gICAgfVxuICAgIC8vIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgZGF0YSArPSBgJHtpbmxpbmVUZW1wbGF0ZX0sYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gICAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgICAgICBkYXRhID0gYF9iKCR7ZGF0YX0sXCIke2VsLnRhZ31cIiwke2dlblByb3BzKGVsLmR5bmFtaWNBdHRycyl9KWA7XG4gICAgfVxuICAgIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICAgICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICAgIH1cbiAgICAvLyB2LW9uIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKSB7XG4gICAgY29uc3QgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gICAgaWYgKCFkaXJzKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICAgIGxldCBoYXNSdW50aW1lID0gZmFsc2U7XG4gICAgbGV0IGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gICAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICAgICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICAgICAgICByZXMgKz0gYHtuYW1lOlwiJHtkaXIubmFtZX1cIixyYXdOYW1lOlwiJHtkaXIucmF3TmFtZX1cIiR7ZGlyLnZhbHVlXG4gICAgICAgICAgICAgICAgPyBgLHZhbHVlOigke2Rpci52YWx1ZX0pLGV4cHJlc3Npb246JHtKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpfWBcbiAgICAgICAgICAgICAgICA6ICcnfSR7ZGlyLmFyZyA/IGAsYXJnOiR7ZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiBgXCIke2Rpci5hcmd9XCJgfWAgOiAnJ30ke2Rpci5tb2RpZmllcnMgPyBgLG1vZGlmaWVyczoke0pTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpfWAgOiAnJ319LGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSc7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKSB7XG4gICAgY29uc3QgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gICAgaWYgKChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpKSB7XG4gICAgICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsIHsgc3RhcnQ6IGVsLnN0YXJ0IH0pO1xuICAgIH1cbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpeyR7aW5saW5lUmVuZGVyRm5zLnJlbmRlcn19LHN0YXRpY1JlbmRlckZuczpbJHtpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgICAgICAgICAubWFwKGNvZGUgPT4gYGZ1bmN0aW9uKCl7JHtjb2RlfX1gKVxuICAgICAgICAgICAgLmpvaW4oJywnKX1dfWA7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMoZWwsIHNsb3RzLCBzdGF0ZSkge1xuICAgIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gICAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAgIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgICBsZXQgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fFxuICAgICAgICBPYmplY3Qua2V5cyhzbG90cykuc29tZShrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gKHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHwgc2xvdC5pZiB8fCBzbG90LmZvciB8fCBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgLy8gIzk1MzQ6IGlmIGEgY29tcG9uZW50IHdpdGggc2NvcGVkIHNsb3RzIGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJyYW5jaCxcbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxuICAgIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gICAgLy8gdGhlIGdlbmVyYXRlZCBjb2RlIG9mIGFsbCB0aGUgc2xvdCBjb250ZW50cy5cbiAgICBsZXQgbmVlZHNLZXkgPSAhIWVsLmlmO1xuICAgIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAgIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgICAvLyAjOTQzOCwgIzk1MDZcbiAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICgocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5mb3IpIHtcbiAgICAgICAgICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgICAgIC5tYXAoa2V5ID0+IGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpKVxuICAgICAgICAuam9pbignLCcpO1xuICAgIHJldHVybiBgc2NvcGVkU2xvdHM6X3UoWyR7Z2VuZXJhdGVkU2xvdHN9XSR7bmVlZHNGb3JjZVVwZGF0ZSA/IGAsbnVsbCx0cnVlYCA6IGBgfSR7IW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyBgLG51bGwsZmFsc2UsJHtoYXNoKGdlbmVyYXRlZFNsb3RzKX1gIDogYGB9KWA7XG59XG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZChlbCkge1xuICAgIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZW5TY29wZWRTbG90KGVsLCBzdGF0ZSkge1xuICAgIGNvbnN0IGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBgbnVsbGApO1xuICAgIH1cbiAgICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpO1xuICAgIH1cbiAgICBjb25zdCBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW4gPyBgYCA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICAgIGNvbnN0IGZuID0gYGZ1bmN0aW9uKCR7c2xvdFNjb3BlfSl7YCArXG4gICAgICAgIGByZXR1cm4gJHtlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgICAgICAgICA/IGAoJHtlbC5pZn0pPyR7Z2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ306dW5kZWZpbmVkYFxuICAgICAgICAgICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSl9fWA7XG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgIGNvbnN0IHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IGBgIDogYCxwcm94eTp0cnVlYDtcbiAgICByZXR1cm4gYHtrZXk6JHtlbC5zbG90VGFyZ2V0IHx8IGBcImRlZmF1bHRcImB9LGZuOiR7Zm59JHtyZXZlcnNlUHJveHl9fWA7XG59XG5mdW5jdGlvbiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIGNoZWNrU2tpcCwgYWx0R2VuRWxlbWVudCwgYWx0R2VuTm9kZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlbCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgZWwuZm9yICYmXG4gICAgICAgICAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgICAgIGVsLnRhZyAhPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICAgICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpXG4gICAgICAgICAgICAgICAgICAgID8gYCwxYFxuICAgICAgICAgICAgICAgICAgICA6IGAsMGBcbiAgICAgICAgICAgICAgICA6IGBgO1xuICAgICAgICAgICAgcmV0dXJuIGAkeyhhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSl9JHtub3JtYWxpemF0aW9uVHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgY29uc3QgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgICAgICByZXR1cm4gYFske2NoaWxkcmVuLm1hcChjID0+IGdlbihjLCBzdGF0ZSkpLmpvaW4oJywnKX1dJHtub3JtYWxpemF0aW9uVHlwZSA/IGAsJHtub3JtYWxpemF0aW9uVHlwZX1gIDogJyd9YDtcbiAgICB9XG59XG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIG1heWJlQ29tcG9uZW50KSB7XG4gICAgbGV0IHJlcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiZcbiAgICAgICAgICAgICAgICBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKSkpKSB7XG4gICAgICAgICAgICByZXMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG1heWJlQ29tcG9uZW50KGMuYmxvY2spKSkpIHtcbiAgICAgICAgICAgIHJlcyA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbihlbCkge1xuICAgIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCc7XG59XG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgICAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZW5UZXh0KG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlblRleHQodGV4dCkge1xuICAgIHJldHVybiBgX3YoJHt0ZXh0LnR5cGUgPT09IDJcbiAgICAgICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgICAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKX0pYDtcbn1cbmZ1bmN0aW9uIGdlbkNvbW1lbnQoY29tbWVudCkge1xuICAgIHJldHVybiBgX2UoJHtKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpfSlgO1xufVxuZnVuY3Rpb24gZ2VuU2xvdChlbCwgc3RhdGUpIHtcbiAgICBjb25zdCBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICAgIGxldCByZXMgPSBgX3QoJHtzbG90TmFtZX0ke2NoaWxkcmVuID8gYCxmdW5jdGlvbigpe3JldHVybiAke2NoaWxkcmVufX1gIDogJyd9YDtcbiAgICBjb25zdCBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgICAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGF0dHIgPT4gKHtcbiAgICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICAgIH0pKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGJpbmQgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gICAgaWYgKChhdHRycyB8fCBiaW5kKSAmJiAhY2hpbGRyZW4pIHtcbiAgICAgICAgcmVzICs9IGAsbnVsbGA7XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgICByZXMgKz0gYCwke2F0dHJzfWA7XG4gICAgfVxuICAgIGlmIChiaW5kKSB7XG4gICAgICAgIHJlcyArPSBgJHthdHRycyA/ICcnIDogJyxudWxsJ30sJHtiaW5kfWA7XG4gICAgfVxuICAgIHJldHVybiByZXMgKyAnKSc7XG59XG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQoY29tcG9uZW50TmFtZSwgZWwsIHN0YXRlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgIHJldHVybiBgX2MoJHtjb21wb25lbnROYW1lfSwke2dlbkRhdGEoZWwsIHN0YXRlKX0ke2NoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJ30pYDtcbn1cbmZ1bmN0aW9uIGdlblByb3BzKHByb3BzKSB7XG4gICAgbGV0IHN0YXRpY1Byb3BzID0gYGA7XG4gICAgbGV0IGR5bmFtaWNQcm9wcyA9IGBgO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICAgICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgICAgICAgZHluYW1pY1Byb3BzICs9IGAke3Byb3AubmFtZX0sJHt2YWx1ZX0sYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1Byb3BzICs9IGBcIiR7cHJvcC5uYW1lfVwiOiR7dmFsdWV9LGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljUHJvcHMgPSBgeyR7c3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpfX1gO1xuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGBfZCgke3N0YXRpY1Byb3BzfSxbJHtkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpfV0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0aWNQcm9wcztcbiAgICB9XG59XG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jyk7XG59XG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcbiAgICAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICAgICAgICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJylcbiAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgLmpvaW4oJ1xcXFxifFxcXFxiJykgK1xuICAgICdcXFxcYicpO1xuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbmNvbnN0IHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgK1xuICAgICdkZWxldGUsdHlwZW9mLHZvaWQnLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICtcbiAgICAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyhhc3QsIHdhcm4pIHtcbiAgICBpZiAoYXN0KSB7XG4gICAgICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrTm9kZShub2RlLCB3YXJuKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIGB2LWZvcj1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ3Ytc2xvdCcgfHwgbmFtZVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbih2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAgICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0V2ZW50KGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICBjb25zdCBzdHJpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoICYmIHN0cmlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgICAgIHdhcm4oYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogYCArXG4gICAgICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIiBpbiBleHByZXNzaW9uICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgIH1cbiAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5mdW5jdGlvbiBjaGVja0Zvcihub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIoaWRlbnQsIHR5cGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihgdmFyICR7aWRlbnR9PV9gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgd2FybihgaW52YWxpZCAke3R5cGV9IFwiJHtpZGVudH1cIiBpbiBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfWAsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKGByZXR1cm4gJHtleHB9YCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXG4gICAgICAgICAgICAubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm4oYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgICAgICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIlxcbiAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybihgaW52YWxpZCBleHByZXNzaW9uOiAke2UubWVzc2FnZX0gaW5cXG5cXG5gICtcbiAgICAgICAgICAgICAgICBgICAgICR7ZXhwfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfVxcbmAsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oZXhwLCAnJyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oYGludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfSBpblxcblxcbmAgK1xuICAgICAgICAgICAgYCAgICAke2V4cH1cXG5cXG5gICtcbiAgICAgICAgICAgIGAgIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfVxcbmAsIHJhbmdlKTtcbiAgICB9XG59XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtqICsgMX0ke3JlcGVhdChgIGAsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYCBgLCBwYWQpICsgcmVwZWF0KGBeYCwgbGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYF5gLCBsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgbikge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAobiA+IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgaWYgKG4gJiAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICBuID4+Pj0gMTtcbiAgICAgICAgICAgIGlmIChuIDw9IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGVycm9ycykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goeyBlcnIsIGNvZGUgfSk7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCBvcHRpb25zLCB2bSkge1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCB3YXJuJDI7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgICAgIGNvbnN0IGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICAgICAgICA6IHRlbXBsYXRlO1xuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcGlsZVxuICAgICAgICBjb25zdCBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgICAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke2UubXNnfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksIHZtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuJHt0ZW1wbGF0ZX1cXG5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZSA9PiBgLSAke2V9YCkuam9pbignXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicsIHZtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChlID0+IHRpcChlLm1zZywgdm0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChtc2cgPT4gdGlwKG1zZywgdm0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBmbkdlbkVycm9ycyA9IFtdO1xuICAgICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGNvZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgICAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGZuR2VuRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGVyciwgY29kZSB9KSA9PiBgJHtlcnIudG9TdHJpbmcoKX0gaW5cXG5cXG4ke2NvZGV9XFxuYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGJhc2VDb21waWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBjb25zdCB0aXBzID0gW107XG4gICAgICAgICAgICBsZXQgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IHsgbXNnIH0gOiBtc2c7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID0gKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG4gICAgICAgICAgICBjb25zdCBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21waWxlLFxuICAgICAgICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG5jb25zdCBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzdCxcbiAgICAgICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICAgIH07XG59KTtcblxuY29uc3QgeyBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbnMgfSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmxldCBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUoaHJlZikge1xuICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IGA8YSBocmVmPVwiXFxuXCIvPmAgOiBgPGRpdiBhPVwiXFxuXCIvPmA7XG4gICAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDA7XG59XG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXJcbiAgICA/IGdldFNob3VsZERlY29kZSh0cnVlKVxuICAgIDogZmFsc2U7XG5cbmNvbnN0IGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChpZCA9PiB7XG4gICAgY29uc3QgZWwgPSBxdWVyeShpZCk7XG4gICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTDtcbn0pO1xuY29uc3QgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsLCBoeWRyYXRpbmcpIHtcbiAgICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICB3YXJuJDIoYERvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLmApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHtvcHRpb25zLnRlbXBsYXRlfWAsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgbWVhc3VyZShgdnVlICR7dGhpcy5fbmFtZX0gY29tcGlsZWAsICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZyk7XG59O1xuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICAgIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxufVxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbi8vIGV4cG9ydCB0eXBlIEVmZmVjdFNjaGVkdWxlciA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55XG4vKipcbiAqIEBpbnRlcm5hbCBzaW5jZSB3ZSBhcmUgbm90IGV4cG9zaW5nIHRoaXMgaW4gVnVlIDIsIGl0J3MgdXNlZCBvbmx5IGZvclxuICogaW50ZXJuYWwgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZWZmZWN0KGZuLCBzY2hlZHVsZXIpIHtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBmbiwgbm9vcCwge1xuICAgICAgICBzeW5jOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHNjaGVkdWxlcigoKSA9PiB3YXRjaGVyLnJ1bigpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4dGVuZChWdWUsIHZjYSk7XG5WdWUuZWZmZWN0ID0gZWZmZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uZGV2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuY29tbW9uLmRldi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.common.dev.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.js":
/***/ (function(module, exports, __webpack_require__) {

eval("if (false) {\n  module.exports = require('./vue.common.prod.js')\n} else {\n  module.exports = __webpack_require__(\"./node_modules/vue/dist/vue.common.dev.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcz8yMzcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUksS0FBcUM7QUFDekM7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMkNBQXFCO0FBQ2hEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdnVlLmNvbW1vbi5wcm9kLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi92dWUuY29tbW9uLmRldi5qcycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuY29tbW9uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.common.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ 3:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("./node_modules/vue/dist/vue.common.js");


/***/ })

},[3]);